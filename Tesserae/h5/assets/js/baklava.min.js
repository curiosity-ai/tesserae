/* https://cdn.jsdelivr.net/npm/baklavajs@2.7.0/dist/bundle.js */
"use strict"; var BaklavaJS = (() => {
    var Ls = Object.defineProperty; var _c = Object.getOwnPropertyDescriptor; var yc = Object.getOwnPropertyNames; var Ec = Object.prototype.hasOwnProperty; var Bn = (e, t) => { for (var n in t) Ls(e, n, { get: t[n], enumerable: !0 }) }, bc = (e, t, n, o) => { if (t && typeof t == "object" || typeof t == "function") for (let s of yc(t)) !Ec.call(e, s) && s !== n && Ls(e, s, { get: () => t[s], enumerable: !(o = _c(t, s)) || o.enumerable }); return e }; var Nc = e => bc(Ls({}, "__esModule", { value: !0 }), e); var Qh = {}; Bn(Qh, { Core: () => js, Engine: () => Gs, InterfaceTypes: () => qs, RendererVue: () => yr, createBaklava: () => Zh }); var js = {}; Bn(js, { AbstractNode: () => vn, Connection: () => mn, DummyConnection: () => Jt, DynamicNode: () => ko, Editor: () => Kn, GRAPH_INPUT_NODE_TYPE: () => vt, GRAPH_NODE_TYPE_PREFIX: () => Zt, GRAPH_OUTPUT_NODE_TYPE: () => gt, Graph: () => it, GraphInputNode: () => Vt, GraphOutputNode: () => At, GraphTemplate: () => Qt, Node: () => Mt, NodeInterface: () => ye, createGraphNodeType: () => Bs, defineDynamicNode: () => Tc, defineNode: () => Cc, getGraphNodeTypeString: () => _t }); var De = []; for (let e = 0; e < 256; ++e)De.push((e + 256).toString(16).slice(1)); function Or(e, t = 0) { return (De[e[t + 0]] + De[e[t + 1]] + De[e[t + 2]] + De[e[t + 3]] + "-" + De[e[t + 4]] + De[e[t + 5]] + "-" + De[e[t + 6]] + De[e[t + 7]] + "-" + De[e[t + 8]] + De[e[t + 9]] + "-" + De[e[t + 10]] + De[e[t + 11]] + De[e[t + 12]] + De[e[t + 13]] + De[e[t + 14]] + De[e[t + 15]]).toLowerCase() } var Hs, wc = new Uint8Array(16); function Fs() { if (!Hs) { if (typeof crypto > "u" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"); Hs = crypto.getRandomValues.bind(crypto) } return Hs(wc) } var Oc = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Us = { randomUUID: Oc }; function xc(e, t, n) { if (Us.randomUUID && !t && !e) return Us.randomUUID(); e = e || {}; let o = e.random ?? e.rng?.() ?? Fs(); if (o.length < 16) throw new Error("Random bytes length must be >= 16"); if (o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, t) { if (n = n || 0, n < 0 || n + 16 > t.length) throw new RangeError(`UUID byte range ${n}:${n + 15} is out of buffer bounds`); for (let s = 0; s < 16; ++s)t[n + s] = o[s]; return t } return Or(o) } var Re = xc; var ot = class {
        constructor() { this.listenerMap = new Map, this._listeners = [], this.proxyMap = new Map, this.proxies = [] } get listeners() { return this._listeners.concat(this.proxies.flatMap(t => t())) } subscribe(t, n) {
            this.listenerMap.has(t) && (console.warn(`Already subscribed. Unsubscribing for you.
Please check that you don't accidentally use the same token twice to register two different handlers for the same event/hook.`), this.unsubscribe(t)), this.listenerMap.set(t, n), this._listeners.push(n)
        } unsubscribe(t) { if (this.listenerMap.has(t)) { let n = this.listenerMap.get(t); this.listenerMap.delete(t); let o = this._listeners.indexOf(n); o >= 0 && this._listeners.splice(o, 1) } } registerProxy(t, n) {
            this.proxyMap.has(t) && (console.warn(`Already subscribed. Unsubscribing for you.
Please check that you don't accidentally use the same token twice to register two different proxies for the same event/hook.`), this.unregisterProxy(t)), this.proxyMap.set(t, n), this.proxies.push(n)
        } unregisterProxy(t) { if (!this.proxyMap.has(t)) return; let n = this.proxyMap.get(t); this.proxyMap.delete(t); let o = this.proxies.indexOf(n); o >= 0 && this.proxies.splice(o, 1) }
    }; var te = class extends ot { constructor(t) { super(), this.entity = t } emit(t) { this.listeners.forEach(n => n(t, this.entity)) } }, _e = class extends ot { constructor(t) { super(), this.entity = t } emit(t) { let n = !1, o = () => [n = !0]; for (let s of Array.from(this.listeners.values())) if (s(t, o, this.entity), n) return { prevented: !0 }; return { prevented: !1 } } }; var jn = class extends ot { execute(t, n) { let o = t; for (let s of this.listeners) o = s(o, n); return o } }, Ne = class extends jn { constructor(t) { super(), this.entity = t } execute(t) { return super.execute(t, this.entity) } }, Do = class extends ot { constructor(t) { super(), this.entity = t } execute(t) { let n = []; for (let o of this.listeners) n.push(o(t, this.entity)); return n } }; function st() { let e = Symbol(), t = new Map, n = new Set, o = (l, u) => { u instanceof ot && u.registerProxy(e, () => { var c, d; return (d = (c = t.get(l)) === null || c === void 0 ? void 0 : c.listeners) !== null && d !== void 0 ? d : [] }) }, s = l => { let u = new ot; t.set(l, u), n.forEach(c => o(l, c[l])) }, i = l => { n.add(l); for (let u of t.keys()) o(u, l[u]) }, r = l => { for (let u of t.keys()) l[u] instanceof ot && l[u].unregisterProxy(e); n.delete(l) }, a = () => { n.forEach(l => r(l)), t.clear() }; return new Proxy({}, { get(l, u) { return u === "addTarget" ? i : u === "removeTarget" ? r : u === "destroy" ? a : typeof u != "string" || u.startsWith("_") ? l[u] : (t.has(u) || s(u), t.get(u)) } }) } var mn = class { constructor(t, n) { if (this.destructed = !1, this.events = { destruct: new te(this) }, !t || !n) throw new Error("Cannot initialize connection with null/undefined for 'from' or 'to' values"); this.id = Re(), this.from = t, this.to = n, this.from.connectionCount++, this.to.connectionCount++ } destruct() { this.events.destruct.emit(), this.from.connectionCount--, this.to.connectionCount--, this.destructed = !0 } }, Jt = class { constructor(t, n) { if (!t || !n) throw new Error("Cannot initialize connection with null/undefined for 'from' or 'to' values"); this.id = Re(), this.from = t, this.to = n } }; function Wn(e, t) { return Object.fromEntries(Object.entries(e).map(([n, o]) => [n, t(o)])) } var vn = class { constructor() { this._title = "", this.id = Re(), this.events = { loaded: new te(this), beforeAddInput: new _e(this), addInput: new te(this), beforeRemoveInput: new _e(this), removeInput: new te(this), beforeAddOutput: new _e(this), addOutput: new te(this), beforeRemoveOutput: new _e(this), removeOutput: new te(this), beforeTitleChanged: new _e(this), titleChanged: new te(this), update: new te(this) }, this.hooks = { beforeLoad: new Ne(this), afterSave: new Ne(this) } } get graph() { return this.graphInstance } get title() { return this._title } set title(t) { this.events.beforeTitleChanged.emit(t).prevented || (this._title = t, this.events.titleChanged.emit(t)) } addInput(t, n) { return this.addInterface("input", t, n) } addOutput(t, n) { return this.addInterface("output", t, n) } removeInput(t) { return this.removeInterface("input", t) } removeOutput(t) { return this.removeInterface("output", t) } registerGraph(t) { this.graphInstance = t } load(t) { this.hooks.beforeLoad.execute(t), this.id = t.id, this._title = t.title, Object.entries(t.inputs).forEach(([n, o]) => { this.inputs[n] && (this.inputs[n].load(o), this.inputs[n].nodeId = this.id) }), Object.entries(t.outputs).forEach(([n, o]) => { this.outputs[n] && (this.outputs[n].load(o), this.outputs[n].nodeId = this.id) }), this.events.loaded.emit(this) } save() { let t = Wn(this.inputs, s => s.save()), n = Wn(this.outputs, s => s.save()), o = { type: this.type, id: this.id, title: this.title, inputs: t, outputs: n }; return this.hooks.afterSave.execute(o) } onPlaced() { } onDestroy() { } initializeIo() { Object.entries(this.inputs).forEach(([t, n]) => this.initializeIntf("input", t, n)), Object.entries(this.outputs).forEach(([t, n]) => this.initializeIntf("output", t, n)) } initializeIntf(t, n, o) { o.isInput = t === "input", o.nodeId = this.id, o.events.setValue.subscribe(this, () => this.events.update.emit({ type: t, name: n, intf: o })) } addInterface(t, n, o) { let s = t === "input" ? this.events.beforeAddInput : this.events.beforeAddOutput, i = t === "input" ? this.events.addInput : this.events.addOutput, r = t === "input" ? this.inputs : this.outputs; return s.emit(o).prevented ? !1 : (r[n] = o, this.initializeIntf(t, n, o), i.emit(o), !0) } removeInterface(t, n) { let o = t === "input" ? this.events.beforeRemoveInput : this.events.beforeRemoveOutput, s = t === "input" ? this.events.removeInput : this.events.removeOutput, i = t === "input" ? this.inputs[n] : this.outputs[n]; if (!i || o.emit(i).prevented) return !1; if (i.connectionCount > 0) if (this.graphInstance) this.graphInstance.connections.filter(a => a.from === i || a.to === i).forEach(a => { this.graphInstance.removeConnection(a) }); else throw new Error("Interface is connected, but no graph instance is specified. Unable to delete interface"); return i.events.setValue.unsubscribe(this), t === "input" ? delete this.inputs[n] : delete this.outputs[n], s.emit(i), !0 } }, Mt = class extends vn { load(t) { super.load(t) } save() { return super.save() } }; function Cc(e) { return class extends Mt { constructor() { var t, n; super(), this.type = e.type, this.inputs = {}, this.outputs = {}, this.calculate = e.calculate ? (o, s) => e.calculate.call(this, o, s) : void 0, this._title = (t = e.title) !== null && t !== void 0 ? t : e.type, this.executeFactory("input", e.inputs), this.executeFactory("output", e.outputs), (n = e.onCreate) === null || n === void 0 || n.call(this) } onPlaced() { var t; (t = e.onPlaced) === null || t === void 0 || t.call(this) } onDestroy() { var t; (t = e.onDestroy) === null || t === void 0 || t.call(this) } executeFactory(t, n) { Object.keys(n || {}).forEach(o => { let s = n[o](); t === "input" ? this.addInput(o, s) : this.addOutput(o, s) }) } } } var ko = class extends Mt { }; function Tc(e) { return class extends ko { constructor() { var t, n, o, s; super(), this.type = e.type, this.inputs = {}, this.outputs = {}, this.preventUpdate = !1, this.staticInputKeys = Object.keys((t = e.inputs) !== null && t !== void 0 ? t : {}), this.staticOutputKeys = Object.keys((n = e.outputs) !== null && n !== void 0 ? n : {}), this._title = (o = e.title) !== null && o !== void 0 ? o : e.type, this.executeFactory("input", e.inputs), this.executeFactory("output", e.outputs), e.calculate && (this.calculate = (i, r) => { var a; return (a = e.calculate) === null || a === void 0 ? void 0 : a.call(this, i, r) }), (s = e.onCreate) === null || s === void 0 || s.call(this) } onPlaced() { var t; this.events.update.subscribe(this, n => { n && (n.type === "input" && this.staticInputKeys.includes(n.name) || n.type === "output" && this.staticOutputKeys.includes(n.name)) && this.onUpdate() }), this.onUpdate(), (t = e.onPlaced) === null || t === void 0 || t.call(this) } onDestroy() { var t; (t = e.onDestroy) === null || t === void 0 || t.call(this) } load(t) { this.preventUpdate = !0, this.hooks.beforeLoad.execute(t), this.id = t.id, this.title = t.title; for (let n of this.staticInputKeys) this.inputs[n].load(t.inputs[n]), this.inputs[n].nodeId = this.id; for (let n of this.staticOutputKeys) this.outputs[n].load(t.outputs[n]), this.outputs[n].nodeId = this.id; this.preventUpdate = !1, this.onUpdate(), this.preventUpdate = !0; for (let n of Object.keys(t.inputs)) this.staticInputKeys.includes(n) || (this.inputs[n].load(t.inputs[n]), this.inputs[n].nodeId = this.id); for (let n of Object.keys(t.outputs)) this.staticOutputKeys.includes(n) || (this.outputs[n].load(t.outputs[n]), this.outputs[n].nodeId = this.id); this.preventUpdate = !1, this.events.loaded.emit(this) } onUpdate() { var t, n, o, s; if (this.preventUpdate) return; this.graph && this.graph.activeTransactions++; let i = this.getStaticValues(this.staticInputKeys, this.inputs), r = this.getStaticValues(this.staticOutputKeys, this.outputs), a = e.onUpdate.call(this, i, r); this.updateInterfaces("input", (t = a.inputs) !== null && t !== void 0 ? t : {}, (n = a.forceUpdateInputs) !== null && n !== void 0 ? n : []), this.updateInterfaces("output", (o = a.outputs) !== null && o !== void 0 ? o : {}, (s = a.forceUpdateOutputs) !== null && s !== void 0 ? s : []), this.graph && this.graph.activeTransactions-- } getStaticValues(t, n) { let o = {}; for (let s of t) o[s] = n[s].value; return o } updateInterfaces(t, n, o) { let s = t === "input" ? this.staticInputKeys : this.staticOutputKeys, i = t === "input" ? this.inputs : this.outputs; for (let r of Object.keys(i)) s.includes(r) || n[r] && !o.includes(r) || (t === "input" ? this.removeInput(r) : this.removeOutput(r)); for (let r of Object.keys(n)) { if (i[r]) continue; let a = n[r](); t === "input" ? this.addInput(r, a) : this.addOutput(r, a) } } executeFactory(t, n) { Object.keys(n || {}).forEach(o => { let s = n[o](); t === "input" ? this.addInput(o, s) : this.addOutput(o, s) }) } } } var ye = class { set connectionCount(t) { this._connectionCount = t, this.events.setConnectionCount.emit(t) } get connectionCount() { return this._connectionCount } set value(t) { this.events.beforeSetValue.emit(t).prevented || (this._value = t, this.events.setValue.emit(t)) } get value() { return this._value } constructor(t, n) { this.id = Re(), this.nodeId = "", this.port = !0, this.hidden = !1, this.events = { setConnectionCount: new te(this), beforeSetValue: new _e(this), setValue: new te(this), updated: new te(this) }, this.hooks = { load: new Ne(this), save: new Ne(this) }, this._connectionCount = 0, this.name = t, this._value = n } load(t) { this.id = t.id, this.templateId = t.templateId, this.value = t.value, this.hooks.load.execute(t) } save() { let t = { id: this.id, templateId: this.templateId, value: this.value }; return this.hooks.save.execute(t) } setComponent(t) { return this.component = t, this } setPort(t) { return this.port = t, this } setHidden(t) { return this.hidden = t, this } use(t, ...n) { return t(this, ...n), this } }; var vt = "__baklava_SubgraphInputNode", gt = "__baklava_SubgraphOutputNode", Io = class extends Mt { constructor() { super(), this.graphInterfaceId = Re() } onPlaced() { super.onPlaced(), this.initializeIo() } save() { return { ...super.save(), graphInterfaceId: this.graphInterfaceId } } load(t) { super.load(t), this.graphInterfaceId = t.graphInterfaceId } }, Vt = class extends Io { constructor() { super(...arguments), this.type = vt, this.inputs = { name: new ye("Name", "Input") }, this.outputs = { placeholder: new ye("Value", void 0) } } static isGraphInputNode(t) { return t.type === vt } }, At = class extends Io { constructor() { super(...arguments), this.type = gt, this.inputs = { name: new ye("Name", "Output"), placeholder: new ye("Value", void 0) }, this.outputs = { output: new ye("Output", void 0).setHidden(!0) }, this.calculate = ({ placeholder: t }) => ({ output: t }) } static isGraphOutputNode(t) { return t.type === gt } }; var it = class { get nodes() { return this._nodes } get connections() { return this._connections } get loading() { return this._loading } get destroying() { return this._destroying } get inputs() { return this.nodes.filter(n => n.type === vt).map(n => ({ id: n.graphInterfaceId, name: n.inputs.name.value, nodeId: n.id, nodeInterfaceId: n.outputs.placeholder.id })) } get outputs() { return this.nodes.filter(n => n.type === gt).map(n => ({ id: n.graphInterfaceId, name: n.inputs.name.value, nodeId: n.id, nodeInterfaceId: n.outputs.output.id })) } constructor(t, n) { this.id = Re(), this.activeTransactions = 0, this._nodes = [], this._connections = [], this._loading = !1, this._destroying = !1, this.events = { beforeAddNode: new _e(this), addNode: new te(this), beforeRemoveNode: new _e(this), removeNode: new te(this), beforeAddConnection: new _e(this), addConnection: new te(this), checkConnection: new _e(this), beforeRemoveConnection: new _e(this), removeConnection: new te(this) }, this.hooks = { save: new Ne(this), load: new Ne(this), checkConnection: new Do(this) }, this.nodeEvents = st(), this.nodeHooks = st(), this.connectionEvents = st(), this.editor = t, this.template = n, t.registerGraph(this) } addNode(t) { if (!this.events.beforeAddNode.emit(t).prevented) return this.nodeEvents.addTarget(t.events), this.nodeHooks.addTarget(t.hooks), t.registerGraph(this), this._nodes.push(t), t = this.nodes.find(n => n.id === t.id), t.onPlaced(), this.events.addNode.emit(t), t } removeNode(t) { if (this.nodes.includes(t)) { if (this.events.beforeRemoveNode.emit(t).prevented) return; let n = [...Object.values(t.inputs), ...Object.values(t.outputs)]; this.connections.filter(o => n.includes(o.from) || n.includes(o.to)).forEach(o => this.removeConnection(o)), this._nodes.splice(this.nodes.indexOf(t), 1), this.events.removeNode.emit(t), t.onDestroy(), this.nodeEvents.removeTarget(t.events), this.nodeHooks.removeTarget(t.hooks) } } addConnection(t, n) { let o = this.checkConnection(t, n); if (!o.connectionAllowed || this.events.beforeAddConnection.emit({ from: t, to: n }).prevented) return; for (let i of o.connectionsInDanger) { let r = this.connections.find(a => a.id === i.id); r && this.removeConnection(r) } let s = new mn(o.dummyConnection.from, o.dummyConnection.to); return this.internalAddConnection(s), s } removeConnection(t) { if (this.connections.includes(t)) { if (this.events.beforeRemoveConnection.emit(t).prevented) return; t.destruct(), this._connections.splice(this.connections.indexOf(t), 1), this.events.removeConnection.emit(t), this.connectionEvents.removeTarget(t.events) } } checkConnection(t, n) { if (!t || !n) return { connectionAllowed: !1 }; let o = this.findNodeById(t.nodeId), s = this.findNodeById(n.nodeId); if (o && s && o === s) return { connectionAllowed: !1 }; if (t.isInput && !n.isInput) { let a = t; t = n, n = a } if (t.isInput || !n.isInput) return { connectionAllowed: !1 }; if (this.connections.some(a => a.from === t && a.to === n)) return { connectionAllowed: !1 }; if (this.events.checkConnection.emit({ from: t, to: n }).prevented) return { connectionAllowed: !1 }; let i = this.hooks.checkConnection.execute({ from: t, to: n }); if (i.some(a => !a.connectionAllowed)) return { connectionAllowed: !1 }; let r = Array.from(new Set(i.flatMap(a => a.connectionsInDanger))); return { connectionAllowed: !0, dummyConnection: new Jt(t, n), connectionsInDanger: r } } findNodeInterface(t) { for (let n of this.nodes) { for (let o in n.inputs) { let s = n.inputs[o]; if (s.id === t) return s } for (let o in n.outputs) { let s = n.outputs[o]; if (s.id === t) return s } } } findNodeById(t) { return this.nodes.find(n => n.id === t) } load(t) { try { this._loading = !0; let n = []; for (let o = this.connections.length - 1; o >= 0; o--)this.removeConnection(this.connections[o]); for (let o = this.nodes.length - 1; o >= 0; o--)this.removeNode(this.nodes[o]); this.id = t.id; for (let o of t.nodes) { let s = this.editor.nodeTypes.get(o.type); if (!s) { n.push(`Node type ${o.type} is not registered`); continue } let i = new s.type; this.addNode(i), i.load(o) } for (let o of t.connections) { let s = this.findNodeInterface(o.from), i = this.findNodeInterface(o.to); if (s) if (i) { let r = new mn(s, i); r.id = o.id, this.internalAddConnection(r) } else { n.push(`Could not find interface with id ${o.to}`); continue } else { n.push(`Could not find interface with id ${o.from}`); continue } } return this.hooks.load.execute(t), n } finally { this._loading = !1 } } save() { let t = { id: this.id, nodes: this.nodes.map(n => n.save()), connections: this.connections.map(n => ({ id: n.id, from: n.from.id, to: n.to.id })), inputs: this.inputs, outputs: this.outputs }; return this.hooks.save.execute(t) } destroy() { this._destroying = !0; for (let t of this.nodes) this.removeNode(t); this.editor.unregisterGraph(this) } internalAddConnection(t) { this.connectionEvents.addTarget(t.events), this._connections.push(t), this.events.addConnection.emit(t) } }; var Zt = "__baklava_GraphNode-"; function _t(e) { return Zt + e.id } var Sc = ["component", "connectionCount", "events", "hidden", "hooks", "id", "isInput", "name", "nodeId", "port", "templateId", "value"]; function Bs(e) { return class extends vn { constructor() { super(...arguments), this.type = _t(e), this.inputs = {}, this.outputs = {}, this.template = e, this.calculate = async (n, o) => { var s; if (!this.subgraph) throw new Error(`GraphNode ${this.id}: calculate called without subgraph being initialized`); if (!o.engine || typeof o.engine != "object") throw new Error(`GraphNode ${this.id}: calculate called but no engine provided in context`); let i = o.engine.getInputValues(this.subgraph); for (let l of this.subgraph.inputs) i.set(l.nodeInterfaceId, n[l.id]); let r = await o.engine.runGraph(this.subgraph, i, o.globalValues), a = {}; for (let l of this.subgraph.outputs) a[l.id] = (s = r.get(l.nodeId)) === null || s === void 0 ? void 0 : s.get("output"); return a._calculationResults = r, a } } get title() { return this._title } set title(n) { this.template.name = n } load(n) { if (!this.subgraph) throw new Error("Cannot load a graph node without a graph"); if (!this.template) throw new Error("Unable to load graph node without graph template"); this.subgraph.load(n.graphState), super.load(n) } save() { if (!this.subgraph) throw new Error("Cannot save a graph node without a graph"); return { ...super.save(), graphState: this.subgraph.save() } } onPlaced() { this.template.events.updated.subscribe(this, () => this.initialize()), this.template.events.nameChanged.subscribe(this, n => { this._title = n }), this.initialize() } onDestroy() { var n; this.template.events.updated.unsubscribe(this), this.template.events.nameChanged.unsubscribe(this), (n = this.subgraph) === null || n === void 0 || n.destroy() } initialize() { this.subgraph && this.subgraph.destroy(), this.subgraph = this.template.createGraph(), this._title = this.template.name, this.updateInterfaces(), this.events.update.emit(null) } updateInterfaces() { if (!this.subgraph) throw new Error("Trying to update interfaces without graph instance"); for (let n of this.subgraph.inputs) n.id in this.inputs ? this.inputs[n.id].name = n.name : this.addInput(n.id, this.createProxyInterface(n, !0)); for (let n of Object.keys(this.inputs)) this.subgraph.inputs.some(o => o.id === n) || this.removeInput(n); for (let n of this.subgraph.outputs) n.id in this.outputs ? this.outputs[n.id].name = n.name : this.addOutput(n.id, this.createProxyInterface(n, !1)); for (let n of Object.keys(this.outputs)) this.subgraph.outputs.some(o => o.id === n) || this.removeOutput(n); this.addOutput("_calculationResults", new ye("_calculationResults", void 0).setHidden(!0)) } createProxyInterface(n, o) { let s = new ye(n.name, void 0); return new Proxy(s, { get: (i, r) => { var a, l, u; if (Sc.includes(r) || r in i || typeof r == "string" && r.startsWith("__v_")) return Reflect.get(i, r); let c; if (o) { let h = (a = this.subgraph) === null || a === void 0 ? void 0 : a.nodes.find(v => Vt.isGraphInputNode(v) && v.graphInterfaceId === n.id); c = h?.outputs.placeholder.id } else { let h = (l = this.subgraph) === null || l === void 0 ? void 0 : l.nodes.find(v => At.isGraphOutputNode(v) && v.graphInterfaceId === n.id); c = h?.inputs.placeholder.id } let d = (u = this.subgraph) === null || u === void 0 ? void 0 : u.connections.find(h => { var v; return c === ((v = o ? h.from : h.to) === null || v === void 0 ? void 0 : v.id) }), p = o ? d?.to : d?.from; if (p) return Reflect.get(p, r) } }) } } } var Qt = class e { static fromGraph(t, n) { return new e(t.save(), n) } get name() { return this._name } set name(t) { this._name = t, this.events.nameChanged.emit(t); let n = this.editor.nodeTypes.get(_t(this)); n && (n.title = t) } get inputs() { return this.nodes.filter(n => n.type === vt).map(n => ({ id: n.graphInterfaceId, name: n.inputs.name.value, nodeId: n.id, nodeInterfaceId: n.outputs.placeholder.id })) } get outputs() { return this.nodes.filter(n => n.type === gt).map(n => ({ id: n.graphInterfaceId, name: n.inputs.name.value, nodeId: n.id, nodeInterfaceId: n.outputs.output.id })) } constructor(t, n) { this.id = Re(), this._name = "Subgraph", this.events = { nameChanged: new te(this), updated: new te(this) }, this.hooks = { beforeLoad: new Ne(this), afterSave: new Ne(this) }, this.editor = n, t.id && (this.id = t.id), t.name && (this._name = t.name), this.update(t) } update(t) { this.nodes = t.nodes, this.connections = t.connections, this.events.updated.emit() } save() { return { id: this.id, name: this.name, nodes: this.nodes, connections: this.connections, inputs: this.inputs, outputs: this.outputs } } createGraph(t) { let n = new Map, o = p => { let h = Re(); return n.set(p, h), h }, s = p => { let h = n.get(p); if (!h) throw new Error(`Unable to create graph from template: Could not map old id ${p} to new id`); return h }, i = p => Wn(p, h => ({ id: o(h.id), templateId: h.id, value: h.value })), r = this.nodes.map(p => ({ ...p, id: o(p.id), inputs: i(p.inputs), outputs: i(p.outputs) })), a = this.connections.map(p => ({ id: o(p.id), from: s(p.from), to: s(p.to) })), l = this.inputs.map(p => ({ id: p.id, name: p.name, nodeId: s(p.nodeId), nodeInterfaceId: s(p.nodeInterfaceId) })), u = this.outputs.map(p => ({ id: p.id, name: p.name, nodeId: s(p.nodeId), nodeInterfaceId: s(p.nodeInterfaceId) })), c = { id: Re(), nodes: r, connections: a, inputs: l, outputs: u }; return t || (t = new it(this.editor)), t.load(c).forEach(p => console.warn(p)), t.template = this, t } }; var Kn = class { get nodeTypes() { return this._nodeTypes } get graph() { return this._graph } get graphTemplates() { return this._graphTemplates } get graphs() { return this._graphs } get loading() { return this._loading } constructor() { this.events = { loaded: new te(this), beforeRegisterNodeType: new _e(this), registerNodeType: new te(this), beforeUnregisterNodeType: new _e(this), unregisterNodeType: new te(this), beforeAddGraphTemplate: new _e(this), addGraphTemplate: new te(this), beforeRemoveGraphTemplate: new _e(this), removeGraphTemplate: new te(this), registerGraph: new te(this), unregisterGraph: new te(this) }, this.hooks = { save: new Ne(this), load: new Ne(this) }, this.graphTemplateEvents = st(), this.graphTemplateHooks = st(), this.graphEvents = st(), this.graphHooks = st(), this.nodeEvents = st(), this.nodeHooks = st(), this.connectionEvents = st(), this._graphs = new Set, this._nodeTypes = new Map, this._graph = new it(this), this._graphTemplates = [], this._loading = !1, this.registerNodeType(Vt), this.registerNodeType(At) } registerNodeType(t, n) { var o, s; if (this.events.beforeRegisterNodeType.emit({ type: t, options: n }).prevented) return; let i = new t; this._nodeTypes.set(i.type, { type: t, category: (o = n?.category) !== null && o !== void 0 ? o : "default", title: (s = n?.title) !== null && s !== void 0 ? s : i.title }), this.events.registerNodeType.emit({ type: t, options: n }) } unregisterNodeType(t) { let n = typeof t == "string" ? t : new t().type; if (this.nodeTypes.has(n)) { if (this.events.beforeUnregisterNodeType.emit(n).prevented) return; this._nodeTypes.delete(n), this.events.unregisterNodeType.emit(n) } } addGraphTemplate(t) { if (this.events.beforeAddGraphTemplate.emit(t).prevented) return; this._graphTemplates.push(t), this.graphTemplateEvents.addTarget(t.events), this.graphTemplateHooks.addTarget(t.hooks); let n = Bs(t); this.registerNodeType(n, { category: "Subgraphs", title: t.name }), this.events.addGraphTemplate.emit(t) } removeGraphTemplate(t) { if (this.graphTemplates.includes(t)) { if (this.events.beforeRemoveGraphTemplate.emit(t).prevented) return; let n = _t(t); for (let o of [this.graph, ...this.graphs.values()]) { let s = o.nodes.filter(i => i.type === n); for (let i of s) o.removeNode(i) } this.unregisterNodeType(n), this._graphTemplates.splice(this._graphTemplates.indexOf(t), 1), this.graphTemplateEvents.removeTarget(t.events), this.graphTemplateHooks.removeTarget(t.hooks), this.events.removeGraphTemplate.emit(t) } } registerGraph(t) { this.graphEvents.addTarget(t.events), this.graphHooks.addTarget(t.hooks), this.nodeEvents.addTarget(t.nodeEvents), this.nodeHooks.addTarget(t.nodeHooks), this.connectionEvents.addTarget(t.connectionEvents), this.events.registerGraph.emit(t), this._graphs.add(t) } unregisterGraph(t) { this.graphEvents.removeTarget(t.events), this.graphHooks.removeTarget(t.hooks), this.nodeEvents.removeTarget(t.nodeEvents), this.nodeHooks.removeTarget(t.nodeHooks), this.connectionEvents.removeTarget(t.connectionEvents), this.events.unregisterGraph.emit(t), this._graphs.delete(t) } load(t) { try { for (this._loading = !0, t = this.hooks.load.execute(t); this.graphTemplates.length > 0;)this.removeGraphTemplate(this.graphTemplates[0]); t.graphTemplates.forEach(o => { let s = new Qt(o, this); this.addGraphTemplate(s) }); let n = this._graph.load(t.graph); return this.events.loaded.emit(), n.forEach(o => console.warn(o)), n } finally { this._loading = !1 } } save() { let t = { graph: this.graph.save(), graphTemplates: this.graphTemplates.map(n => n.save()) }; return this.hooks.save.execute(t) } }; var Gs = {}; Bn(Gs, { BaseEngine: () => zn, CycleError: () => Gn, DependencyEngine: () => Ks, EngineStatus: () => Fe, allowMultipleConnections: () => Ic, applyResult: () => Dc, containsCycle: () => Ws, sortTopologically: () => Mo }); function Dc(e, t) { let n = new Map; t.graphs.forEach(o => { o.nodes.forEach(s => n.set(s.id, s)) }), e.forEach((o, s) => { let i = n.get(s); i && o.forEach((r, a) => { let l = i.outputs[a]; l && (l.value = r) }) }) } var Gn = class extends Error { constructor() { super("Cycle detected") } }; function kc(e) { return typeof e == "string" } function Mo(e, t) { let n = new Map, o = new Map, s = new Map, i, r; if (e instanceof it) i = e.nodes, r = e.connections; else { if (!t) throw new Error("Invalid argument value: expected array of connections"); i = e, r = t } i.forEach(u => { Object.values(u.inputs).forEach(c => n.set(c.id, u.id)), Object.values(u.outputs).forEach(c => n.set(c.id, u.id)) }), i.forEach(u => { let c = r.filter(p => p.from && n.get(p.from.id) === u.id), d = new Set(c.map(p => n.get(p.to.id)).filter(kc)); o.set(u.id, d), s.set(u, c) }); let a = i.slice(); r.forEach(u => { let c = a.findIndex(d => n.get(u.to.id) === d.id); c >= 0 && a.splice(c, 1) }); let l = []; for (; a.length > 0;) { let u = a.pop(); l.push(u); let c = o.get(u.id); for (; c.size > 0;) { let d = c.values().next().value; if (c.delete(d), Array.from(o.values()).every(p => !p.has(d))) { let p = i.find(h => h.id === d); a.push(p) } } } if (Array.from(o.values()).some(u => u.size > 0)) throw new Gn; return { calculationOrder: l, connectionsFromNode: s, interfaceIdToNodeId: n } } function Ws(e, t) { try { return Mo(e, t), !1 } catch (n) { if (n instanceof Gn) return !0; throw n } } var Fe; (function (e) { e.Running = "Running", e.Idle = "Idle", e.Paused = "Paused", e.Stopped = "Stopped" })(Fe || (Fe = {})); var zn = class { get status() { return this.isRunning ? Fe.Running : this.internalStatus } constructor(t) { this.editor = t, this.events = { beforeRun: new _e(this), afterRun: new te(this), statusChange: new te(this), beforeNodeCalculation: new te(this), afterNodeCalculation: new te(this) }, this.hooks = { gatherCalculationData: new Ne(this), transferData: new jn }, this.recalculateOrder = !0, this.internalStatus = Fe.Stopped, this.isRunning = !1, this.editor.nodeEvents.update.subscribe(this, (n, o) => { o.graph && !o.graph.loading && o.graph.activeTransactions === 0 && this.internalOnChange(o, n ?? void 0) }), this.editor.graphEvents.addNode.subscribe(this, (n, o) => { this.recalculateOrder = !0, !o.loading && o.activeTransactions === 0 && this.internalOnChange() }), this.editor.graphEvents.removeNode.subscribe(this, (n, o) => { this.recalculateOrder = !0, !o.loading && o.activeTransactions === 0 && this.internalOnChange() }), this.editor.graphEvents.addConnection.subscribe(this, (n, o) => { this.recalculateOrder = !0, !o.loading && o.activeTransactions === 0 && this.internalOnChange() }), this.editor.graphEvents.removeConnection.subscribe(this, (n, o) => { this.recalculateOrder = !0, !o.loading && o.activeTransactions === 0 && this.internalOnChange() }), this.editor.graphHooks.checkConnection.subscribe(this, n => this.checkConnection(n.from, n.to)) } start() { this.internalStatus === Fe.Stopped && (this.internalStatus = Fe.Idle, this.events.statusChange.emit(this.status)) } pause() { this.internalStatus === Fe.Idle && (this.internalStatus = Fe.Paused, this.events.statusChange.emit(this.status)) } resume() { this.internalStatus === Fe.Paused && (this.internalStatus = Fe.Idle, this.events.statusChange.emit(this.status)) } stop() { (this.internalStatus === Fe.Idle || this.internalStatus === Fe.Paused) && (this.internalStatus = Fe.Stopped, this.events.statusChange.emit(this.status)) } async runOnce(t, ...n) { if (this.events.beforeRun.emit(t).prevented) return null; try { this.isRunning = !0, this.events.statusChange.emit(this.status), this.recalculateOrder && this.calculateOrder(); let o = await this.execute(t, ...n); return this.events.afterRun.emit(o), o } finally { this.isRunning = !1, this.events.statusChange.emit(this.status) } } checkConnection(t, n) { if (t.templateId) { let i = this.findInterfaceByTemplateId(this.editor.graph.nodes, t.templateId); if (!i) return { connectionAllowed: !0, connectionsInDanger: [] }; t = i } if (n.templateId) { let i = this.findInterfaceByTemplateId(this.editor.graph.nodes, n.templateId); if (!i) return { connectionAllowed: !0, connectionsInDanger: [] }; n = i } let o = new Jt(t, n), s = this.editor.graph.connections.slice(); return n.allowMultipleConnections || (s = s.filter(i => i.to !== n)), s.push(o), Ws(this.editor.graph.nodes, s) ? { connectionAllowed: !1, connectionsInDanger: [] } : { connectionAllowed: !0, connectionsInDanger: n.allowMultipleConnections ? [] : this.editor.graph.connections.filter(i => i.to === n) } } calculateOrder() { this.recalculateOrder = !0 } async calculateWithoutData(...t) { let n = this.hooks.gatherCalculationData.execute(void 0); return await this.runOnce(n, ...t) } validateNodeCalculationOutput(t, n) { if (typeof n != "object") throw new Error(`Invalid calculation return value from node ${t.id} (type ${t.type})`); Object.keys(t.outputs).forEach(o => { if (!(o in n)) throw new Error(`Calculation return value from node ${t.id} (type ${t.type}) is missing key "${o}"`) }) } internalOnChange(t, n) { this.internalStatus === Fe.Idle && this.onChange(this.recalculateOrder, t, n) } findInterfaceByTemplateId(t, n) { for (let o of t) for (let s of [...Object.values(o.inputs), ...Object.values(o.outputs)]) if (s.templateId === n) return s; return null } }; var Ic = e => { e.allowMultipleConnections = !0 }, Ks = class extends zn {
        constructor(t) { super(t), this.order = new Map } start() { super.start(), this.recalculateOrder = !0, this.calculateWithoutData() } async runGraph(t, n, o) {
            this.order.has(t.id) || this.order.set(t.id, Mo(t)); let { calculationOrder: s, connectionsFromNode: i } = this.order.get(t.id), r = new Map; for (let a of s) {
                let l = {}; Object.entries(a.inputs).forEach(([c, d]) => { l[c] = this.getInterfaceValue(n, d.id) }), this.events.beforeNodeCalculation.emit({ inputValues: l, node: a }); let u; if (a.calculate) u = await a.calculate(l, { globalValues: o, engine: this }); else { u = {}; for (let [c, d] of Object.entries(a.outputs)) u[c] = this.getInterfaceValue(n, d.id) } this.validateNodeCalculationOutput(a, u), this.events.afterNodeCalculation.emit({ outputValues: u, node: a }), r.set(a.id, new Map(Object.entries(u))), i.has(a) && i.get(a).forEach(c => {
                    var d; let p = (d = Object.entries(a.outputs).find(([, v]) => v.id === c.from.id)) === null || d === void 0 ? void 0 : d[0]; if (!p) throw new Error(`Could not find key for interface ${c.from.id}
This is likely a Baklava internal issue. Please report it on GitHub.`); let h = this.hooks.transferData.execute(u[p], c); c.to.allowMultipleConnections ? n.has(c.to.id) ? n.get(c.to.id).push(h) : n.set(c.to.id, [h]) : n.set(c.to.id, h)
                })
            } return r
        } async execute(t) { this.recalculateOrder && (this.order.clear(), this.recalculateOrder = !1); let n = this.getInputValues(this.editor.graph); return await this.runGraph(this.editor.graph, n, t) } getInputValues(t) { let n = new Map; for (let o of t.nodes) Object.values(o.inputs).forEach(s => { s.connectionCount === 0 && n.set(s.id, s.value) }), o.calculate || Object.values(o.outputs).forEach(s => { n.set(s.id, s.value) }); return n } onChange(t) { this.recalculateOrder = t || this.recalculateOrder, this.calculateWithoutData() } getInterfaceValue(t, n) {
            if (!t.has(n)) throw new Error(`Could not find value for interface ${n}
This is likely a Baklava internal issue. Please report it on GitHub.`); return t.get(n)
        }
    }; var qs = {}; Bn(qs, { BaklavaInterfaceTypes: () => Ys, NodeInterfaceType: () => zs, getType: () => Ac, setType: () => Mc, setTypeForMultipleConnections: () => Vc }); var zs = class { constructor(t) { this.name = t, this.conversions = [] } addConversion(t, n = o => o) { return this.conversions.push({ targetType: t.name, transformationFunction: n }), this } }; function Mc(e, t) { e.type = t.name } function Vc(e, t) { e.type = t.name } function Ac(e) { return e.type } var Ys = class { constructor(t, n) { this.types = new Map, this.editor = t, this.editor.graphEvents.checkConnection.subscribe(this, ({ from: o, to: s }, i) => { let r = o.type, a = s.type; if (!(!r || !a) && !this.canConvert(r, a)) return i() }), n?.engine && n.engine.hooks.transferData.subscribe(this, (o, s) => { let i = s.from.type, r = s.to.type; return !i || !r ? o : this.convert(i, r, o) }), n?.viewPlugin && n.viewPlugin.hooks.renderInterface.subscribe(this, ({ intf: o, el: s }) => (o.type && s.setAttribute("data-interface-type", o.type), { intf: o, el: s })) } addTypes(...t) { return t.forEach(n => { this.types.set(n.name, n) }), this } getConversion(t, n) { var o, s; return (s = (o = this.types.get(t)) === null || o === void 0 ? void 0 : o.conversions.find(i => i.targetType === n)) !== null && s !== void 0 ? s : null } canConvert(t, n) { return t === n || this.types.has(t) && this.types.get(t).conversions.some(o => o.targetType === n) } convert(t, n, o) { if (t === n) return o; { let s = this.getConversion(t, n); if (s) return s.transformationFunction(o); throw Error(`Can not convert from "${t}" to "${n}"`) } } }; var yr = {}; Bn(yr, { BaklavaEditor: () => hr, ButtonInterface: () => Qi, ButtonInterfaceComponent: () => Jl, CheckboxInterface: () => er, CheckboxInterfaceComponent: () => Zl, Commands: () => rh, Components: () => Jh, DEFAULT_TOOLBAR_COMMANDS: () => pc, DEFAULT_TOOLBAR_SUBGRAPH_COMMANDS: () => mc, EditorComponent: () => hr, IntegerInterface: () => tr, IntegerInterfaceComponent: () => Ql, NumberInterface: () => nr, NumberInterfaceComponent: () => ec, SelectInterface: () => or, SelectInterfaceComponent: () => tc, SliderInterface: () => sr, SliderInterfaceComponent: () => nc, TOOLBAR_COMMANDS: () => fc, TOOLBAR_SUBGRAPH_COMMANDS: () => hc, TemporaryConnectionState: () => tt, TextInputInterface: () => To, TextInputInterfaceComponent: () => oc, TextInterface: () => ir, TextareaInputInterface: () => rr, TextareaInputInterfaceComponent: () => sc, displayInSidebar: () => eh, getDomElementOfNode: () => Wl, getDomElements: () => fn, getNodePosition: () => qd, getPortCoordinates: () => xo, isInputElement: () => lr, providePlugin: () => Al, provideTemporaryConnection: () => Pl, setNodePosition: () => Xd, useBaklava: () => _r, useCommandHandler: () => Xl, useDragMove: () => cr, useGraph: () => nt, useNodeCategories: () => ur, useTemporaryConnection: () => Ll, useTransform: () => dr, useViewModel: () => Ye }); function gn(e) { let t = Object.create(null); for (let n of e.split(",")) t[n] = 1; return n => n in t } var ce = {}, en = [], Ue = () => { }, Cr = () => !1, _n = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), Yn = e => e.startsWith("onUpdate:"), ge = Object.assign, qn = (e, t) => { let n = e.indexOf(t); n > -1 && e.splice(n, 1) }, Rc = Object.prototype.hasOwnProperty, re = (e, t) => Rc.call(e, t), W = Array.isArray, tn = e => Ao(e) === "[object Map]", Vo = e => Ao(e) === "[object Set]"; var q = e => typeof e == "function", ve = e => typeof e == "string", rt = e => typeof e == "symbol", de = e => e !== null && typeof e == "object", Js = e => (de(e) || q(e)) && q(e.then) && q(e.catch), Tr = Object.prototype.toString, Ao = e => Tr.call(e), Zs = e => Ao(e).slice(8, -1), Ro = e => Ao(e) === "[object Object]", $o = e => ve(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, yn = gn(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"); var Po = e => { let t = Object.create(null); return n => t[n] || (t[n] = e(n)) }, $c = /-(\w)/g, $e = Po(e => e.replace($c, (t, n) => n ? n.toUpperCase() : "")), Pc = /\B([A-Z])/g, yt = Po(e => e.replace(Pc, "-$1").toLowerCase()), nn = Po(e => e.charAt(0).toUpperCase() + e.slice(1)), Xn = Po(e => e ? `on${nn(e)}` : ""), Et = (e, t) => !Object.is(e, t), En = (e, ...t) => { for (let n = 0; n < e.length; n++)e[n](...t) }, bn = (e, t, n, o = !1) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: o, value: n }) }, Jn = e => { let t = parseFloat(e); return isNaN(t) ? e : t }, Qs = e => { let t = ve(e) ? Number(e) : NaN; return isNaN(t) ? e : t }, xr, Ft = () => xr || (xr = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function Ke(e) { if (W(e)) { let t = {}; for (let n = 0; n < e.length; n++) { let o = e[n], s = ve(o) ? Uc(o) : Ke(o); if (s) for (let i in s) t[i] = s[i] } return t } else if (ve(e) || de(e)) return e } var Lc = /;(?![^(]*\))/g, Hc = /:([^]+)/, Fc = /\/\*[^]*?\*\//g; function Uc(e) { let t = {}; return e.replace(Fc, "").split(Lc).forEach(n => { if (n) { let o = n.split(Hc); o.length > 1 && (t[o[0].trim()] = o[1].trim()) } }), t } function we(e) { let t = ""; if (ve(e)) t = e; else if (W(e)) for (let n = 0; n < e.length; n++) { let o = we(e[n]); o && (t += o + " ") } else if (de(e)) for (let n in e) e[n] && (t += n + " "); return t.trim() } var Sr = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Dr = gn(Sr), Bc = gn(Sr + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"); function Lo(e) { return !!e || e === "" } var kr = e => !!(e && e.__v_isRef === !0), Ee = e => ve(e) ? e : e == null ? "" : W(e) || de(e) && (e.toString === Tr || !q(e.toString)) ? kr(e) ? Ee(e.value) : JSON.stringify(e, Ir, 2) : String(e), Ir = (e, t) => kr(t) ? Ir(e, t.value) : tn(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((n, [o, s], i) => (n[Xs(o, i) + " =>"] = s, n), {}) } : Vo(t) ? { [`Set(${t.size})`]: [...t.values()].map(n => Xs(n)) } : rt(t) ? Xs(t) : de(t) && !W(t) && !Ro(t) ? String(t) : t, Xs = (e, t = "") => { var n; return rt(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e }; function jc(e, ...t) { console.warn(`[Vue warn] ${e}`, ...t) } var Pe, to = class { constructor(t = !1) { this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Pe, !t && Pe && (this.index = (Pe.scopes || (Pe.scopes = [])).push(this) - 1) } get active() { return this._active } pause() { if (this._active) { this._isPaused = !0; let t, n; if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].pause(); for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].pause() } } resume() { if (this._active && this._isPaused) { this._isPaused = !1; let t, n; if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].resume(); for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].resume() } } run(t) { if (this._active) { let n = Pe; try { return Pe = this, t() } finally { Pe = n } } } on() { ++this._on === 1 && (this.prevScope = Pe, Pe = this) } off() { this._on > 0 && --this._on === 0 && (Pe = this.prevScope, this.prevScope = void 0) } stop(t) { if (this._active) { this._active = !1; let n, o; for (n = 0, o = this.effects.length; n < o; n++)this.effects[n].stop(); for (this.effects.length = 0, n = 0, o = this.cleanups.length; n < o; n++)this.cleanups[n](); if (this.cleanups.length = 0, this.scopes) { for (n = 0, o = this.scopes.length; n < o; n++)this.scopes[n].stop(!0); this.scopes.length = 0 } if (!this.detached && this.parent && !t) { let s = this.parent.scopes.pop(); s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index) } this.parent = void 0 } } }; function zo() { return Pe } function fi(e, t = !1) { Pe && Pe.cleanups.push(e) } var pe; var ei = new WeakSet, wn = class { constructor(t) { this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Pe && Pe.active && Pe.effects.push(this) } pause() { this.flags |= 64 } resume() { this.flags & 64 && (this.flags &= -65, ei.has(this) && (ei.delete(this), this.trigger())) } notify() { this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Rr(this) } run() { if (!(this.flags & 1)) return this.fn(); this.flags |= 2, Mr(this), $r(this); let t = pe, n = ft; pe = this, ft = !0; try { return this.fn() } finally { Pr(this), pe = t, ft = n, this.flags &= -3 } } stop() { if (this.flags & 1) { for (let t = this.deps; t; t = t.nextDep)mi(t); this.deps = this.depsTail = void 0, Mr(this), this.onStop && this.onStop(), this.flags &= -2 } } trigger() { this.flags & 64 ? ei.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty() } runIfDirty() { oi(this) && this.run() } get dirty() { return oi(this) } }, Ar = 0, Qn, eo; function Rr(e, t = !1) { if (e.flags |= 8, t) { e.next = eo, eo = e; return } e.next = Qn, Qn = e } function pi() { Ar++ } function hi() { if (--Ar > 0) return; if (eo) { let t = eo; for (eo = void 0; t;) { let n = t.next; t.next = void 0, t.flags &= -9, t = n } } let e; for (; Qn;) { let t = Qn; for (Qn = void 0; t;) { let n = t.next; if (t.next = void 0, t.flags &= -9, t.flags & 1) try { t.trigger() } catch (o) { e || (e = o) } t = n } } if (e) throw e } function $r(e) { for (let t = e.deps; t; t = t.nextDep)t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t } function Pr(e) { let t, n = e.depsTail, o = n; for (; o;) { let s = o.prevDep; o.version === -1 ? (o === n && (n = s), mi(o), Wc(o)) : t = o, o.dep.activeLink = o.prevActiveLink, o.prevActiveLink = void 0, o = s } e.deps = t, e.depsTail = n } function oi(e) { for (let t = e.deps; t; t = t.nextDep)if (t.dep.version !== t.version || t.dep.computed && (Lr(t.dep.computed) || t.dep.version !== t.version)) return !0; return !!e._dirty } function Lr(e) { if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === no) || (e.globalVersion = no, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !oi(e)))) return; e.flags |= 2; let t = e.dep, n = pe, o = ft; pe = e, ft = !0; try { $r(e); let s = e.fn(e._value); (t.version === 0 || Et(s, e._value)) && (e.flags |= 128, e._value = s, t.version++) } catch (s) { throw t.version++, s } finally { pe = n, ft = o, Pr(e), e.flags &= -3 } } function mi(e, t = !1) { let { dep: n, prevSub: o, nextSub: s } = e; if (o && (o.nextSub = s, e.prevSub = void 0), s && (s.prevSub = o, e.nextSub = void 0), n.subs === e && (n.subs = o, !o && n.computed)) { n.computed.flags &= -5; for (let i = n.computed.deps; i; i = i.nextDep)mi(i, !0) } !t && !--n.sc && n.map && n.map.delete(n.key) } function Wc(e) { let { prevDep: t, nextDep: n } = e; t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0) } var ft = !0, Hr = []; function Ot() { Hr.push(ft), ft = !1 } function xt() { let e = Hr.pop(); ft = e === void 0 ? !0 : e } function Mr(e) { let { cleanup: t } = e; if (e.cleanup = void 0, t) { let n = pe; pe = void 0; try { t() } finally { pe = n } } } var no = 0, si = class { constructor(t, n) { this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0 } }, On = class { constructor(t) { this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0 } track(t) { if (!pe || !ft || pe === this.computed) return; let n = this.activeLink; if (n === void 0 || n.sub !== pe) n = this.activeLink = new si(pe, this), pe.deps ? (n.prevDep = pe.depsTail, pe.depsTail.nextDep = n, pe.depsTail = n) : pe.deps = pe.depsTail = n, Fr(n); else if (n.version === -1 && (n.version = this.version, n.nextDep)) { let o = n.nextDep; o.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = o), n.prevDep = pe.depsTail, n.nextDep = void 0, pe.depsTail.nextDep = n, pe.depsTail = n, pe.deps === n && (pe.deps = o) } return n } trigger(t) { this.version++, no++, this.notify(t) } notify(t) { pi(); try { for (let n = this.subs; n; n = n.prevSub)n.sub.notify() && n.sub.dep.notify() } finally { hi() } } }; function Fr(e) { if (e.dep.sc++, e.sub.flags & 4) { let t = e.dep.computed; if (t && !e.dep.subs) { t.flags |= 20; for (let o = t.deps; o; o = o.nextDep)Fr(o) } let n = e.dep.subs; n !== e && (e.prevSub = n, n && (n.nextSub = e)), e.dep.subs = e } } var Bo = new WeakMap, sn = Symbol(""), ii = Symbol(""), oo = Symbol(""); function ke(e, t, n) { if (ft && pe) { let o = Bo.get(e); o || Bo.set(e, o = new Map); let s = o.get(n); s || (o.set(n, s = new On), s.map = o, s.key = n), s.track() } } function bt(e, t, n, o, s, i) { let r = Bo.get(e); if (!r) { no++; return } let a = l => { l && l.trigger() }; if (pi(), t === "clear") r.forEach(a); else { let l = W(e), u = l && $o(n); if (l && n === "length") { let c = Number(o); r.forEach((d, p) => { (p === "length" || p === oo || !rt(p) && p >= c) && a(d) }) } else switch ((n !== void 0 || r.has(void 0)) && a(r.get(n)), u && a(r.get(oo)), t) { case "add": l ? u && a(r.get("length")) : (a(r.get(sn)), tn(e) && a(r.get(ii))); break; case "delete": l || (a(r.get(sn)), tn(e) && a(r.get(ii))); break; case "set": tn(e) && a(r.get(sn)); break } } hi() } function Kc(e, t) { let n = Bo.get(e); return n && n.get(t) } function Nn(e) { let t = ne(e); return t === e ? t : (ke(t, "iterate", oo), Ge(e) ? t : t.map(Ce)) } function io(e) { return ke(e = ne(e), "iterate", oo), e } var Gc = { __proto__: null, [Symbol.iterator]() { return ti(this, Symbol.iterator, Ce) }, concat(...e) { return Nn(this).concat(...e.map(t => W(t) ? Nn(t) : t)) }, entries() { return ti(this, "entries", e => (e[1] = Ce(e[1]), e)) }, every(e, t) { return Rt(this, "every", e, t, void 0, arguments) }, filter(e, t) { return Rt(this, "filter", e, t, n => n.map(Ce), arguments) }, find(e, t) { return Rt(this, "find", e, t, Ce, arguments) }, findIndex(e, t) { return Rt(this, "findIndex", e, t, void 0, arguments) }, findLast(e, t) { return Rt(this, "findLast", e, t, Ce, arguments) }, findLastIndex(e, t) { return Rt(this, "findLastIndex", e, t, void 0, arguments) }, forEach(e, t) { return Rt(this, "forEach", e, t, void 0, arguments) }, includes(...e) { return ni(this, "includes", e) }, indexOf(...e) { return ni(this, "indexOf", e) }, join(e) { return Nn(this).join(e) }, lastIndexOf(...e) { return ni(this, "lastIndexOf", e) }, map(e, t) { return Rt(this, "map", e, t, void 0, arguments) }, pop() { return Zn(this, "pop") }, push(...e) { return Zn(this, "push", e) }, reduce(e, ...t) { return Vr(this, "reduce", e, t) }, reduceRight(e, ...t) { return Vr(this, "reduceRight", e, t) }, shift() { return Zn(this, "shift") }, some(e, t) { return Rt(this, "some", e, t, void 0, arguments) }, splice(...e) { return Zn(this, "splice", e) }, toReversed() { return Nn(this).toReversed() }, toSorted(e) { return Nn(this).toSorted(e) }, toSpliced(...e) { return Nn(this).toSpliced(...e) }, unshift(...e) { return Zn(this, "unshift", e) }, values() { return ti(this, "values", Ce) } }; function ti(e, t, n) { let o = io(e), s = o[t](); return o !== e && !Ge(e) && (s._next = s.next, s.next = () => { let i = s._next(); return i.value && (i.value = n(i.value)), i }), s } var zc = Array.prototype; function Rt(e, t, n, o, s, i) { let r = io(e), a = r !== e && !Ge(e), l = r[t]; if (l !== zc[t]) { let d = l.apply(e, i); return a ? Ce(d) : d } let u = n; r !== e && (a ? u = function (d, p) { return n.call(this, Ce(d), p, e) } : n.length > 2 && (u = function (d, p) { return n.call(this, d, p, e) })); let c = l.call(r, u, o); return a && s ? s(c) : c } function Vr(e, t, n, o) { let s = io(e), i = n; return s !== e && (Ge(e) ? n.length > 3 && (i = function (r, a, l) { return n.call(this, r, a, l, e) }) : i = function (r, a, l) { return n.call(this, r, Ce(a), l, e) }), s[t](i, ...o) } function ni(e, t, n) { let o = ne(e); ke(o, "iterate", oo); let s = o[t](...n); return (s === -1 || s === !1) && ro(n[0]) ? (n[0] = ne(n[0]), o[t](...n)) : s } function Zn(e, t, n = []) { Ot(), pi(); let o = ne(e)[t].apply(e, n); return hi(), xt(), o } var Yc = gn("__proto__,__v_isRef,__isVue"), Ur = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(rt)); function qc(e) { rt(e) || (e = String(e)); let t = ne(this); return ke(t, "has", e), t.hasOwnProperty(e) } var jo = class { constructor(t = !1, n = !1) { this._isReadonly = t, this._isShallow = n } get(t, n, o) { if (n === "__v_skip") return t.__v_skip; let s = this._isReadonly, i = this._isShallow; if (n === "__v_isReactive") return !s; if (n === "__v_isReadonly") return s; if (n === "__v_isShallow") return i; if (n === "__v_raw") return o === (s ? i ? Kr : Wr : i ? jr : Br).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(o) ? t : void 0; let r = W(t); if (!s) { let l; if (r && (l = Gc[n])) return l; if (n === "hasOwnProperty") return qc } let a = Reflect.get(t, n, be(t) ? t : o); return (rt(n) ? Ur.has(n) : Yc(n)) || (s || ke(t, "get", n), i) ? a : be(a) ? r && $o(n) ? a : a.value : de(a) ? s ? gi(a) : Le(a) : a } }, Wo = class extends jo { constructor(t = !1) { super(!1, t) } set(t, n, o, s) { let i = t[n]; if (!this._isShallow) { let l = wt(i); if (!Ge(o) && !wt(o) && (i = ne(i), o = ne(o)), !W(t) && be(i) && !be(o)) return l ? !1 : (i.value = o, !0) } let r = W(t) && $o(n) ? Number(n) < t.length : re(t, n), a = Reflect.set(t, n, o, be(t) ? t : s); return t === ne(s) && (r ? Et(o, i) && bt(t, "set", n, o, i) : bt(t, "add", n, o)), a } deleteProperty(t, n) { let o = re(t, n), s = t[n], i = Reflect.deleteProperty(t, n); return i && o && bt(t, "delete", n, void 0, s), i } has(t, n) { let o = Reflect.has(t, n); return (!rt(n) || !Ur.has(n)) && ke(t, "has", n), o } ownKeys(t) { return ke(t, "iterate", W(t) ? "length" : sn), Reflect.ownKeys(t) } }, Ko = class extends jo { constructor(t = !1) { super(!0, t) } set(t, n) { return !0 } deleteProperty(t, n) { return !0 } }, Xc = new Wo, Jc = new Ko, Zc = new Wo(!0), Qc = new Ko(!0), ri = e => e, Ho = e => Reflect.getPrototypeOf(e); function eu(e, t, n) { return function (...o) { let s = this.__v_raw, i = ne(s), r = tn(i), a = e === "entries" || e === Symbol.iterator && r, l = e === "keys" && r, u = s[e](...o), c = n ? ri : t ? so : Ce; return !t && ke(i, "iterate", l ? ii : sn), { next() { let { value: d, done: p } = u.next(); return p ? { value: d, done: p } : { value: a ? [c(d[0]), c(d[1])] : c(d), done: p } }, [Symbol.iterator]() { return this } } } } function Fo(e) { return function (...t) { return e === "delete" ? !1 : e === "clear" ? void 0 : this } } function tu(e, t) { let n = { get(s) { let i = this.__v_raw, r = ne(i), a = ne(s); e || (Et(s, a) && ke(r, "get", s), ke(r, "get", a)); let { has: l } = Ho(r), u = t ? ri : e ? so : Ce; if (l.call(r, s)) return u(i.get(s)); if (l.call(r, a)) return u(i.get(a)); i !== r && i.get(s) }, get size() { let s = this.__v_raw; return !e && ke(ne(s), "iterate", sn), Reflect.get(s, "size", s) }, has(s) { let i = this.__v_raw, r = ne(i), a = ne(s); return e || (Et(s, a) && ke(r, "has", s), ke(r, "has", a)), s === a ? i.has(s) : i.has(s) || i.has(a) }, forEach(s, i) { let r = this, a = r.__v_raw, l = ne(a), u = t ? ri : e ? so : Ce; return !e && ke(l, "iterate", sn), a.forEach((c, d) => s.call(i, u(c), u(d), r)) } }; return ge(n, e ? { add: Fo("add"), set: Fo("set"), delete: Fo("delete"), clear: Fo("clear") } : { add(s) { !t && !Ge(s) && !wt(s) && (s = ne(s)); let i = ne(this); return Ho(i).has.call(i, s) || (i.add(s), bt(i, "add", s, s)), this }, set(s, i) { !t && !Ge(i) && !wt(i) && (i = ne(i)); let r = ne(this), { has: a, get: l } = Ho(r), u = a.call(r, s); u || (s = ne(s), u = a.call(r, s)); let c = l.call(r, s); return r.set(s, i), u ? Et(i, c) && bt(r, "set", s, i, c) : bt(r, "add", s, i), this }, delete(s) { let i = ne(this), { has: r, get: a } = Ho(i), l = r.call(i, s); l || (s = ne(s), l = r.call(i, s)); let u = a ? a.call(i, s) : void 0, c = i.delete(s); return l && bt(i, "delete", s, void 0, u), c }, clear() { let s = ne(this), i = s.size !== 0, r = void 0, a = s.clear(); return i && bt(s, "clear", void 0, void 0, r), a } }), ["keys", "values", "entries", Symbol.iterator].forEach(s => { n[s] = eu(s, e, t) }), n } function Yo(e, t) { let n = tu(e, t); return (o, s, i) => s === "__v_isReactive" ? !e : s === "__v_isReadonly" ? e : s === "__v_raw" ? o : Reflect.get(re(n, s) && s in o ? n : o, s, i) } var nu = { get: Yo(!1, !1) }, ou = { get: Yo(!1, !0) }, su = { get: Yo(!0, !1) }, iu = { get: Yo(!0, !0) }; var Br = new WeakMap, jr = new WeakMap, Wr = new WeakMap, Kr = new WeakMap; function ru(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function au(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : ru(Zs(e)) } function Le(e) { return wt(e) ? e : qo(e, !1, Xc, nu, Br) } function vi(e) { return qo(e, !1, Zc, ou, jr) } function gi(e) { return qo(e, !0, Jc, su, Wr) } function _i(e) { return qo(e, !0, Qc, iu, Kr) } function qo(e, t, n, o, s) { if (!de(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; let i = au(e); if (i === 0) return e; let r = s.get(e); if (r) return r; let a = new Proxy(e, i === 2 ? o : n); return s.set(e, a), a } function Ut(e) { return wt(e) ? Ut(e.__v_raw) : !!(e && e.__v_isReactive) } function wt(e) { return !!(e && e.__v_isReadonly) } function Ge(e) { return !!(e && e.__v_isShallow) } function ro(e) { return e ? !!e.__v_raw : !1 } function ne(e) { let t = e && e.__v_raw; return t ? ne(t) : e } function Ze(e) { return !re(e, "__v_skip") && Object.isExtensible(e) && bn(e, "__v_skip", !0), e } var Ce = e => de(e) ? Le(e) : e, so = e => de(e) ? gi(e) : e; function be(e) { return e ? e.__v_isRef === !0 : !1 } function U(e) { return Gr(e, !1) } function Xo(e) { return Gr(e, !0) } function Gr(e, t) { return be(e) ? e : new ai(e, t) } var ai = class { constructor(t, n) { this.dep = new On, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? t : ne(t), this._value = n ? t : Ce(t), this.__v_isShallow = n } get value() { return this.dep.track(), this._value } set value(t) { let n = this._rawValue, o = this.__v_isShallow || Ge(t) || wt(t); t = o ? t : ne(t), Et(t, n) && (this._rawValue = t, this._value = o ? t : Ce(t), this.dep.trigger()) } }; function Q(e) { return be(e) ? e.value : e } function Ct(e) { return q(e) ? e() : Q(e) } var lu = { get: (e, t, n) => t === "__v_raw" ? e : Q(Reflect.get(e, t, n)), set: (e, t, n, o) => { let s = e[t]; return be(s) && !be(n) ? (s.value = n, !0) : Reflect.set(e, t, n, o) } }; function Jo(e) { return Ut(e) ? e : new Proxy(e, lu) } var li = class { constructor(t) { this.__v_isRef = !0, this._value = void 0; let n = this.dep = new On, { get: o, set: s } = t(n.track.bind(n), n.trigger.bind(n)); this._get = o, this._set = s } get value() { return this._value = this._get() } set value(t) { this._set(t) } }; function Zo(e) { return new li(e) } function yi(e) { let t = W(e) ? new Array(e.length) : {}; for (let n in e) t[n] = zr(e, n); return t } var ci = class { constructor(t, n, o) { this._object = t, this._key = n, this._defaultValue = o, this.__v_isRef = !0, this._value = void 0 } get value() { let t = this._object[this._key]; return this._value = t === void 0 ? this._defaultValue : t } set value(t) { this._object[this._key] = t } get dep() { return Kc(ne(this._object), this._key) } }, ui = class { constructor(t) { this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0 } get value() { return this._value = this._getter() } }; function $t(e, t, n) { return be(e) ? e : q(e) ? new ui(e) : de(e) && arguments.length > 1 ? zr(e, t, n) : U(e) } function zr(e, t, n) { let o = e[t]; return be(o) ? o : new ci(e, t, n) } var di = class { constructor(t, n, o) { this.fn = t, this.setter = n, this._value = void 0, this.dep = new On(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = no - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = o } notify() { if (this.flags |= 16, !(this.flags & 8) && pe !== this) return Rr(this, !0), !0 } get value() { let t = this.dep.track(); return Lr(this), t && (t.version = this.dep.version), this._value } set value(t) { this.setter && this.setter(t) } }; function Yr(e, t, n = !1) { let o, s; return q(e) ? o = e : (o = e.get, s = e.set), new di(o, s, n) } var Uo = {}, Go = new WeakMap, on; function qr(e, t = !1, n = on) { if (n) { let o = Go.get(n); o || Go.set(n, o = []), o.push(e) } } function Xr(e, t, n = ce) { let { immediate: o, deep: s, once: i, scheduler: r, augmentJob: a, call: l } = n, u = C => { (n.onWarn || jc)("Invalid watch source: ", C, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.") }, c = C => s ? C : Ge(C) || s === !1 || s === 0 ? Nt(C, 1) : Nt(C), d, p, h, v, b = !1, y = !1; if (be(e) ? (p = () => e.value, b = Ge(e)) : Ut(e) ? (p = () => c(e), b = !0) : W(e) ? (y = !0, b = e.some(C => Ut(C) || Ge(C)), p = () => e.map(C => { if (be(C)) return C.value; if (Ut(C)) return c(C); if (q(C)) return l ? l(C, 2) : C() })) : q(e) ? t ? p = l ? () => l(e, 2) : e : p = () => { if (h) { Ot(); try { h() } finally { xt() } } let C = on; on = d; try { return l ? l(e, 3, [v]) : e(v) } finally { on = C } } : p = Ue, t && s) { let C = p, D = s === !0 ? 1 / 0 : s; p = () => Nt(C(), D) } let E = zo(), N = () => { d.stop(), E && E.active && qn(E.effects, d) }; if (i && t) { let C = t; t = (...D) => { C(...D), N() } } let k = y ? new Array(e.length).fill(Uo) : Uo, G = C => { if (!(!(d.flags & 1) || !d.dirty && !C)) if (t) { let D = d.run(); if (s || b || (y ? D.some((z, P) => Et(z, k[P])) : Et(D, k))) { h && h(); let z = on; on = d; try { let P = [D, k === Uo ? void 0 : y && k[0] === Uo ? [] : k, v]; k = D, l ? l(t, 3, P) : t(...P) } finally { on = z } } } else d.run() }; return a && a(G), d = new wn(p), d.scheduler = r ? () => r(G, !1) : G, v = C => qr(C, !1, d), h = d.onStop = () => { let C = Go.get(d); if (C) { if (l) l(C, 4); else for (let D of C) D(); Go.delete(d) } }, t ? o ? G(!0) : k = d.run() : r ? r(G.bind(null, !0), !0) : d.run(), N.pause = d.pause.bind(d), N.resume = d.resume.bind(d), N.stop = N, N } function Nt(e, t = 1 / 0, n) { if (t <= 0 || !de(e) || e.__v_skip || (n = n || new Set, n.has(e))) return e; if (n.add(e), t--, be(e)) Nt(e.value, t, n); else if (W(e)) for (let o = 0; o < e.length; o++)Nt(e[o], t, n); else if (Vo(e) || tn(e)) e.forEach(o => { Nt(o, t, n) }); else if (Ro(e)) { for (let o in e) Nt(e[o], t, n); for (let o of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, o) && Nt(e[o], t, n) } return e } function vo(e, t, n, o) { try { return o ? e(...o) : e() } catch (s) { rs(s, t, n) } } function lt(e, t, n, o) { if (q(e)) { let s = vo(e, t, n, o); return s && Js(s) && s.catch(i => { rs(i, t, n) }), s } if (W(e)) { let s = []; for (let i = 0; i < e.length; i++)s.push(lt(e[i], t, n, o)); return s } } function rs(e, t, n, o = !0) { let s = t ? t.vnode : null, { errorHandler: i, throwUnhandledErrorInProduction: r } = t && t.appContext.config || ce; if (t) { let a = t.parent, l = t.proxy, u = `https://vuejs.org/error-reference/#runtime-${n}`; for (; a;) { let c = a.ec; if (c) { for (let d = 0; d < c.length; d++)if (c[d](e, l, u) === !1) return } a = a.parent } if (i) { Ot(), vo(i, null, 10, [e, l, u]), xt(); return } } cu(e, n, s, o, r) } function cu(e, t, n, o = !0, s = !1) { if (s) throw e; console.error(e) } var je = [], St = -1, Cn = [], Bt = null, xn = 0, pa = Promise.resolve(), ts = null; function In(e) { let t = ts || pa; return e ? t.then(this ? e.bind(this) : e) : t } function uu(e) { let t = St + 1, n = je.length; for (; t < n;) { let o = t + n >>> 1, s = je[o], i = fo(s); i < e || i === e && s.flags & 2 ? t = o + 1 : n = o } return t } function ki(e) { if (!(e.flags & 1)) { let t = fo(e), n = je[je.length - 1]; !n || !(e.flags & 2) && t >= fo(n) ? je.push(e) : je.splice(uu(t), 0, e), e.flags |= 1, ha() } } function ha() { ts || (ts = pa.then(ga)) } function ma(e) { W(e) ? Cn.push(...e) : Bt && e.id === -1 ? Bt.splice(xn + 1, 0, e) : e.flags & 1 || (Cn.push(e), e.flags |= 1), ha() } function Jr(e, t, n = St + 1) { for (; n < je.length; n++) { let o = je[n]; if (o && o.flags & 2) { if (e && o.id !== e.uid) continue; je.splice(n, 1), n--, o.flags & 4 && (o.flags &= -2), o(), o.flags & 4 || (o.flags &= -2) } } } function va(e) { if (Cn.length) { let t = [...new Set(Cn)].sort((n, o) => fo(n) - fo(o)); if (Cn.length = 0, Bt) { Bt.push(...t); return } for (Bt = t, xn = 0; xn < Bt.length; xn++) { let n = Bt[xn]; n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2 } Bt = null, xn = 0 } } var fo = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id; function ga(e) { let t = Ue; try { for (St = 0; St < je.length; St++) { let n = je[St]; n && !(n.flags & 8) && (n.flags & 4 && (n.flags &= -2), vo(n, n.i, n.i ? 15 : 14), n.flags & 4 || (n.flags &= -2)) } } finally { for (; St < je.length; St++) { let n = je[St]; n && (n.flags &= -2) } St = -1, je.length = 0, va(e), ts = null, (je.length || Cn.length) && ga(e) } } var kt, ao = [], Oi = !1; function as(e, ...t) { kt ? kt.emit(e, ...t) : Oi || ao.push({ event: e, args: t }) } function _a(e, t) { var n, o; kt = e, kt ? (kt.enabled = !0, ao.forEach(({ event: s, args: i }) => kt.emit(s, ...i)), ao = []) : typeof window < "u" && window.HTMLElement && !((o = (n = window.navigator) == null ? void 0 : n.userAgent) != null && o.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(i => { _a(i, t) }), setTimeout(() => { kt || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Oi = !0, ao = []) }, 3e3)) : (Oi = !0, ao = []) } function du(e, t) { as("app:init", e, t, { Fragment: ae, Text: go, Comment: Ie, Static: Dn }) } function fu(e) { as("app:unmount", e) } var pu = Ii("component:added"), ya = Ii("component:updated"), hu = Ii("component:removed"), mu = e => { kt && typeof kt.cleanupBuffer == "function" && !kt.cleanupBuffer(e) && hu(e) }; function Ii(e) { return t => { as(e, t.appContext.app, t.uid, t.parent ? t.parent.uid : void 0, t) } } function vu(e, t, n) { as("component:emit", e.appContext.app, e, t, n) } var Te = null, Ea = null; function ns(e) { let t = Te; return Te = e, Ea = e && e.type.__scopeId || null, t } function Mn(e, t = Te, n) { if (!t || e._n) return e; let o = (...s) => { o._d && aa(-1); let i = ns(t), r; try { r = e(...s) } finally { ns(i), o._d && aa(1) } return __VUE_PROD_DEVTOOLS__ && ya(t), r }; return o._n = !0, o._c = !0, o._d = !0, o } function Pt(e, t) { if (Te === null) return e; let n = hs(Te), o = e.dirs || (e.dirs = []); for (let s = 0; s < t.length; s++) { let [i, r, a, l = ce] = t[s]; i && (q(i) && (i = { mounted: i, updated: i }), i.deep && Nt(r), o.push({ dir: i, instance: n, value: r, oldValue: void 0, arg: a, modifiers: l })) } return e } function rn(e, t, n, o) { let s = e.dirs, i = t && t.dirs; for (let r = 0; r < s.length; r++) { let a = s[r]; i && (a.oldValue = i[r].value); let l = a.dir[o]; l && (Ot(), lt(l, n, 8, [e.el, a, e, t]), xt()) } } var gu = Symbol("_vte"), ba = e => e.__isTeleport; var jt = Symbol("_leaveCb"), Qo = Symbol("_enterCb"); function Mi() { let e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map }; return zt(() => { e.isMounted = !0 }), An(() => { e.isUnmounting = !0 }), e } var at = [Function, Array], Vi = { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: at, onEnter: at, onAfterEnter: at, onEnterCancelled: at, onBeforeLeave: at, onLeave: at, onAfterLeave: at, onLeaveCancelled: at, onBeforeAppear: at, onAppear: at, onAfterAppear: at, onAppearCancelled: at }, Na = e => { let t = e.subTree; return t.component ? Na(t.component) : t }, _u = { name: "BaseTransition", props: Vi, setup(e, { slots: t }) { let n = Ui(), o = Mi(); return () => { let s = t.default && ls(t.default(), !0); if (!s || !s.length) return; let i = wa(s), r = ne(e), { mode: a } = r; if (o.isLeaving) return Ei(i); let l = Zr(i); if (!l) return Ei(i); let u = kn(l, r, o, n, d => u = d); l.type !== Ie && Kt(l, u); let c = n.subTree && Zr(n.subTree); if (c && c.type !== Ie && !ln(l, c) && Na(n).type !== Ie) { let d = kn(c, r, o, n); if (Kt(c, d), a === "out-in" && l.type !== Ie) return o.isLeaving = !0, d.afterLeave = () => { o.isLeaving = !1, n.job.flags & 8 || n.update(), delete d.afterLeave, c = void 0 }, Ei(i); a === "in-out" && l.type !== Ie ? d.delayLeave = (p, h, v) => { let b = xa(o, c); b[String(c.key)] = c, p[jt] = () => { h(), p[jt] = void 0, delete u.delayedLeave, c = void 0 }, u.delayedLeave = () => { v(), delete u.delayedLeave, c = void 0 } } : c = void 0 } else c && (c = void 0); return i } } }; function wa(e) { let t = e[0]; if (e.length > 1) { let n = !1; for (let o of e) if (o.type !== Ie) { t = o, n = !0; break } } return t } var Oa = _u; function xa(e, t) { let { leavingVNodes: n } = e, o = n.get(t.type); return o || (o = Object.create(null), n.set(t.type, o)), o } function kn(e, t, n, o, s) { let { appear: i, mode: r, persisted: a = !1, onBeforeEnter: l, onEnter: u, onAfterEnter: c, onEnterCancelled: d, onBeforeLeave: p, onLeave: h, onAfterLeave: v, onLeaveCancelled: b, onBeforeAppear: y, onAppear: E, onAfterAppear: N, onAppearCancelled: k } = t, G = String(e.key), C = xa(n, e), D = (_, M) => { _ && lt(_, o, 9, M) }, z = (_, M) => { let Y = M[1]; D(_, M), W(_) ? _.every(L => L.length <= 1) && Y() : _.length <= 1 && Y() }, P = { mode: r, persisted: a, beforeEnter(_) { let M = l; if (!n.isMounted) if (i) M = y || l; else return; _[jt] && _[jt](!0); let Y = C[G]; Y && ln(e, Y) && Y.el[jt] && Y.el[jt](), D(M, [_]) }, enter(_) { let M = u, Y = c, L = d; if (!n.isMounted) if (i) M = E || u, Y = N || c, L = k || d; else return; let le = !1, A = _[Qo] = Z => { le || (le = !0, Z ? D(L, [_]) : D(Y, [_]), P.delayedLeave && P.delayedLeave(), _[Qo] = void 0) }; M ? z(M, [_, A]) : A() }, leave(_, M) { let Y = String(e.key); if (_[Qo] && _[Qo](!0), n.isUnmounting) return M(); D(p, [_]); let L = !1, le = _[jt] = A => { L || (L = !0, M(), A ? D(b, [_]) : D(v, [_]), _[jt] = void 0, C[Y] === e && delete C[Y]) }; C[Y] = e, h ? z(h, [_, le]) : le() }, clone(_) { let M = kn(_, t, n, o, s); return s && s(M), M } }; return P } function Ei(e) { if (cs(e)) return e = Gt(e), e.children = null, e } function Zr(e) { if (!cs(e)) return ba(e.type) && e.children ? wa(e.children) : e; if (e.component) return e.component.subTree; let { shapeFlag: t, children: n } = e; if (n) { if (t & 16) return n[0]; if (t & 32 && q(n.default)) return n.default() } } function Kt(e, t) { e.shapeFlag & 6 && e.component ? (e.transition = t, Kt(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t } function ls(e, t = !1, n) { let o = [], s = 0; for (let i = 0; i < e.length; i++) { let r = e[i], a = n == null ? r.key : String(n) + String(r.key != null ? r.key : i); r.type === ae ? (r.patchFlag & 128 && s++, o = o.concat(ls(r.children, t, a))) : (t || r.type !== Ie) && o.push(a != null ? Gt(r, { key: a }) : r) } if (s > 1) for (let i = 0; i < o.length; i++)o[i].patchFlag = -2; return o } function me(e, t) { return q(e) ? ge({ name: e.name }, t, { setup: e }) : e } function Ca(e) { e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0] } function os(e, t, n, o, s = !1) { if (W(e)) { e.forEach((v, b) => os(v, t && (W(t) ? t[b] : t), n, o, s)); return } if (Tn(o) && !s) { o.shapeFlag & 512 && o.type.__asyncResolved && o.component.subTree.component && os(e, t, n, o.component.subTree); return } let i = o.shapeFlag & 4 ? hs(o.component) : o.el, r = s ? null : i, { i: a, r: l } = e, u = t && t.r, c = a.refs === ce ? a.refs = {} : a.refs, d = a.setupState, p = ne(d), h = d === ce ? () => !1 : v => re(p, v); if (u != null && u !== l && (ve(u) ? (c[u] = null, h(u) && (d[u] = null)) : be(u) && (u.value = null)), q(l)) vo(l, a, 12, [r, c]); else { let v = ve(l), b = be(l); if (v || b) { let y = () => { if (e.f) { let E = v ? h(l) ? d[l] : c[l] : l.value; s ? W(E) && qn(E, i) : W(E) ? E.includes(i) || E.push(i) : v ? (c[l] = [i], h(l) && (d[l] = c[l])) : (l.value = [i], e.k && (c[e.k] = l.value)) } else v ? (c[l] = r, h(l) && (d[l] = r)) : b && (l.value = r, e.k && (c[e.k] = r)) }; r ? (y.id = -1, Qe(y, n)) : y() } } } var cg = Ft().requestIdleCallback || (e => setTimeout(e, 1)), ug = Ft().cancelIdleCallback || (e => clearTimeout(e)); var Tn = e => !!e.type.__asyncLoader; var cs = e => e.type.__isKeepAlive; function yu(e, t) { Ta(e, "a", t) } function Eu(e, t) { Ta(e, "da", t) } function Ta(e, t, n = Me) { let o = e.__wdc || (e.__wdc = () => { let s = n; for (; s;) { if (s.isDeactivated) return; s = s.parent } return e() }); if (us(t, o, n), n) { let s = n.parent; for (; s && s.parent;)cs(s.parent.vnode) && bu(o, t, n, s), s = s.parent } } function bu(e, t, n, o) { let s = us(t, e, o, !0); Ai(() => { qn(o[t], s) }, n) } function us(e, t, n = Me, o = !1) { if (n) { let s = n[e] || (n[e] = []), i = t.__weh || (t.__weh = (...r) => { Ot(); let a = yo(n), l = lt(t, n, e, r); return a(), xt(), l }); return o ? s.unshift(i) : s.push(i), i } } var Lt = e => (t, n = Me) => { (!mo || e === "sp") && us(e, (...o) => t(...o), n) }, Nu = Lt("bm"), zt = Lt("m"), Sa = Lt("bu"), Vn = Lt("u"), An = Lt("bum"), Ai = Lt("um"), wu = Lt("sp"), Ou = Lt("rtg"), xu = Lt("rtc"); function Cu(e, t = Me) { us("ec", e, t) } var Ri = "components"; function Yt(e, t) { return ka(Ri, e, !0, t) || e } var Da = Symbol.for("v-ndc"); function ds(e) { return ve(e) ? ka(Ri, e, !1) || e : e || Da } function ka(e, t, n = !0, o = !1) { let s = Te || Me; if (s) { let i = s.type; if (e === Ri) { let a = fd(i, !1); if (a && (a === t || a === $e(t) || a === nn($e(t)))) return i } let r = Qr(s[e] || i[e], t) || Qr(s.appContext[e], t); return !r && o ? i : r } } function Qr(e, t) { return e && (e[t] || e[$e(t)] || e[nn($e(t))]) } function ct(e, t, n, o) { let s, i = n && n[o], r = W(e); if (r || ve(e)) { let a = r && Ut(e), l = !1, u = !1; a && (l = !Ge(e), u = wt(e), e = io(e)), s = new Array(e.length); for (let c = 0, d = e.length; c < d; c++)s[c] = t(l ? u ? so(Ce(e[c])) : Ce(e[c]) : e[c], c, void 0, i && i[c]) } else if (typeof e == "number") { s = new Array(e); for (let a = 0; a < e; a++)s[a] = t(a + 1, a, void 0, i && i[a]) } else if (de(e)) if (e[Symbol.iterator]) s = Array.from(e, (a, l) => t(a, l, void 0, i && i[l])); else { let a = Object.keys(e); s = new Array(a.length); for (let l = 0, u = a.length; l < u; l++) { let c = a[l]; s[l] = t(e[c], c, l, i && i[l]) } } else s = []; return n && (n[o] = s), s } function We(e, t, n = {}, o, s) { if (Te.ce || Te.parent && Tn(Te.parent) && Te.parent.ce) return t !== "default" && (n.name = t), S(), Oe(ae, null, [oe("slot", n, o && o())], 64); let i = e[t]; i && i._c && (i._d = !1), S(); let r = i && Ia(i(n)), a = n.key || r && r.key, l = Oe(ae, { key: (a && !rt(a) ? a : `_${t}`) + (!r && o ? "_fb" : "") }, r || (o ? o() : []), r && e._ === 1 ? 64 : -2); return !s && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]), i && i._c && (i._d = !0), l } function Ia(e) { return e.some(t => ho(t) ? !(t.type === Ie || t.type === ae && !Ia(t.children)) : !0) ? e : null } var xi = e => e ? Ja(e) ? hs(e) : xi(e.parent) : null, co = ge(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => xi(e.parent), $root: e => xi(e.root), $host: e => e.ce, $emit: e => e.emit, $options: e => __VUE_OPTIONS_API__ ? $i(e) : e.type, $forceUpdate: e => e.f || (e.f = () => { ki(e.update) }), $nextTick: e => e.n || (e.n = In.bind(e.proxy)), $watch: e => __VUE_OPTIONS_API__ ? zu.bind(e) : Ue }); var bi = (e, t) => e !== ce && !e.__isScriptSetup && re(e, t), Tu = { get({ _: e }, t) { if (t === "__v_skip") return !0; let { ctx: n, setupState: o, data: s, props: i, accessCache: r, type: a, appContext: l } = e, u; if (t[0] !== "$") { let h = r[t]; if (h !== void 0) switch (h) { case 1: return o[t]; case 2: return s[t]; case 4: return n[t]; case 3: return i[t] } else { if (bi(o, t)) return r[t] = 1, o[t]; if (s !== ce && re(s, t)) return r[t] = 2, s[t]; if ((u = e.propsOptions[0]) && re(u, t)) return r[t] = 3, i[t]; if (n !== ce && re(n, t)) return r[t] = 4, n[t]; (!__VUE_OPTIONS_API__ || Ci) && (r[t] = 0) } } let c = co[t], d, p; if (c) return t === "$attrs" && ke(e.attrs, "get", ""), c(e); if ((d = a.__cssModules) && (d = d[t])) return d; if (n !== ce && re(n, t)) return r[t] = 4, n[t]; if (p = l.config.globalProperties, re(p, t)) return p[t] }, set({ _: e }, t, n) { let { data: o, setupState: s, ctx: i } = e; return bi(s, t) ? (s[t] = n, !0) : o !== ce && re(o, t) ? (o[t] = n, !0) : re(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (i[t] = n, !0) }, has({ _: { data: e, setupState: t, accessCache: n, ctx: o, appContext: s, propsOptions: i } }, r) { let a; return !!n[r] || e !== ce && re(e, r) || bi(t, r) || (a = i[0]) && re(a, r) || re(o, r) || re(co, r) || re(s.config.globalProperties, r) }, defineProperty(e, t, n) { return n.get != null ? e._.accessCache[t] = 0 : re(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n) } }; function ea(e) { return W(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e } var Ci = !0; function Su(e) { let t = $i(e), n = e.proxy, o = e.ctx; Ci = !1, t.beforeCreate && ta(t.beforeCreate, e, "bc"); let { data: s, computed: i, methods: r, watch: a, provide: l, inject: u, created: c, beforeMount: d, mounted: p, beforeUpdate: h, updated: v, activated: b, deactivated: y, beforeDestroy: E, beforeUnmount: N, destroyed: k, unmounted: G, render: C, renderTracked: D, renderTriggered: z, errorCaptured: P, serverPrefetch: _, expose: M, inheritAttrs: Y, components: L, directives: le, filters: A } = t; if (u && Du(u, o, null), r) for (let se in r) { let ee = r[se]; q(ee) && (o[se] = ee.bind(n)) } if (s) { let se = s.call(n, n); de(se) && (e.data = Le(se)) } if (Ci = !0, i) for (let se in i) { let ee = i[se], xe = q(ee) ? ee.bind(n, n) : q(ee.get) ? ee.get.bind(n, n) : Ue, pn = !q(ee) && q(ee.set) ? ee.set.bind(n) : Ue, pt = j({ get: xe, set: pn }); Object.defineProperty(o, se, { enumerable: !0, configurable: !0, get: () => pt.value, set: ht => pt.value = ht }) } if (a) for (let se in a) Ma(a[se], o, n, se); if (l) { let se = q(l) ? l.call(n) : l; Reflect.ownKeys(se).forEach(ee => { fs(ee, se[ee]) }) } c && ta(c, e, "c"); function J(se, ee) { W(ee) ? ee.forEach(xe => se(xe.bind(n))) : ee && se(ee.bind(n)) } if (J(Nu, d), J(zt, p), J(Sa, h), J(Vn, v), J(yu, b), J(Eu, y), J(Cu, P), J(xu, D), J(Ou, z), J(An, N), J(Ai, G), J(wu, _), W(M)) if (M.length) { let se = e.exposed || (e.exposed = {}); M.forEach(ee => { Object.defineProperty(se, ee, { get: () => n[ee], set: xe => n[ee] = xe }) }) } else e.exposed || (e.exposed = {}); C && e.render === Ue && (e.render = C), Y != null && (e.inheritAttrs = Y), L && (e.components = L), le && (e.directives = le), _ && Ca(e) } function Du(e, t, n = Ue) { W(e) && (e = Ti(e)); for (let o in e) { let s = e[o], i; de(s) ? "default" in s ? i = cn(s.from || o, s.default, !0) : i = cn(s.from || o) : i = cn(s), be(i) ? Object.defineProperty(t, o, { enumerable: !0, configurable: !0, get: () => i.value, set: r => i.value = r }) : t[o] = i } } function ta(e, t, n) { lt(W(e) ? e.map(o => o.bind(t.proxy)) : e.bind(t.proxy), t, n) } function Ma(e, t, n, o) { let s = o.includes(".") ? Ga(n, o) : () => n[o]; if (ve(e)) { let i = t[e]; q(i) && ze(s, i) } else if (q(e)) ze(s, e.bind(n)); else if (de(e)) if (W(e)) e.forEach(i => Ma(i, t, n, o)); else { let i = q(e.handler) ? e.handler.bind(n) : t[e.handler]; q(i) && ze(s, i, e) } } function $i(e) { let t = e.type, { mixins: n, extends: o } = t, { mixins: s, optionsCache: i, config: { optionMergeStrategies: r } } = e.appContext, a = i.get(t), l; return a ? l = a : !s.length && !n && !o ? l = t : (l = {}, s.length && s.forEach(u => ss(l, u, r, !0)), ss(l, t, r)), de(t) && i.set(t, l), l } function ss(e, t, n, o = !1) { let { mixins: s, extends: i } = t; i && ss(e, i, n, !0), s && s.forEach(r => ss(e, r, n, !0)); for (let r in t) if (!(o && r === "expose")) { let a = ku[r] || n && n[r]; e[r] = a ? a(e[r], t[r]) : t[r] } return e } var ku = { data: na, props: oa, emits: oa, methods: lo, computed: lo, beforeCreate: Be, created: Be, beforeMount: Be, mounted: Be, beforeUpdate: Be, updated: Be, beforeDestroy: Be, beforeUnmount: Be, destroyed: Be, unmounted: Be, activated: Be, deactivated: Be, errorCaptured: Be, serverPrefetch: Be, components: lo, directives: lo, watch: Mu, provide: na, inject: Iu }; function na(e, t) { return t ? e ? function () { return ge(q(e) ? e.call(this, this) : e, q(t) ? t.call(this, this) : t) } : t : e } function Iu(e, t) { return lo(Ti(e), Ti(t)) } function Ti(e) { if (W(e)) { let t = {}; for (let n = 0; n < e.length; n++)t[e[n]] = e[n]; return t } return e } function Be(e, t) { return e ? [...new Set([].concat(e, t))] : t } function lo(e, t) { return e ? ge(Object.create(null), e, t) : t } function oa(e, t) { return e ? W(e) && W(t) ? [...new Set([...e, ...t])] : ge(Object.create(null), ea(e), ea(t ?? {})) : t } function Mu(e, t) { if (!e) return t; if (!t) return e; let n = ge(Object.create(null), e); for (let o in t) n[o] = Be(e[o], t[o]); return n } function Va() { return { app: null, config: { isNativeTag: Cr, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } var Vu = 0; function Au(e, t) { return function (o, s = null) { q(o) || (o = ge({}, o)), s != null && !de(s) && (s = null); let i = Va(), r = new WeakSet, a = [], l = !1, u = i.app = { _uid: Vu++, _component: o, _props: s, _container: null, _context: i, _instance: null, version: fa, get config() { return i.config }, set config(c) { }, use(c, ...d) { return r.has(c) || (c && q(c.install) ? (r.add(c), c.install(u, ...d)) : q(c) && (r.add(c), c(u, ...d))), u }, mixin(c) { return __VUE_OPTIONS_API__ && (i.mixins.includes(c) || i.mixins.push(c)), u }, component(c, d) { return d ? (i.components[c] = d, u) : i.components[c] }, directive(c, d) { return d ? (i.directives[c] = d, u) : i.directives[c] }, mount(c, d, p) { if (!l) { let h = u._ceVNode || oe(o, s); return h.appContext = i, p === !0 ? p = "svg" : p === !1 && (p = void 0), d && t ? t(h, c) : e(h, c, p), l = !0, u._container = c, c.__vue_app__ = u, __VUE_PROD_DEVTOOLS__ && (u._instance = h.component, du(u, fa)), hs(h.component) } }, onUnmount(c) { a.push(c) }, unmount() { l && (lt(a, u._instance, 16), e(null, u._container), __VUE_PROD_DEVTOOLS__ && (u._instance = null, fu(u)), delete u._container.__vue_app__) }, provide(c, d) { return i.provides[c] = d, u }, runWithContext(c) { let d = Sn; Sn = u; try { return c() } finally { Sn = d } } }; return u } } var Sn = null; function fs(e, t) { if (Me) { let n = Me.provides, o = Me.parent && Me.parent.provides; o === n && (n = Me.provides = Object.create(o)), n[e] = t } } function cn(e, t, n = !1) { let o = Me || Te; if (o || Sn) { let s = Sn ? Sn._context.provides : o ? o.parent == null || o.ce ? o.vnode.appContext && o.vnode.appContext.provides : o.parent.provides : void 0; if (s && e in s) return s[e]; if (arguments.length > 1) return n && q(t) ? t.call(o && o.proxy) : t } } var Aa = {}, Ra = () => Object.create(Aa), $a = e => Object.getPrototypeOf(e) === Aa; function Ru(e, t, n, o = !1) { let s = {}, i = Ra(); e.propsDefaults = Object.create(null), Pa(e, t, s, i); for (let r in e.propsOptions[0]) r in s || (s[r] = void 0); n ? e.props = o ? s : vi(s) : e.type.props ? e.props = s : e.props = i, e.attrs = i } function $u(e, t, n, o) { let { props: s, attrs: i, vnode: { patchFlag: r } } = e, a = ne(s), [l] = e.propsOptions, u = !1; if ((o || r > 0) && !(r & 16)) { if (r & 8) { let c = e.vnode.dynamicProps; for (let d = 0; d < c.length; d++) { let p = c[d]; if (ps(e.emitsOptions, p)) continue; let h = t[p]; if (l) if (re(i, p)) h !== i[p] && (i[p] = h, u = !0); else { let v = $e(p); s[v] = Si(l, a, v, h, e, !1) } else h !== i[p] && (i[p] = h, u = !0) } } } else { Pa(e, t, s, i) && (u = !0); let c; for (let d in a) (!t || !re(t, d) && ((c = yt(d)) === d || !re(t, c))) && (l ? n && (n[d] !== void 0 || n[c] !== void 0) && (s[d] = Si(l, a, d, void 0, e, !0)) : delete s[d]); if (i !== a) for (let d in i) (!t || !re(t, d)) && (delete i[d], u = !0) } u && bt(e.attrs, "set", "") } function Pa(e, t, n, o) { let [s, i] = e.propsOptions, r = !1, a; if (t) for (let l in t) { if (yn(l)) continue; let u = t[l], c; s && re(s, c = $e(l)) ? !i || !i.includes(c) ? n[c] = u : (a || (a = {}))[c] = u : ps(e.emitsOptions, l) || (!(l in o) || u !== o[l]) && (o[l] = u, r = !0) } if (i) { let l = ne(n), u = a || ce; for (let c = 0; c < i.length; c++) { let d = i[c]; n[d] = Si(s, l, d, u[d], e, !re(u, d)) } } return r } function Si(e, t, n, o, s, i) { let r = e[n]; if (r != null) { let a = re(r, "default"); if (a && o === void 0) { let l = r.default; if (r.type !== Function && !r.skipFactory && q(l)) { let { propsDefaults: u } = s; if (n in u) o = u[n]; else { let c = yo(s); o = u[n] = l.call(null, t), c() } } else o = l; s.ce && s.ce._setProp(n, o) } r[0] && (i && !a ? o = !1 : r[1] && (o === "" || o === yt(n)) && (o = !0)) } return o } var Pu = new WeakMap; function La(e, t, n = !1) { let o = __VUE_OPTIONS_API__ && n ? Pu : t.propsCache, s = o.get(e); if (s) return s; let i = e.props, r = {}, a = [], l = !1; if (__VUE_OPTIONS_API__ && !q(e)) { let c = d => { l = !0; let [p, h] = La(d, t, !0); ge(r, p), h && a.push(...h) }; !n && t.mixins.length && t.mixins.forEach(c), e.extends && c(e.extends), e.mixins && e.mixins.forEach(c) } if (!i && !l) return de(e) && o.set(e, en), en; if (W(i)) for (let c = 0; c < i.length; c++) { let d = $e(i[c]); sa(d) && (r[d] = ce) } else if (i) for (let c in i) { let d = $e(c); if (sa(d)) { let p = i[c], h = r[d] = W(p) || q(p) ? { type: p } : ge({}, p), v = h.type, b = !1, y = !0; if (W(v)) for (let E = 0; E < v.length; ++E) { let N = v[E], k = q(N) && N.name; if (k === "Boolean") { b = !0; break } else k === "String" && (y = !1) } else b = q(v) && v.name === "Boolean"; h[0] = b, h[1] = y, (b || re(h, "default")) && a.push(d) } } let u = [r, a]; return de(e) && o.set(e, u), u } function sa(e) { return e[0] !== "$" && !yn(e) } var Pi = e => e[0] === "_" || e === "$stable", Li = e => W(e) ? e.map(Dt) : [Dt(e)], Lu = (e, t, n) => { if (t._n) return t; let o = Mn((...s) => Li(t(...s)), n); return o._c = !1, o }, Ha = (e, t, n) => { let o = e._ctx; for (let s in e) { if (Pi(s)) continue; let i = e[s]; if (q(i)) t[s] = Lu(s, i, o); else if (i != null) { let r = Li(i); t[s] = () => r } } }, Fa = (e, t) => { let n = Li(t); e.slots.default = () => n }, Ua = (e, t, n) => { for (let o in t) (n || !Pi(o)) && (e[o] = t[o]) }, Hu = (e, t, n) => { let o = e.slots = Ra(); if (e.vnode.shapeFlag & 32) { let s = t._; s ? (Ua(o, t, n), n && bn(o, "_", s, !0)) : Ha(t, o) } else t && Fa(e, t) }, Fu = (e, t, n) => { let { vnode: o, slots: s } = e, i = !0, r = ce; if (o.shapeFlag & 32) { let a = t._; a ? n && a === 1 ? i = !1 : Ua(s, t, n) : (i = !t.$stable, Ha(t, s)), r = t } else t && (Fa(e, t), r = { default: 1 }); if (i) for (let a in s) !Pi(a) && r[a] == null && delete s[a] }; function Uu() { let e = []; typeof __VUE_OPTIONS_API__ != "boolean" && (Ft().__VUE_OPTIONS_API__ = !0), typeof __VUE_PROD_DEVTOOLS__ != "boolean" && (Ft().__VUE_PROD_DEVTOOLS__ = !1), typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ != "boolean" && (Ft().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = !1) } var Qe = ed; function Ba(e) { return Bu(e) } function Bu(e, t) { Uu(); let n = Ft(); n.__VUE__ = !0, __VUE_PROD_DEVTOOLS__ && _a(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n); let { insert: o, remove: s, patchProp: i, createElement: r, createText: a, createComment: l, setText: u, setElementText: c, parentNode: d, nextSibling: p, setScopeId: h = Ue, insertStaticContent: v } = e, b = (f, m, g, O = null, w = null, x = null, R = void 0, V = null, I = !!m.dynamicChildren) => { if (f === m) return; f && !ln(f, m) && (O = So(f), ut(f, w, x, !0), f = null), m.patchFlag === -2 && (I = !1, m.dynamicChildren = null); let { type: T, ref: K, shapeFlag: $ } = m; switch (T) { case go: y(f, m, g, O); break; case Ie: E(f, m, g, O); break; case Dn: f == null && N(m, g, O, R); break; case ae: le(f, m, g, O, w, x, R, V, I); break; default: $ & 1 ? D(f, m, g, O, w, x, R, V, I) : $ & 6 ? A(f, m, g, O, w, x, R, V, I) : ($ & 64 || $ & 128) && T.process(f, m, g, O, w, x, R, V, I, hn) }K != null && w && os(K, f && f.ref, x, m || f, !m) }, y = (f, m, g, O) => { if (f == null) o(m.el = a(m.children), g, O); else { let w = m.el = f.el; m.children !== f.children && u(w, m.children) } }, E = (f, m, g, O) => { f == null ? o(m.el = l(m.children || ""), g, O) : m.el = f.el }, N = (f, m, g, O) => { [f.el, f.anchor] = v(f.children, m, g, O, f.el, f.anchor) }, k = (f, m, g, O) => { if (m.children !== f.children) { let w = p(f.anchor); C(f), [m.el, m.anchor] = v(m.children, g, w, O) } else m.el = f.el, m.anchor = f.anchor }, G = ({ el: f, anchor: m }, g, O) => { let w; for (; f && f !== m;)w = p(f), o(f, g, O), f = w; o(m, g, O) }, C = ({ el: f, anchor: m }) => { let g; for (; f && f !== m;)g = p(f), s(f), f = g; s(m) }, D = (f, m, g, O, w, x, R, V, I) => { m.type === "svg" ? R = "svg" : m.type === "math" && (R = "mathml"), f == null ? z(m, g, O, w, x, R, V, I) : M(f, m, w, x, R, V, I) }, z = (f, m, g, O, w, x, R, V) => { let I, T, { props: K, shapeFlag: $, transition: B, dirs: X } = f; if (I = f.el = r(f.type, x, K && K.is, K), $ & 8 ? c(I, f.children) : $ & 16 && _(f.children, I, null, O, w, Ni(f, x), R, V), X && rn(f, null, O, "created"), P(I, f, f.scopeId, R, O), K) { for (let fe in K) fe !== "value" && !yn(fe) && i(I, fe, null, K[fe], x, O); "value" in K && i(I, "value", null, K.value, x), (T = K.onVnodeBeforeMount) && Tt(T, O, f) } __VUE_PROD_DEVTOOLS__ && (bn(I, "__vnode", f, !0), bn(I, "__vueParentComponent", O, !0)), X && rn(f, null, O, "beforeMount"); let ie = ju(w, B); ie && B.beforeEnter(I), o(I, m, g), ((T = K && K.onVnodeMounted) || ie || X) && Qe(() => { T && Tt(T, O, f), ie && B.enter(I), X && rn(f, null, O, "mounted") }, w) }, P = (f, m, g, O, w) => { if (g && h(f, g), O) for (let x = 0; x < O.length; x++)h(f, O[x]); if (w) { let x = w.subTree; if (m === x || Ya(x.type) && (x.ssContent === m || x.ssFallback === m)) { let R = w.vnode; P(f, R, R.scopeId, R.slotScopeIds, w.parent) } } }, _ = (f, m, g, O, w, x, R, V, I = 0) => { for (let T = I; T < f.length; T++) { let K = f[T] = V ? Wt(f[T]) : Dt(f[T]); b(null, K, m, g, O, w, x, R, V) } }, M = (f, m, g, O, w, x, R) => { let V = m.el = f.el; __VUE_PROD_DEVTOOLS__ && (V.__vnode = m); let { patchFlag: I, dynamicChildren: T, dirs: K } = m; I |= f.patchFlag & 16; let $ = f.props || ce, B = m.props || ce, X; if (g && an(g, !1), (X = B.onVnodeBeforeUpdate) && Tt(X, g, m, f), K && rn(m, f, g, "beforeUpdate"), g && an(g, !0), ($.innerHTML && B.innerHTML == null || $.textContent && B.textContent == null) && c(V, ""), T ? Y(f.dynamicChildren, T, V, g, O, Ni(m, w), x) : R || xe(f, m, V, null, g, O, Ni(m, w), x, !1), I > 0) { if (I & 16) L(V, $, B, g, w); else if (I & 2 && $.class !== B.class && i(V, "class", null, B.class, w), I & 4 && i(V, "style", $.style, B.style, w), I & 8) { let ie = m.dynamicProps; for (let fe = 0; fe < ie.length; fe++) { let ue = ie[fe], qe = $[ue], Ae = B[ue]; (Ae !== qe || ue === "value") && i(V, ue, qe, Ae, w, g) } } I & 1 && f.children !== m.children && c(V, m.children) } else !R && T == null && L(V, $, B, g, w); ((X = B.onVnodeUpdated) || K) && Qe(() => { X && Tt(X, g, m, f), K && rn(m, f, g, "updated") }, O) }, Y = (f, m, g, O, w, x, R) => { for (let V = 0; V < m.length; V++) { let I = f[V], T = m[V], K = I.el && (I.type === ae || !ln(I, T) || I.shapeFlag & 198) ? d(I.el) : g; b(I, T, K, null, O, w, x, R, !0) } }, L = (f, m, g, O, w) => { if (m !== g) { if (m !== ce) for (let x in m) !yn(x) && !(x in g) && i(f, x, m[x], null, w, O); for (let x in g) { if (yn(x)) continue; let R = g[x], V = m[x]; R !== V && x !== "value" && i(f, x, V, R, w, O) } "value" in g && i(f, "value", m.value, g.value, w) } }, le = (f, m, g, O, w, x, R, V, I) => { let T = m.el = f ? f.el : a(""), K = m.anchor = f ? f.anchor : a(""), { patchFlag: $, dynamicChildren: B, slotScopeIds: X } = m; X && (V = V ? V.concat(X) : X), f == null ? (o(T, g, O), o(K, g, O), _(m.children || [], g, K, w, x, R, V, I)) : $ > 0 && $ & 64 && B && f.dynamicChildren ? (Y(f.dynamicChildren, B, g, w, x, R, V), (m.key != null || w && m === w.subTree) && ja(f, m, !0)) : xe(f, m, g, K, w, x, R, V, I) }, A = (f, m, g, O, w, x, R, V, I) => { m.slotScopeIds = V, f == null ? m.shapeFlag & 512 ? w.ctx.activate(m, g, O, R, I) : Z(m, g, O, w, x, R, I) : J(f, m, I) }, Z = (f, m, g, O, w, x, R) => { let V = f.component = ad(f, O, w); if (cs(f) && (V.ctx.renderer = hn), ld(V, !1, R), V.asyncDep) { if (w && w.registerDep(V, se, R), !f.el) { let I = V.subTree = oe(Ie); E(null, I, m, g) } } else se(V, f, m, g, w, x, R) }, J = (f, m, g) => { let O = m.component = f.component; if (Zu(f, m, g)) if (O.asyncDep && !O.asyncResolved) { ee(O, m, g); return } else O.next = m, O.update(); else m.el = f.el, O.vnode = m }, se = (f, m, g, O, w, x, R) => { let V = () => { if (f.isMounted) { let { next: $, bu: B, u: X, parent: ie, vnode: fe } = f; { let Xe = Wa(f); if (Xe) { $ && ($.el = fe.el, ee(f, $, R)), Xe.asyncDep.then(() => { f.isUnmounted || V() }); return } } let ue = $, qe; an(f, !1), $ ? ($.el = fe.el, ee(f, $, R)) : $ = fe, B && En(B), (qe = $.props && $.props.onVnodeBeforeUpdate) && Tt(qe, ie, $, fe), an(f, !0); let Ae = wi(f), dt = f.subTree; f.subTree = Ae, b(dt, Ae, d(dt.el), So(dt), f, w, x), $.el = Ae.el, ue === null && Qu(f, Ae.el), X && Qe(X, w), (qe = $.props && $.props.onVnodeUpdated) && Qe(() => Tt(qe, ie, $, fe), w), __VUE_PROD_DEVTOOLS__ && ya(f) } else { let $, { el: B, props: X } = m, { bm: ie, m: fe, parent: ue, root: qe, type: Ae } = f, dt = Tn(m); if (an(f, !1), ie && En(ie), !dt && ($ = X && X.onVnodeBeforeMount) && Tt($, ue, m), an(f, !0), B && Ps) { let Xe = () => { f.subTree = wi(f), Ps(B, f.subTree, f, w, null) }; dt && Ae.__asyncHydrate ? Ae.__asyncHydrate(B, f, Xe) : Xe() } else { qe.ce && qe.ce._injectChildStyle(Ae); let Xe = f.subTree = wi(f); b(null, Xe, g, O, f, w, x), m.el = Xe.el } if (fe && Qe(fe, w), !dt && ($ = X && X.onVnodeMounted)) { let Xe = m; Qe(() => Tt($, ue, Xe), w) } (m.shapeFlag & 256 || ue && Tn(ue.vnode) && ue.vnode.shapeFlag & 256) && f.a && Qe(f.a, w), f.isMounted = !0, __VUE_PROD_DEVTOOLS__ && pu(f), m = g = O = null } }; f.scope.on(); let I = f.effect = new wn(V); f.scope.off(); let T = f.update = I.run.bind(I), K = f.job = I.runIfDirty.bind(I); K.i = f, K.id = f.uid, I.scheduler = () => ki(K), an(f, !0), T() }, ee = (f, m, g) => { m.component = f; let O = f.vnode.props; f.vnode = m, f.next = null, $u(f, m.props, O, g), Fu(f, m.children, g), Ot(), Jr(f), xt() }, xe = (f, m, g, O, w, x, R, V, I = !1) => { let T = f && f.children, K = f ? f.shapeFlag : 0, $ = m.children, { patchFlag: B, shapeFlag: X } = m; if (B > 0) { if (B & 128) { pt(T, $, g, O, w, x, R, V, I); return } else if (B & 256) { pn(T, $, g, O, w, x, R, V, I); return } } X & 8 ? (K & 16 && Fn(T, w, x), $ !== T && c(g, $)) : K & 16 ? X & 16 ? pt(T, $, g, O, w, x, R, V, I) : Fn(T, w, x, !0) : (K & 8 && c(g, ""), X & 16 && _($, g, O, w, x, R, V, I)) }, pn = (f, m, g, O, w, x, R, V, I) => { f = f || en, m = m || en; let T = f.length, K = m.length, $ = Math.min(T, K), B; for (B = 0; B < $; B++) { let X = m[B] = I ? Wt(m[B]) : Dt(m[B]); b(f[B], X, g, null, w, x, R, V, I) } T > K ? Fn(f, w, x, !0, !1, $) : _(m, g, O, w, x, R, V, I, $) }, pt = (f, m, g, O, w, x, R, V, I) => { let T = 0, K = m.length, $ = f.length - 1, B = K - 1; for (; T <= $ && T <= B;) { let X = f[T], ie = m[T] = I ? Wt(m[T]) : Dt(m[T]); if (ln(X, ie)) b(X, ie, g, null, w, x, R, V, I); else break; T++ } for (; T <= $ && T <= B;) { let X = f[$], ie = m[B] = I ? Wt(m[B]) : Dt(m[B]); if (ln(X, ie)) b(X, ie, g, null, w, x, R, V, I); else break; $--, B-- } if (T > $) { if (T <= B) { let X = B + 1, ie = X < K ? m[X].el : O; for (; T <= B;)b(null, m[T] = I ? Wt(m[T]) : Dt(m[T]), g, ie, w, x, R, V, I), T++ } } else if (T > B) for (; T <= $;)ut(f[T], w, x, !0), T++; else { let X = T, ie = T, fe = new Map; for (T = ie; T <= B; T++) { let Je = m[T] = I ? Wt(m[T]) : Dt(m[T]); Je.key != null && fe.set(Je.key, T) } let ue, qe = 0, Ae = B - ie + 1, dt = !1, Xe = 0, Un = new Array(Ae); for (T = 0; T < Ae; T++)Un[T] = 0; for (T = X; T <= $; T++) { let Je = f[T]; if (qe >= Ae) { ut(Je, w, x, !0); continue } let mt; if (Je.key != null) mt = fe.get(Je.key); else for (ue = ie; ue <= B; ue++)if (Un[ue - ie] === 0 && ln(Je, m[ue])) { mt = ue; break } mt === void 0 ? ut(Je, w, x, !0) : (Un[mt - ie] = T + 1, mt >= Xe ? Xe = mt : dt = !0, b(Je, m[mt], g, null, w, x, R, V, I), qe++) } let Nr = dt ? Wu(Un) : en; for (ue = Nr.length - 1, T = Ae - 1; T >= 0; T--) { let Je = ie + T, mt = m[Je], wr = Je + 1 < K ? m[Je + 1].el : O; Un[T] === 0 ? b(null, mt, g, wr, w, x, R, V, I) : dt && (ue < 0 || T !== Nr[ue] ? ht(mt, g, wr, 2) : ue--) } } }, ht = (f, m, g, O, w = null) => { let { el: x, type: R, transition: V, children: I, shapeFlag: T } = f; if (T & 6) { ht(f.component.subTree, m, g, O); return } if (T & 128) { f.suspense.move(m, g, O); return } if (T & 64) { R.move(f, m, g, hn); return } if (R === ae) { o(x, m, g); for (let $ = 0; $ < I.length; $++)ht(I[$], m, g, O); o(f.anchor, m, g); return } if (R === Dn) { G(f, m, g); return } if (O !== 2 && T & 1 && V) if (O === 0) V.beforeEnter(x), o(x, m, g), Qe(() => V.enter(x), w); else { let { leave: $, delayLeave: B, afterLeave: X } = V, ie = () => { f.ctx.isUnmounted ? s(x) : o(x, m, g) }, fe = () => { $(x, () => { ie(), X && X() }) }; B ? B(x, ie, fe) : fe() } else o(x, m, g) }, ut = (f, m, g, O = !1, w = !1) => { let { type: x, props: R, ref: V, children: I, dynamicChildren: T, shapeFlag: K, patchFlag: $, dirs: B, cacheIndex: X } = f; if ($ === -2 && (w = !1), V != null && (Ot(), os(V, null, g, f, !0), xt()), X != null && (m.renderCache[X] = void 0), K & 256) { m.ctx.deactivate(f); return } let ie = K & 1 && B, fe = !Tn(f), ue; if (fe && (ue = R && R.onVnodeBeforeUnmount) && Tt(ue, m, f), K & 6) gc(f.component, g, O); else { if (K & 128) { f.suspense.unmount(g, O); return } ie && rn(f, null, m, "beforeUnmount"), K & 64 ? f.type.remove(f, m, g, hn, O) : T && !T.hasOnce && (x !== ae || $ > 0 && $ & 64) ? Fn(T, m, g, !1, !0) : (x === ae && $ & 384 || !w && K & 16) && Fn(I, m, g), O && Er(f) } (fe && (ue = R && R.onVnodeUnmounted) || ie) && Qe(() => { ue && Tt(ue, m, f), ie && rn(f, null, m, "unmounted") }, g) }, Er = f => { let { type: m, el: g, anchor: O, transition: w } = f; if (m === ae) { vc(g, O); return } if (m === Dn) { C(f); return } let x = () => { s(g), w && !w.persisted && w.afterLeave && w.afterLeave() }; if (f.shapeFlag & 1 && w && !w.persisted) { let { leave: R, delayLeave: V } = w, I = () => R(g, x); V ? V(f.el, x, I) : I() } else x() }, vc = (f, m) => { let g; for (; f !== m;)g = p(f), s(f), f = g; s(m) }, gc = (f, m, g) => { let { bum: O, scope: w, job: x, subTree: R, um: V, m: I, a: T, parent: K, slots: { __: $ } } = f; ia(I), ia(T), O && En(O), K && W($) && $.forEach(B => { K.renderCache[B] = void 0 }), w.stop(), x && (x.flags |= 8, ut(R, f, m, g)), V && Qe(V, m), Qe(() => { f.isUnmounted = !0 }, m), m && m.pendingBranch && !m.isUnmounted && f.asyncDep && !f.asyncResolved && f.suspenseId === m.pendingId && (m.deps--, m.deps === 0 && m.resolve()), __VUE_PROD_DEVTOOLS__ && mu(f) }, Fn = (f, m, g, O = !1, w = !1, x = 0) => { for (let R = x; R < f.length; R++)ut(f[R], m, g, O, w) }, So = f => { if (f.shapeFlag & 6) return So(f.component.subTree); if (f.shapeFlag & 128) return f.suspense.next(); let m = p(f.anchor || f.el), g = m && m[gu]; return g ? p(g) : m }, Rs = !1, br = (f, m, g) => { f == null ? m._vnode && ut(m._vnode, null, null, !0) : b(m._vnode || null, f, m, null, null, null, g), m._vnode = f, Rs || (Rs = !0, Jr(), va(), Rs = !1) }, hn = { p: b, um: ut, m: ht, r: Er, mt: Z, mc: _, pc: xe, pbc: Y, n: So, o: e }, $s, Ps; return t && ([$s, Ps] = t(hn)), { render: br, hydrate: $s, createApp: Au(br, $s) } } function Ni({ type: e, props: t }, n) { return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n } function an({ effect: e, job: t }, n) { n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5) } function ju(e, t) { return (!e || e && !e.pendingBranch) && t && !t.persisted } function ja(e, t, n = !1) { let o = e.children, s = t.children; if (W(o) && W(s)) for (let i = 0; i < o.length; i++) { let r = o[i], a = s[i]; a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = s[i] = Wt(s[i]), a.el = r.el), !n && a.patchFlag !== -2 && ja(r, a)), a.type === go && (a.el = r.el), a.type === Ie && !a.el && (a.el = r.el) } } function Wu(e) { let t = e.slice(), n = [0], o, s, i, r, a, l = e.length; for (o = 0; o < l; o++) { let u = e[o]; if (u !== 0) { if (s = n[n.length - 1], e[s] < u) { t[o] = s, n.push(o); continue } for (i = 0, r = n.length - 1; i < r;)a = i + r >> 1, e[n[a]] < u ? i = a + 1 : r = a; u < e[n[i]] && (i > 0 && (t[o] = n[i - 1]), n[i] = o) } } for (i = n.length, r = n[i - 1]; i-- > 0;)n[i] = r, r = t[r]; return n } function Wa(e) { let t = e.subTree.component; if (t) return t.asyncDep && !t.asyncResolved ? t : Wa(t) } function ia(e) { if (e) for (let t = 0; t < e.length; t++)e[t].flags |= 8 } var Ku = Symbol.for("v-scx"), Gu = () => { { let e = cn(Ku); return e } }; function ze(e, t, n) { return Ka(e, t, n) } function Ka(e, t, n = ce) { let { immediate: o, deep: s, flush: i, once: r } = n, a = ge({}, n), l = t && o || !t && i !== "post", u; if (mo) { if (i === "sync") { let h = Gu(); u = h.__watcherHandles || (h.__watcherHandles = []) } else if (!l) { let h = () => { }; return h.stop = Ue, h.resume = Ue, h.pause = Ue, h } } let c = Me; a.call = (h, v, b) => lt(h, c, v, b); let d = !1; i === "post" ? a.scheduler = h => { Qe(h, c && c.suspense) } : i !== "sync" && (d = !0, a.scheduler = (h, v) => { v ? h() : ki(h) }), a.augmentJob = h => { t && (h.flags |= 4), d && (h.flags |= 2, c && (h.id = c.uid, h.i = c)) }; let p = Xr(e, t, a); return mo && (u ? u.push(p) : l && p()), p } function zu(e, t, n) { let o = this.proxy, s = ve(e) ? e.includes(".") ? Ga(o, e) : () => o[e] : e.bind(o, o), i; q(t) ? i = t : (i = t.handler, n = t); let r = yo(this), a = Ka(s, i.bind(o), n); return r(), a } function Ga(e, t) { let n = t.split("."); return () => { let o = e; for (let s = 0; s < n.length && o; s++)o = o[n[s]]; return o } } var Yu = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${$e(t)}Modifiers`] || e[`${yt(t)}Modifiers`]; function qu(e, t, ...n) { if (e.isUnmounted) return; let o = e.vnode.props || ce, s = n, i = t.startsWith("update:"), r = i && Yu(o, t.slice(7)); r && (r.trim && (s = n.map(c => ve(c) ? c.trim() : c)), r.number && (s = n.map(Jn))), __VUE_PROD_DEVTOOLS__ && vu(e, t, s); let a, l = o[a = Xn(t)] || o[a = Xn($e(t))]; !l && i && (l = o[a = Xn(yt(t))]), l && lt(l, e, 6, s); let u = o[a + "Once"]; if (u) { if (!e.emitted) e.emitted = {}; else if (e.emitted[a]) return; e.emitted[a] = !0, lt(u, e, 6, s) } } function za(e, t, n = !1) { let o = t.emitsCache, s = o.get(e); if (s !== void 0) return s; let i = e.emits, r = {}, a = !1; if (__VUE_OPTIONS_API__ && !q(e)) { let l = u => { let c = za(u, t, !0); c && (a = !0, ge(r, c)) }; !n && t.mixins.length && t.mixins.forEach(l), e.extends && l(e.extends), e.mixins && e.mixins.forEach(l) } return !i && !a ? (de(e) && o.set(e, null), null) : (W(i) ? i.forEach(l => r[l] = null) : ge(r, i), de(e) && o.set(e, r), r) } function ps(e, t) { return !e || !_n(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), re(e, t[0].toLowerCase() + t.slice(1)) || re(e, yt(t)) || re(e, t)) } function wi(e) { let { type: t, vnode: n, proxy: o, withProxy: s, propsOptions: [i], slots: r, attrs: a, emit: l, render: u, renderCache: c, props: d, data: p, setupState: h, ctx: v, inheritAttrs: b } = e, y = ns(e), E, N; try { if (n.shapeFlag & 4) { let C = s || o, D = C; E = Dt(u.call(D, C, c, d, h, p, v)), N = a } else { let C = t; E = Dt(C.length > 1 ? C(d, { attrs: a, slots: r, emit: l }) : C(d, null)), N = t.props ? a : Xu(a) } } catch (C) { uo.length = 0, rs(C, e, 1), E = oe(Ie) } let k = E, G; if (N && b !== !1) { let C = Object.keys(N), { shapeFlag: D } = k; C.length && D & 7 && (i && C.some(Yn) && (N = Ju(N, i)), k = Gt(k, N, !1, !0)) } return n.dirs && (k = Gt(k, null, !1, !0), k.dirs = k.dirs ? k.dirs.concat(n.dirs) : n.dirs), n.transition && Kt(k, n.transition), E = k, ns(y), E } var Xu = e => { let t; for (let n in e) (n === "class" || n === "style" || _n(n)) && ((t || (t = {}))[n] = e[n]); return t }, Ju = (e, t) => { let n = {}; for (let o in e) (!Yn(o) || !(o.slice(9) in t)) && (n[o] = e[o]); return n }; function Zu(e, t, n) { let { props: o, children: s, component: i } = e, { props: r, children: a, patchFlag: l } = t, u = i.emitsOptions; if (t.dirs || t.transition) return !0; if (n && l >= 0) { if (l & 1024) return !0; if (l & 16) return o ? ra(o, r, u) : !!r; if (l & 8) { let c = t.dynamicProps; for (let d = 0; d < c.length; d++) { let p = c[d]; if (r[p] !== o[p] && !ps(u, p)) return !0 } } } else return (s || a) && (!a || !a.$stable) ? !0 : o === r ? !1 : o ? r ? ra(o, r, u) : !0 : !!r; return !1 } function ra(e, t, n) { let o = Object.keys(t); if (o.length !== Object.keys(e).length) return !0; for (let s = 0; s < o.length; s++) { let i = o[s]; if (t[i] !== e[i] && !ps(n, i)) return !0 } return !1 } function Qu({ vnode: e, parent: t }, n) { for (; t;) { let o = t.subTree; if (o.suspense && o.suspense.activeBranch === e && (o.el = e.el), o === e) (e = t.vnode).el = n, t = t.parent; else break } } var Ya = e => e.__isSuspense; function ed(e, t) { t && t.pendingBranch ? W(e) ? t.effects.push(...e) : t.effects.push(e) : ma(e) } var ae = Symbol.for("v-fgt"), go = Symbol.for("v-txt"), Ie = Symbol.for("v-cmt"), Dn = Symbol.for("v-stc"), uo = [], et = null; function S(e = !1) { uo.push(et = e ? null : []) } function td() { uo.pop(), et = uo[uo.length - 1] || null } var po = 1; function aa(e, t = !1) { po += e, e < 0 && et && t && (et.hasOnce = !0) } function qa(e) { return e.dynamicChildren = po > 0 ? et || en : null, td(), po > 0 && et && et.push(e), e } function H(e, t, n, o, s, i) { return qa(F(e, t, n, o, s, i, !0)) } function Oe(e, t, n, o, s) { return qa(oe(e, t, n, o, s, !0)) } function ho(e) { return e ? e.__v_isVNode === !0 : !1 } function ln(e, t) { return e.type === t.type && e.key === t.key } var Xa = ({ key: e }) => e ?? null, es = ({ ref: e, ref_key: t, ref_for: n }) => (typeof e == "number" && (e = "" + e), e != null ? ve(e) || be(e) || q(e) ? { i: Te, r: e, k: t, f: !!n } : e : null); function F(e, t = null, n = null, o = 0, s = null, i = e === ae ? 0 : 1, r = !1, a = !1) { let l = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && Xa(t), ref: t && es(t), scopeId: Ea, slotScopeIds: null, children: n, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: i, patchFlag: o, dynamicProps: s, dynamicChildren: null, appContext: null, ctx: Te }; return a ? (Fi(l, n), i & 128 && e.normalize(l)) : n && (l.shapeFlag |= ve(n) ? 8 : 16), po > 0 && !r && et && (l.patchFlag > 0 || i & 6) && l.patchFlag !== 32 && et.push(l), l } var oe = nd; function nd(e, t = null, n = null, o = 0, s = null, i = !1) { if ((!e || e === Da) && (e = Ie), ho(e)) { let a = Gt(e, t, !0); return n && Fi(a, n), po > 0 && !i && et && (a.shapeFlag & 6 ? et[et.indexOf(e)] = a : et.push(a)), a.patchFlag = -2, a } if (pd(e) && (e = e.__vccOpts), t) { t = od(t); let { class: a, style: l } = t; a && !ve(a) && (t.class = we(a)), de(l) && (ro(l) && !W(l) && (l = ge({}, l)), t.style = Ke(l)) } let r = ve(e) ? 1 : Ya(e) ? 128 : ba(e) ? 64 : de(e) ? 4 : q(e) ? 2 : 0; return F(e, t, n, o, s, r, i, !0) } function od(e) { return e ? ro(e) || $a(e) ? ge({}, e) : e : null } function Gt(e, t, n = !1, o = !1) { let { props: s, ref: i, patchFlag: r, children: a, transition: l } = e, u = t ? sd(s || {}, t) : s, c = { __v_isVNode: !0, __v_skip: !0, type: e.type, props: u, key: u && Xa(u), ref: t && t.ref ? n && i ? W(i) ? i.concat(es(t)) : [i, es(t)] : es(t) : i, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: a, target: e.target, targetStart: e.targetStart, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== ae ? r === -1 ? 16 : r | 16 : r, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: l, component: e.component, suspense: e.suspense, ssContent: e.ssContent && Gt(e.ssContent), ssFallback: e.ssFallback && Gt(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce }; return l && o && Kt(c, l.clone(c)), c } function Hi(e = " ", t = 0) { return oe(go, null, e, t) } function _o(e, t) { let n = oe(Dn, null, e); return n.staticCount = t, n } function Se(e = "", t = !1) { return t ? (S(), Oe(Ie, null, e)) : oe(Ie, null, e) } function Dt(e) { return e == null || typeof e == "boolean" ? oe(Ie) : W(e) ? oe(ae, null, e.slice()) : ho(e) ? Wt(e) : oe(go, null, String(e)) } function Wt(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : Gt(e) } function Fi(e, t) { let n = 0, { shapeFlag: o } = e; if (t == null) t = null; else if (W(t)) n = 16; else if (typeof t == "object") if (o & 65) { let s = t.default; s && (s._c && (s._d = !1), Fi(e, s()), s._c && (s._d = !0)); return } else { n = 32; let s = t._; !s && !$a(t) ? t._ctx = Te : s === 3 && Te && (Te.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else q(t) ? (t = { default: t, _ctx: Te }, n = 32) : (t = String(t), o & 64 ? (n = 16, t = [Hi(t)]) : n = 8); e.children = t, e.shapeFlag |= n } function sd(...e) { let t = {}; for (let n = 0; n < e.length; n++) { let o = e[n]; for (let s in o) if (s === "class") t.class !== o.class && (t.class = we([t.class, o.class])); else if (s === "style") t.style = Ke([t.style, o.style]); else if (_n(s)) { let i = t[s], r = o[s]; r && i !== r && !(W(i) && i.includes(r)) && (t[s] = i ? [].concat(i, r) : r) } else s !== "" && (t[s] = o[s]) } return t } function Tt(e, t, n, o = null) { lt(e, t, 7, [n, o]) } var id = Va(), rd = 0; function ad(e, t, n) { let o = e.type, s = (t ? t.appContext : e.appContext) || id, i = { uid: rd++, vnode: e, type: o, parent: t, appContext: s, root: null, next: null, subTree: null, effect: null, update: null, job: null, scope: new to(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(s.provides), ids: t ? t.ids : ["", 0, 0], accessCache: null, renderCache: [], components: null, directives: null, propsOptions: La(o, s), emitsOptions: za(o, s), emit: null, emitted: null, propsDefaults: ce, inheritAttrs: o.inheritAttrs, ctx: ce, data: ce, props: ce, attrs: ce, slots: ce, refs: ce, setupState: ce, setupContext: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return i.ctx = { _: i }, i.root = t ? t.root : i, i.emit = qu.bind(null, i), e.ce && e.ce(i), i } var Me = null, Ui = () => Me || Te, is, Di; { let e = Ft(), t = (n, o) => { let s; return (s = e[n]) || (s = e[n] = []), s.push(o), i => { s.length > 1 ? s.forEach(r => r(i)) : s[0](i) } }; is = t("__VUE_INSTANCE_SETTERS__", n => Me = n), Di = t("__VUE_SSR_SETTERS__", n => mo = n) } var yo = e => { let t = Me; return is(e), e.scope.on(), () => { e.scope.off(), is(t) } }, la = () => { Me && Me.scope.off(), is(null) }; function Ja(e) { return e.vnode.shapeFlag & 4 } var mo = !1; function ld(e, t = !1, n = !1) { t && Di(t); let { props: o, children: s } = e.vnode, i = Ja(e); Ru(e, o, i, t), Hu(e, s, n || t); let r = i ? cd(e, t) : void 0; return t && Di(!1), r } function cd(e, t) { var n; let o = e.type; e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, Tu); let { setup: s } = o; if (s) { Ot(); let i = e.setupContext = s.length > 1 ? dd(e) : null, r = yo(e), a = vo(s, e, 0, [e.props, i]), l = Js(a); if (xt(), r(), (l || e.sp) && !Tn(e) && Ca(e), l) { if (a.then(la, la), t) return a.then(u => { ca(e, u, t) }).catch(u => { rs(u, e, 0) }); e.asyncDep = a } else ca(e, a, t) } else Za(e, t) } function ca(e, t, n) { q(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : de(t) && (__VUE_PROD_DEVTOOLS__ && (e.devtoolsRawSetupState = t), e.setupState = Jo(t)), Za(e, n) } var ua, da; function Za(e, t, n) { let o = e.type; if (!e.render) { if (!t && ua && !o.render) { let s = o.template || __VUE_OPTIONS_API__ && $i(e).template; if (s) { let { isCustomElement: i, compilerOptions: r } = e.appContext.config, { delimiters: a, compilerOptions: l } = o, u = ge(ge({ isCustomElement: i, delimiters: a }, r), l); o.render = ua(s, u) } } e.render = o.render || Ue, da && da(e) } if (__VUE_OPTIONS_API__) { let s = yo(e); Ot(); try { Su(e) } finally { xt(), s() } } } var ud = { get(e, t) { return ke(e, "get", ""), e[t] } }; function dd(e) { let t = n => { e.exposed = n || {} }; return { attrs: new Proxy(e.attrs, ud), slots: e.slots, emit: e.emit, expose: t } } function hs(e) { return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Jo(Ze(e.exposed)), { get(t, n) { if (n in t) return t[n]; if (n in co) return co[n](e) }, has(t, n) { return n in t || n in co } })) : e.proxy } function fd(e, t = !0) { return q(e) ? e.displayName || e.name : e.name || t && e.__name } function pd(e) { return q(e) && "__vccOpts" in e } var j = (e, t) => Yr(e, t, mo); function ms(e, t, n) { let o = arguments.length; return o === 2 ? de(t) && !W(t) ? ho(t) ? oe(e, null, [t]) : oe(e, t) : oe(e, null, t) : (o > 3 ? n = Array.prototype.slice.call(arguments, 2) : o === 3 && ho(n) && (n = [n]), oe(e, t, n)) } var fa = "3.5.16"; var Gi, Qa = typeof window < "u" && window.trustedTypes; if (Qa) try { Gi = Qa.createPolicy("vue", { createHTML: e => e }) } catch { } var _l = Gi ? e => Gi.createHTML(e) : e => e, hd = "http://www.w3.org/2000/svg", md = "http://www.w3.org/1998/Math/MathML", Ht = typeof document < "u" ? document : null, el = Ht && Ht.createElement("template"), vd = { insert: (e, t, n) => { t.insertBefore(e, n || null) }, remove: e => { let t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, n, o) => { let s = t === "svg" ? Ht.createElementNS(hd, e) : t === "mathml" ? Ht.createElementNS(md, e) : n ? Ht.createElement(e, { is: n }) : Ht.createElement(e); return e === "select" && o && o.multiple != null && s.setAttribute("multiple", o.multiple), s }, createText: e => Ht.createTextNode(e), createComment: e => Ht.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => Ht.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, n, o, s, i) { let r = n ? n.previousSibling : t.lastChild; if (s && (s === i || s.nextSibling)) for (; t.insertBefore(s.cloneNode(!0), n), !(s === i || !(s = s.nextSibling));); else { el.innerHTML = _l(o === "svg" ? `<svg>${e}</svg>` : o === "mathml" ? `<math>${e}</math>` : e); let a = el.content; if (o === "svg" || o === "mathml") { let l = a.firstChild; for (; l.firstChild;)a.appendChild(l.firstChild); a.removeChild(l) } t.insertBefore(a, n) } return [r ? r.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild] } }, qt = "transition", Eo = "animation", $n = Symbol("_vtc"), yl = { name: String, type: String, css: { type: Boolean, default: !0 }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }, El = ge({}, Vi, yl), gd = e => (e.displayName = "Transition", e.props = El, e), ys = gd((e, { slots: t }) => ms(Oa, bl(e), t)), un = (e, t = []) => { W(e) ? e.forEach(n => n(...t)) : e && e(...t) }, tl = e => e ? W(e) ? e.some(t => t.length > 1) : e.length > 1 : !1; function bl(e) { let t = {}; for (let L in e) L in yl || (t[L] = e[L]); if (e.css === !1) return t; let { name: n = "v", type: o, duration: s, enterFromClass: i = `${n}-enter-from`, enterActiveClass: r = `${n}-enter-active`, enterToClass: a = `${n}-enter-to`, appearFromClass: l = i, appearActiveClass: u = r, appearToClass: c = a, leaveFromClass: d = `${n}-leave-from`, leaveActiveClass: p = `${n}-leave-active`, leaveToClass: h = `${n}-leave-to` } = e, v = _d(s), b = v && v[0], y = v && v[1], { onBeforeEnter: E, onEnter: N, onEnterCancelled: k, onLeave: G, onLeaveCancelled: C, onBeforeAppear: D = E, onAppear: z = N, onAppearCancelled: P = k } = t, _ = (L, le, A, Z) => { L._enterCancelled = Z, Xt(L, le ? c : a), Xt(L, le ? u : r), A && A() }, M = (L, le) => { L._isLeaving = !1, Xt(L, d), Xt(L, h), Xt(L, p), le && le() }, Y = L => (le, A) => { let Z = L ? z : N, J = () => _(le, L, A); un(Z, [le, J]), nl(() => { Xt(le, L ? l : i), It(le, L ? c : a), tl(Z) || ol(le, o, b, J) }) }; return ge(t, { onBeforeEnter(L) { un(E, [L]), It(L, i), It(L, r) }, onBeforeAppear(L) { un(D, [L]), It(L, l), It(L, u) }, onEnter: Y(!1), onAppear: Y(!0), onLeave(L, le) { L._isLeaving = !0; let A = () => M(L, le); It(L, d), L._enterCancelled ? (It(L, p), zi()) : (zi(), It(L, p)), nl(() => { L._isLeaving && (Xt(L, d), It(L, h), tl(G) || ol(L, o, y, A)) }), un(G, [L, A]) }, onEnterCancelled(L) { _(L, !1, void 0, !0), un(k, [L]) }, onAppearCancelled(L) { _(L, !0, void 0, !0), un(P, [L]) }, onLeaveCancelled(L) { M(L), un(C, [L]) } }) } function _d(e) { if (e == null) return null; if (de(e)) return [Bi(e.enter), Bi(e.leave)]; { let t = Bi(e); return [t, t] } } function Bi(e) { return Qs(e) } function It(e, t) { t.split(/\s+/).forEach(n => n && e.classList.add(n)), (e[$n] || (e[$n] = new Set)).add(t) } function Xt(e, t) { t.split(/\s+/).forEach(o => o && e.classList.remove(o)); let n = e[$n]; n && (n.delete(t), n.size || (e[$n] = void 0)) } function nl(e) { requestAnimationFrame(() => { requestAnimationFrame(e) }) } var yd = 0; function ol(e, t, n, o) { let s = e._endId = ++yd, i = () => { s === e._endId && o() }; if (n != null) return setTimeout(i, n); let { type: r, timeout: a, propCount: l } = Nl(e, t); if (!r) return o(); let u = r + "end", c = 0, d = () => { e.removeEventListener(u, p), i() }, p = h => { h.target === e && ++c >= l && d() }; setTimeout(() => { c < l && d() }, a + 1), e.addEventListener(u, p) } function Nl(e, t) { let n = window.getComputedStyle(e), o = v => (n[v] || "").split(", "), s = o(`${qt}Delay`), i = o(`${qt}Duration`), r = sl(s, i), a = o(`${Eo}Delay`), l = o(`${Eo}Duration`), u = sl(a, l), c = null, d = 0, p = 0; t === qt ? r > 0 && (c = qt, d = r, p = i.length) : t === Eo ? u > 0 && (c = Eo, d = u, p = l.length) : (d = Math.max(r, u), c = d > 0 ? r > u ? qt : Eo : null, p = c ? c === qt ? i.length : l.length : 0); let h = c === qt && /\b(transform|all)(,|$)/.test(o(`${qt}Property`).toString()); return { type: c, timeout: d, propCount: p, hasTransform: h } } function sl(e, t) { for (; e.length < t.length;)e = e.concat(e); return Math.max(...t.map((n, o) => il(n) + il(e[o]))) } function il(e) { return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3 } function zi() { return document.body.offsetHeight } function Ed(e, t, n) { let o = e[$n]; o && (t = (t ? [t, ...o] : [...o]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t } var gs = Symbol("_vod"), wl = Symbol("_vsh"), Yi = { beforeMount(e, { value: t }, { transition: n }) { e[gs] = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : bo(e, t) }, mounted(e, { value: t }, { transition: n }) { n && t && n.enter(e) }, updated(e, { value: t, oldValue: n }, { transition: o }) { !t != !n && (o ? t ? (o.beforeEnter(e), bo(e, !0), o.enter(e)) : o.leave(e, () => { bo(e, !1) }) : bo(e, t)) }, beforeUnmount(e, { value: t }) { bo(e, t) } }; function bo(e, t) { e.style.display = t ? e[gs] : "none", e[wl] = !t } var bd = Symbol(""); var Nd = /(^|;)\s*display\s*:/; function wd(e, t, n) { let o = e.style, s = ve(n), i = !1; if (n && !s) { if (t) if (ve(t)) for (let r of t.split(";")) { let a = r.slice(0, r.indexOf(":")).trim(); n[a] == null && vs(o, a, "") } else for (let r in t) n[r] == null && vs(o, r, ""); for (let r in n) r === "display" && (i = !0), vs(o, r, n[r]) } else if (s) { if (t !== n) { let r = o[bd]; r && (n += ";" + r), o.cssText = n, i = Nd.test(n) } } else t && e.removeAttribute("style"); gs in e && (e[gs] = i ? o.display : "", e[wl] && (o.display = "none")) } var rl = /\s*!important$/; function vs(e, t, n) { if (W(n)) n.forEach(o => vs(e, t, o)); else if (n == null && (n = ""), t.startsWith("--")) e.setProperty(t, n); else { let o = Od(e, t); rl.test(n) ? e.setProperty(yt(o), n.replace(rl, ""), "important") : e[o] = n } } var al = ["Webkit", "Moz", "ms"], ji = {}; function Od(e, t) { let n = ji[t]; if (n) return n; let o = $e(t); if (o !== "filter" && o in e) return ji[t] = o; o = nn(o); for (let s = 0; s < al.length; s++) { let i = al[s] + o; if (i in e) return ji[t] = i } return t } var ll = "http://www.w3.org/1999/xlink"; function cl(e, t, n, o, s, i = Dr(t)) { o && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(ll, t.slice(6, t.length)) : e.setAttributeNS(ll, t, n) : n == null || i && !Lo(n) ? e.removeAttribute(t) : e.setAttribute(t, i ? "" : rt(n) ? String(n) : n) } function ul(e, t, n, o, s) { if (t === "innerHTML" || t === "textContent") { n != null && (e[t] = t === "innerHTML" ? _l(n) : n); return } let i = e.tagName; if (t === "value" && i !== "PROGRESS" && !i.includes("-")) { let a = i === "OPTION" ? e.getAttribute("value") || "" : e.value, l = n == null ? e.type === "checkbox" ? "on" : "" : String(n); (a !== l || !("_value" in e)) && (e.value = l), n == null && e.removeAttribute(t), e._value = n; return } let r = !1; if (n === "" || n == null) { let a = typeof e[t]; a === "boolean" ? n = Lo(n) : n == null && a === "string" ? (n = "", r = !0) : a === "number" && (n = 0, r = !0) } try { e[t] = n } catch { } r && e.removeAttribute(s || t) } function Rn(e, t, n, o) { e.addEventListener(t, n, o) } function xd(e, t, n, o) { e.removeEventListener(t, n, o) } var dl = Symbol("_vei"); function Cd(e, t, n, o, s = null) { let i = e[dl] || (e[dl] = {}), r = i[t]; if (o && r) r.value = o; else { let [a, l] = Td(t); if (o) { let u = i[t] = kd(o, s); Rn(e, a, u, l) } else r && (xd(e, a, r, l), i[t] = void 0) } } var fl = /(?:Once|Passive|Capture)$/; function Td(e) { let t; if (fl.test(e)) { t = {}; let o; for (; o = e.match(fl);)e = e.slice(0, e.length - o[0].length), t[o[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : yt(e.slice(2)), t] } var Wi = 0, Sd = Promise.resolve(), Dd = () => Wi || (Sd.then(() => Wi = 0), Wi = Date.now()); function kd(e, t) { let n = o => { if (!o._vts) o._vts = Date.now(); else if (o._vts <= n.attached) return; lt(Id(o, n.value), t, 5, [o]) }; return n.value = e, n.attached = Dd(), n } function Id(e, t) { if (W(t)) { let n = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { n.call(e), e._stopped = !0 }, t.map(o => s => !s._stopped && o && o(s)) } else return t } var pl = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, Md = (e, t, n, o, s, i) => { let r = s === "svg"; t === "class" ? Ed(e, o, r) : t === "style" ? wd(e, n, o) : _n(t) ? Yn(t) || Cd(e, t, n, o, i) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : Vd(e, t, o, r)) ? (ul(e, t, o), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && cl(e, t, o, r, i, t !== "value")) : e._isVueCE && (/[A-Z]/.test(t) || !ve(o)) ? ul(e, $e(t), o, i, t) : (t === "true-value" ? e._trueValue = o : t === "false-value" && (e._falseValue = o), cl(e, t, o, r)) }; function Vd(e, t, n, o) { if (o) return !!(t === "innerHTML" || t === "textContent" || t in e && pl(t) && q(n)); if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1; if (t === "width" || t === "height") { let s = e.tagName; if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE") return !1 } return pl(t) && ve(n) ? !1 : t in e } var Ol = new WeakMap, xl = new WeakMap, _s = Symbol("_moveCb"), hl = Symbol("_enterCb"), Ad = e => (delete e.props.mode, e), Rd = Ad({ name: "TransitionGroup", props: ge({}, El, { tag: String, moveClass: String }), setup(e, { slots: t }) { let n = Ui(), o = Mi(), s, i; return Vn(() => { if (!s.length) return; let r = e.moveClass || `${e.name || "v"}-move`; if (!Hd(s[0].el, n.vnode.el, r)) { s = []; return } s.forEach($d), s.forEach(Pd); let a = s.filter(Ld); zi(), a.forEach(l => { let u = l.el, c = u.style; It(u, r), c.transform = c.webkitTransform = c.transitionDuration = ""; let d = u[_s] = p => { p && p.target !== u || (!p || /transform$/.test(p.propertyName)) && (u.removeEventListener("transitionend", d), u[_s] = null, Xt(u, r)) }; u.addEventListener("transitionend", d) }), s = [] }), () => { let r = ne(e), a = bl(r), l = r.tag || ae; if (s = [], i) for (let u = 0; u < i.length; u++) { let c = i[u]; c.el && c.el instanceof Element && (s.push(c), Kt(c, kn(c, a, o, n)), Ol.set(c, c.el.getBoundingClientRect())) } i = t.default ? ls(t.default()) : []; for (let u = 0; u < i.length; u++) { let c = i[u]; c.key != null && Kt(c, kn(c, a, o, n)) } return oe(l, null, i) } } }), Cl = Rd; function $d(e) { let t = e.el; t[_s] && t[_s](), t[hl] && t[hl]() } function Pd(e) { xl.set(e, e.el.getBoundingClientRect()) } function Ld(e) { let t = Ol.get(e), n = xl.get(e), o = t.left - n.left, s = t.top - n.top; if (o || s) { let i = e.el.style; return i.transform = i.webkitTransform = `translate(${o}px,${s}px)`, i.transitionDuration = "0s", e } } function Hd(e, t, n) { let o = e.cloneNode(), s = e[$n]; s && s.forEach(a => { a.split(/\s+/).forEach(l => l && o.classList.remove(l)) }), n.split(/\s+/).forEach(a => a && o.classList.add(a)), o.style.display = "none"; let i = t.nodeType === 1 ? t : t.parentNode; i.appendChild(o); let { hasTransform: r } = Nl(o); return i.removeChild(o), r } var ml = e => { let t = e.props["onUpdate:modelValue"] || !1; return W(t) ? n => En(t, n) : t }; function Fd(e) { e.target.composing = !0 } function vl(e) { let t = e.target; t.composing && (t.composing = !1, t.dispatchEvent(new Event("input"))) } var Ki = Symbol("_assign"), dn = { created(e, { modifiers: { lazy: t, trim: n, number: o } }, s) { e[Ki] = ml(s); let i = o || s.props && s.props.type === "number"; Rn(e, t ? "change" : "input", r => { if (r.target.composing) return; let a = e.value; n && (a = a.trim()), i && (a = Jn(a)), e[Ki](a) }), n && Rn(e, "change", () => { e.value = e.value.trim() }), t || (Rn(e, "compositionstart", Fd), Rn(e, "compositionend", vl), Rn(e, "change", vl)) }, mounted(e, { value: t }) { e.value = t ?? "" }, beforeUpdate(e, { value: t, oldValue: n, modifiers: { lazy: o, trim: s, number: i } }, r) { if (e[Ki] = ml(r), e.composing) return; let a = (i || e.type === "number") && !/^0\d/.test(e.value) ? Jn(e.value) : e.value, l = t ?? ""; a !== l && (document.activeElement === e && e.type !== "range" && (o && t === n || s && e.value.trim() === l) || (e.value = l)) } }; var Ud = ["ctrl", "shift", "alt", "meta"], Bd = { stop: e => e.stopPropagation(), prevent: e => e.preventDefault(), self: e => e.target !== e.currentTarget, ctrl: e => !e.ctrlKey, shift: e => !e.shiftKey, alt: e => !e.altKey, meta: e => !e.metaKey, left: e => "button" in e && e.button !== 0, middle: e => "button" in e && e.button !== 1, right: e => "button" in e && e.button !== 2, exact: (e, t) => Ud.some(n => e[`${n}Key`] && !t.includes(n)) }, He = (e, t) => { let n = e._withMods || (e._withMods = {}), o = t.join("."); return n[o] || (n[o] = (s, ...i) => { for (let r = 0; r < t.length; r++) { let a = Bd[t[r]]; if (a && a(s, t)) return } return e(s, ...i) }) }, jd = { esc: "escape", space: " ", up: "arrow-up", left: "arrow-left", right: "arrow-right", down: "arrow-down", delete: "backspace" }, Pn = (e, t) => { let n = e._withKeys || (e._withKeys = {}), o = t.join("."); return n[o] || (n[o] = s => { if (!("key" in s)) return; let i = yt(s.key); if (t.some(r => r === i || jd[r] === i)) return e(s) }) }, Wd = ge({ patchProp: Md }, vd), gl; function Kd() { return gl || (gl = Ba(Wd)) } var Tl = (...e) => { let t = Kd().createApp(...e), { mount: n } = t; return t.mount = o => { let s = zd(o); if (!s) return; let i = t._component; !q(i) && !i.render && !i.template && (i.template = s.innerHTML), s.nodeType === 1 && (s.textContent = ""); let r = n(s, !1, Gd(s)); return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), r }, t }; function Gd(e) { if (e instanceof SVGElement) return "svg"; if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml" } function zd(e) { return ve(e) ? document.querySelector(e) : e } var Yd = ["INPUT", "TEXTAREA", "SELECT"]; function lr(e) { return Yd.includes(e.tagName) } function qd(e) { return e.position } function Xd(e, t, n) { e.position.x = t, e.position.y = n } var Ji = null; function Al(e) { Ji = e } function Ye() { if (!Ji) throw new Error("providePlugin() must be called before usePlugin()"); return { viewModel: Ji } } function nt() { let { viewModel: e } = Ye(); return { graph: $t(e.value, "displayedGraph"), switchGraph: e.value.switchGraph } } function cr(e) { let { graph: t } = nt(), n = U(null), o = U(null); return { dragging: j(() => !!n.value), onPointerDown: l => { n.value = { x: l.pageX, y: l.pageY }, o.value = { x: e.value.x, y: e.value.y } }, onPointerMove: l => { if (n.value) { let u = l.pageX - n.value.x, c = l.pageY - n.value.y; e.value.x = o.value.x + u / t.value.scaling, e.value.y = o.value.y + c / t.value.scaling } }, onPointerUp: () => { n.value = null, o.value = null } } } function Rl(e, t, n) { if (!t.template) return !1; if (_t(t.template) === n) return !0; let o = e.graphTemplates.find(i => _t(i) === n); return o ? o.nodes.filter(i => i.type.startsWith(Zt)).some(i => Rl(e, t, i.type)) : !1 } function ur(e) { return j(() => { let t = Array.from(e.value.editor.nodeTypes.entries()), n = new Set(t.map(([, s]) => s.category)), o = []; for (let s of n.values()) { let i = t.filter(([, r]) => r.category === s); e.value.displayedGraph.template ? i = i.filter(([r]) => !Rl(e.value.editor, e.value.displayedGraph, r)) : i = i.filter(([r]) => ![vt, gt].includes(r)), i.length > 0 && o.push({ name: s, nodeTypes: Object.fromEntries(i) }) } return o.sort((s, i) => s.name === "default" ? -1 : i.name === "default" || s.name > i.name ? 1 : -1), o }) } function dr() { let { graph: e } = nt(); return { transform: (n, o) => { let s = n / e.value.scaling - e.value.panning.x, i = o / e.value.scaling - e.value.panning.y; return [s, i] } } } function Jd() { let { graph: e } = nt(), t = [], n = -1, o = { x: 0, y: 0 }, s = j(() => e.value.panning), i = cr(s), r = j(() => ({ "transform-origin": "0 0", transform: `scale(${e.value.scaling}) translate(${e.value.panning.x}px, ${e.value.panning.y}px)` })), a = (h, v, b) => { let y = [h / e.value.scaling - e.value.panning.x, v / e.value.scaling - e.value.panning.y], E = [h / b - e.value.panning.x, v / b - e.value.panning.y], N = [E[0] - y[0], E[1] - y[1]]; e.value.panning.x += N[0], e.value.panning.y += N[1], e.value.scaling = b }, l = h => { h.preventDefault(); let v = h.deltaY; h.deltaMode === 1 && (v *= 32); let b = e.value.scaling * (1 - v / 3e3); a(h.offsetX, h.offsetY, b) }, u = () => ({ ax: t[0].clientX, ay: t[0].clientY, bx: t[1].clientX, by: t[1].clientY }); return { styles: r, ...i, onPointerDown: h => { if (t.push(h), i.onPointerDown(h), t.length === 2) { let { ax: v, ay: b, bx: y, by: E } = u(); o = { x: v + (y - v) / 2, y: b + (E - b) / 2 } } }, onPointerMove: h => { for (let v = 0; v < t.length; v++)if (h.pointerId == t[v].pointerId) { t[v] = h; break } if (t.length == 2) { let { ax: v, ay: b, bx: y, by: E } = u(), N = v - y, k = b - E, G = Math.sqrt(N * N + k * k); if (n > 0) { let C = e.value.scaling * (1 + (G - n) / 500); a(o.x, o.y, C) } n = G } else i.onPointerMove(h) }, onPointerUp: h => { t = t.filter(v => v.pointerId !== h.pointerId), n = -1, i.onPointerUp() }, onMouseWheel: l } } var tt = (e => (e[e.NONE = 0] = "NONE", e[e.ALLOWED = 1] = "ALLOWED", e[e.FORBIDDEN = 2] = "FORBIDDEN", e))(tt || {}), $l = Symbol(); function Pl() { let { graph: e } = nt(), t = U(null), n = U(null), o = a => { t.value && (t.value.mx = a.offsetX / e.value.scaling - e.value.panning.x, t.value.my = a.offsetY / e.value.scaling - e.value.panning.y) }, s = () => { if (n.value) { if (t.value) return; let a = e.value.connections.find(l => l.to === n.value); n.value.isInput && a ? (t.value = { status: tt.NONE, from: a.from }, e.value.removeConnection(a)) : t.value = { status: tt.NONE, from: n.value }, t.value.mx = void 0, t.value.my = void 0 } }, i = () => { if (t.value && n.value) { if (t.value.from === n.value) return; e.value.addConnection(t.value.from, t.value.to) } t.value = null }, r = a => { if (n.value = a ?? null, a && t.value) { t.value.to = a; let l = e.value.checkConnection(t.value.from, t.value.to); if (t.value.status = l.connectionAllowed ? tt.ALLOWED : tt.FORBIDDEN, l.connectionAllowed) { let u = l.connectionsInDanger.map(c => c.id); e.value.connections.forEach(c => { u.includes(c.id) && (c.isInDanger = !0) }) } } else !a && t.value && (t.value.to = void 0, t.value.status = tt.NONE, e.value.connections.forEach(l => { l.isInDanger = !1 })) }; return fs($l, { temporaryConnection: t, hoveredOver: r }), { temporaryConnection: t, onMouseMove: o, onMouseDown: s, onMouseUp: i, hoveredOver: r } } function Ll() { let e = cn($l); if (!e) throw new Error("useTemporaryConnection must be used within a BaklavaEditor"); return e } function Zd(e) { let t = U(!1), n = U(0), o = U(0), s = ur(e), { transform: i } = dr(), r = j(() => { let c = [], d = {}; for (let h of s.value) { let v = Object.entries(h.nodeTypes).map(([b, y]) => ({ label: y.title, value: "addNode:" + b })); h.name === "default" ? c = v : d[h.name] = v } let p = [...Object.entries(d).map(([h, v]) => ({ label: h, submenu: v }))]; return p.length > 0 && c.length > 0 && p.push({ isDivider: !0 }), p.push(...c), p }), a = j(() => e.value.settings.contextMenu.additionalItems.length === 0 ? r.value : [{ label: "Add node", submenu: r.value }, ...e.value.settings.contextMenu.additionalItems.map(c => "isDivider" in c || "submenu" in c ? c : { label: c.label, value: "command:" + c.command, disabled: !e.value.commandHandler.canExecuteCommand(c.command) })]); function l(c) { let d = c.target; if (!(d instanceof Element) || lr(d)) return; c.preventDefault(), t.value = !0; let p = d.getBoundingClientRect(), v = d.closest(".baklava-editor").getBoundingClientRect(); n.value = p.x + c.offsetX - v.x, o.value = p.y + c.offsetY - v.y } function u(c) { if (c.startsWith("addNode:")) { let d = c.substring(8), p = e.value.editor.nodeTypes.get(d); if (!p) return; let h = Le(new p.type); e.value.displayedGraph.addNode(h); let [v, b] = i(n.value, o.value); h.position.x = v, h.position.y = b } else if (c.startsWith("command:")) { let d = c.substring(8); e.value.commandHandler.canExecuteCommand(d) && e.value.commandHandler.executeCommand(d) } } return { show: t, x: n, y: o, items: a, open: l, onClick: u } } var wo = "START_SELECTION_BOX"; function Qd(e) { let { viewModel: t } = Ye(), { graph: n } = nt(), o = j(() => n.value.nodes), s = U(!1), i = U(!1), r = U([0, 0]), a = U([0, 0]); ze(t, () => { t.value.commandHandler.hasCommand(wo) || (t.value.commandHandler.registerCommand(wo, { canExecute: () => !0, execute() { s.value = !0 } }), t.value.commandHandler.registerHotkey(["b"], wo)) }, { immediate: !0 }); function l(E) { return [E.clientX - e.value.getBoundingClientRect().left, E.clientY - e.value.getBoundingClientRect().top] } function u(E) { return s.value ? (i.value = !0, s.value = !1, r.value = l(E), a.value = l(E), document.addEventListener("pointermove", c), document.addEventListener("pointerup", d), !0) : !1 } function c(E) { r.value = l(E) } function d(E) { document.removeEventListener("pointermove", c), document.removeEventListener("pointerup", d), r.value = l(E), i.value = !1; let N = p(); for (let k of N) t.value.displayedGraph.selectedNodes.push(k) } function p() { let E = h(), k = document.querySelector(".baklava-editor").getBoundingClientRect(); return o.value.filter(G => { let C = v(G, k); return b(E, C) }) } function h() { return { left: Math.min(r.value[0], a.value[0]), top: Math.min(r.value[1], a.value[1]), right: Math.max(r.value[0], a.value[0]), bottom: Math.max(r.value[1], a.value[1]) } } function v(E, N) { let k = document.getElementById(E.id), G = k ? k.getBoundingClientRect() : { x: 0, y: 0, width: 0, height: 0 }, C = G.x - N.left, D = G.y - N.top; return { left: C, top: D, right: C + G.width, bottom: D + G.height } } function b(E, N) { return E.left < N.right && E.right > N.left && E.top < N.bottom && E.bottom > N.top } function y() { return { width: Math.abs(a.value[0] - r.value[0]) + "px", height: Math.abs(a.value[1] - r.value[1]) + "px", left: (a.value[0] > r.value[0] ? r.value[0] : a.value[0]) + "px", top: (a.value[1] > r.value[1] ? r.value[1] : a.value[1]) + "px" } } return Le({ startSelection: s, isSelecting: i, start: r, end: a, onPointerDown: u, getStyles: y }) } var ef = me({ setup() { let { viewModel: e } = Ye(), { graph: t } = nt(); return { styles: j(() => { let o = e.value.settings.background, s = t.value.panning.x * t.value.scaling, i = t.value.panning.y * t.value.scaling, r = t.value.scaling * o.gridSize, a = r / o.gridDivision, l = `${r}px ${r}px, ${r}px ${r}px`, u = t.value.scaling > o.subGridVisibleThreshold ? `, ${a}px ${a}px, ${a}px ${a}px` : ""; return { backgroundPosition: `left ${s}px top ${i}px`, backgroundSize: `${l} ${u}` } }) } } }), he = (e, t) => { let n = e.__vccOpts || e; for (let [o, s] of t) n[o] = s; return n }; function tf(e, t, n, o, s, i) { return S(), H("div", { class: "background", style: Ke(e.styles) }, null, 4) } var nf = he(ef, [["render", tf]]); function of(e) { return zo() ? (fi(e), !0) : !1 } var Hl = typeof window < "u" && typeof document < "u"; typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope; var sf = Object.prototype.toString, rf = e => sf.call(e) === "[object Object]", Ln = () => { }, af = lf(); function lf() { var e, t; return Hl && ((e = window?.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window?.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent)) } function cf(e, t, n = !1) { return t.reduce((o, s) => (s in e && (!n || e[s] !== void 0) && (o[s] = e[s]), o), {}) } function qi(e) { return Array.isArray(e) ? e : [e] } function uf(e, t = {}) { if (!be(e)) return yi(e); let n = Array.isArray(e.value) ? Array.from({ length: e.value.length }) : {}; for (let o in e.value) n[o] = Zo(() => ({ get() { return e.value[o] }, set(s) { var i; if ((i = Ct(t.replaceRef)) != null ? i : !0) if (Array.isArray(e.value)) { let a = [...e.value]; a[o] = s, e.value = a } else { let a = { ...e.value, [o]: s }; Object.setPrototypeOf(a, Object.getPrototypeOf(e.value)), e.value = a } else e.value[o] = s } })); return n } function df(e, t, n) { return ze(e, t, { ...n, immediate: !0 }) } var fr = Hl ? window : void 0; function No(e) { var t; let n = Ct(e); return (t = n?.$el) != null ? t : n } function Oo(...e) { let t = [], n = () => { t.forEach(a => a()), t.length = 0 }, o = (a, l, u, c) => (a.addEventListener(l, u, c), () => a.removeEventListener(l, u, c)), s = j(() => { let a = qi(Ct(e[0])).filter(l => l != null); return a.every(l => typeof l != "string") ? a : void 0 }), i = df(() => { var a, l; return [(l = (a = s.value) == null ? void 0 : a.map(u => No(u))) != null ? l : [fr].filter(u => u != null), qi(Ct(s.value ? e[1] : e[0])), qi(Q(s.value ? e[2] : e[1])), Ct(s.value ? e[3] : e[2])] }, ([a, l, u, c]) => { if (n(), !a?.length || !l?.length || !u?.length) return; let d = rf(c) ? { ...c } : c; t.push(...a.flatMap(p => l.flatMap(h => u.map(v => o(p, h, v, d))))) }, { flush: "post" }), r = () => { i(), n() }; return of(n), r } var Sl = !1; function Fl(e, t, n = {}) { let { window: o = fr, ignore: s = [], capture: i = !0, detectIframe: r = !1, controls: a = !1 } = n; if (!o) return a ? { stop: Ln, cancel: Ln, trigger: Ln } : Ln; if (af && !Sl) { Sl = !0; let y = { passive: !0 }; Array.from(o.document.body.children).forEach(E => E.addEventListener("click", Ln, y)), o.document.documentElement.addEventListener("click", Ln, y) } let l = !0, u = y => Ct(s).some(E => { if (typeof E == "string") return Array.from(o.document.querySelectorAll(E)).some(N => N === y.target || y.composedPath().includes(N)); { let N = No(E); return N && (y.target === N || y.composedPath().includes(N)) } }); function c(y) { let E = Ct(y); return E && E.$.subTree.shapeFlag === 16 } function d(y, E) { let N = Ct(y), k = N.$.subTree && N.$.subTree.children; return k == null || !Array.isArray(k) ? !1 : k.some(G => G.el === E.target || E.composedPath().includes(G.el)) } let p = y => { let E = No(e); if (y.target != null && !(!(E instanceof Element) && c(e) && d(e, y)) && !(!E || E === y.target || y.composedPath().includes(E))) { if ("detail" in y && y.detail === 0 && (l = !u(y)), !l) { l = !0; return } t(y) } }, h = !1, v = [Oo(o, "click", y => { h || (h = !0, setTimeout(() => { h = !1 }, 0), p(y)) }, { passive: !0, capture: i }), Oo(o, "pointerdown", y => { let E = No(e); l = !u(y) && !!(E && !y.composedPath().includes(E)) }, { passive: !0 }), r && Oo(o, "blur", y => { setTimeout(() => { var E; let N = No(e); ((E = o.document.activeElement) == null ? void 0 : E.tagName) === "IFRAME" && !N?.contains(o.document.activeElement) && t(y) }, 0) }, { passive: !0 })].filter(Boolean), b = () => v.forEach(y => y()); return a ? { stop: b, cancel: () => { l = !1 }, trigger: y => { l = !0, p(y), l = !1 } } : b } var Ul = { x: 0, y: 0, pointerId: 0, pressure: 0, tiltX: 0, tiltY: 0, width: 0, height: 0, twist: 0, pointerType: null }, ff = Object.keys(Ul); function pf(e = {}) { let { target: t = fr } = e, n = Xo(!1), o = U(e.initialValue || {}); Object.assign(o.value, Ul, o.value); let s = i => { n.value = !0, !(e.pointerTypes && !e.pointerTypes.includes(i.pointerType)) && (o.value = cf(i, ff, !1)) }; if (t) { let i = { passive: !0 }; Oo(t, ["pointerdown", "pointermove", "pointerup"], s, i), Oo(t, "pointerleave", () => n.value = !1, i) } return { ...uf(o), isInside: n } } var hf = ["onMouseenter", "onMouseleave", "onClick"], mf = { class: "flex-fill" }, vf = { key: 0, class: "__submenu-icon", style: { "line-height": "1em" } }, Ms = me({ __name: "ContextMenu", props: { modelValue: { type: Boolean }, items: {}, x: { default: 0 }, y: { default: 0 }, isNested: { type: Boolean, default: !1 }, isFlipped: { default: () => ({ x: !1, y: !1 }) }, flippable: { type: Boolean, default: !1 } }, emits: ["update:modelValue", "click"], setup(e, { emit: t }) { let n = e, o = t, s = null, i = U(null), r = U(-1), a = U(0), l = U({ x: !1, y: !1 }), u = j(() => n.flippable && (l.value.x || n.isFlipped.x)), c = j(() => n.flippable && (l.value.y || n.isFlipped.y)), d = j(() => { let N = {}; return n.isNested || (N.top = (c.value ? n.y - a.value : n.y) + "px", N.left = n.x + "px"), N }), p = j(() => ({ "--flipped-x": u.value, "--flipped-y": c.value, "--nested": n.isNested })), h = j(() => n.items.map(N => ({ ...N, hover: !1 }))); ze([() => n.y, () => n.items], () => { var N, k, G, C; a.value = n.items.length * 30; let D = ((k = (N = i.value) == null ? void 0 : N.parentElement) == null ? void 0 : k.offsetWidth) ?? 0, z = ((C = (G = i.value) == null ? void 0 : G.parentElement) == null ? void 0 : C.offsetHeight) ?? 0; l.value.x = !n.isNested && n.x > D * .75, l.value.y = !n.isNested && n.y + a.value > z - 20 }), Fl(i, () => { n.modelValue && o("update:modelValue", !1) }); let v = N => { !N.submenu && N.value && (o("click", N.value), o("update:modelValue", !1)) }, b = N => { o("click", N), r.value = -1, n.isNested || o("update:modelValue", !1) }, y = (N, k) => { n.items[k].submenu && (r.value = k, s !== null && (clearTimeout(s), s = null)) }, E = (N, k) => { n.items[k].submenu && (s = window.setTimeout(() => { r.value = -1, s = null }, 200)) }; return (N, k) => { let G = Yt("ContextMenu", !0); return S(), Oe(ys, { name: "slide-fade" }, { default: Mn(() => [Pt(F("div", { ref_key: "el", ref: i, class: we(["baklava-context-menu", p.value]), style: Ke(d.value) }, [(S(!0), H(ae, null, ct(h.value, (C, D) => (S(), H(ae, null, [C.isDivider ? (S(), H("div", { key: `d-${D}`, class: "divider" })) : (S(), H("div", { key: `i-${D}`, class: we(["item", { submenu: !!C.submenu, "--disabled": !!C.disabled }]), onMouseenter: z => y(z, D), onMouseleave: z => E(z, D), onClick: He(z => v(C), ["stop", "prevent"]) }, [F("div", mf, Ee(C.label), 1), C.submenu ? (S(), H("div", vf, k[0] || (k[0] = [F("svg", { width: "13", height: "13", viewBox: "-60 120 250 250" }, [F("path", { d: "M160.875 279.5625 L70.875 369.5625 L70.875 189.5625 L160.875 279.5625 Z", stroke: "none", fill: "white" })], -1)]))) : Se("", !0), C.submenu ? (S(), Oe(G, { key: 1, "model-value": r.value === D, items: C.submenu, "is-nested": !0, "is-flipped": { x: u.value, y: c.value }, flippable: N.flippable, onClick: b }, null, 8, ["model-value", "items", "is-flipped", "flippable"])) : Se("", !0)], 42, hf))], 64))), 256))], 6), [[Yi, N.modelValue]])]), _: 1 }) } } }), gf = {}, _f = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "16", height: "16", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function yf(e, t) { return S(), H("svg", _f, t[0] || (t[0] = [F("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, null, -1), F("circle", { cx: "12", cy: "12", r: "1" }, null, -1), F("circle", { cx: "12", cy: "19", r: "1" }, null, -1), F("circle", { cx: "12", cy: "5", r: "1" }, null, -1)])) } var Bl = he(gf, [["render", yf]]), Ef = ["id"], bf = { key: 0, class: "__tooltip" }, Nf = { key: 2, class: "align-middle" }, Zi = me({ __name: "NodeInterface", props: { node: {}, intf: {} }, setup(e) { let t = (y, E = 100) => { let N = typeof y?.toString == "function" ? String(y) : ""; return N.length > E ? N.slice(0, E) + "..." : N }, n = e, { viewModel: o } = Ye(), { hoveredOver: s, temporaryConnection: i } = Ll(), r = U(null), a = j(() => n.intf.connectionCount > 0), l = U(!1), u = j(() => o.value.settings.displayValueOnHover && l.value), c = j(() => ({ "--input": n.intf.isInput, "--output": !n.intf.isInput, "--connected": a.value })), d = j(() => n.intf.component && (!n.intf.isInput || !n.intf.port || n.intf.connectionCount === 0)), p = () => { l.value = !0, s(n.intf) }, h = () => { l.value = !1, s(void 0) }, v = () => { r.value && o.value.hooks.renderInterface.execute({ intf: n.intf, el: r.value }) }, b = () => { let y = o.value.displayedGraph.sidebar; y.nodeId = n.node.id, y.optionName = n.intf.name, y.visible = !0 }; return zt(v), Vn(v), (y, E) => { var N; return S(), H("div", { id: y.intf.id, ref_key: "el", ref: r, class: we(["baklava-node-interface", c.value]) }, [y.intf.port ? (S(), H("div", { key: 0, class: we(["__port", { "--selected": ((N = Q(i)) == null ? void 0 : N.from) === y.intf }]), onPointerover: p, onPointerout: h }, [We(y.$slots, "portTooltip", { showTooltip: u.value }, () => [u.value === !0 ? (S(), H("span", bf, Ee(t(y.intf.value)), 1)) : Se("", !0)])], 34)) : Se("", !0), d.value ? (S(), Oe(ds(y.intf.component), { key: 1, modelValue: y.intf.value, "onUpdate:modelValue": E[0] || (E[0] = k => y.intf.value = k), node: y.node, intf: y.intf, onOpenSidebar: b }, null, 40, ["modelValue", "node", "intf"])) : (S(), H("span", Nf, Ee(y.intf.name), 1))], 10, Ef) } } }), wf = ["id", "data-node-type"], Of = { class: "__title-label" }, xf = { class: "__menu" }, Cf = { class: "__outputs" }, Tf = { class: "__inputs" }, jl = me({ __name: "Node", props: { node: {}, selected: { type: Boolean, default: !1 }, dragging: { type: Boolean } }, emits: ["select", "start-drag"], setup(e, { emit: t }) { let n = e, o = t, { viewModel: s } = Ye(), { graph: i, switchGraph: r } = nt(), a = U(null), l = U(!1), u = U(""), c = U(null), d = U(!1), p = 0, h = 0, v = U(!1), b = j(() => { let A = [{ value: "rename", label: "Rename" }, { value: "delete", label: "Delete" }]; return n.node.type.startsWith(Zt) && A.push({ value: "editSubgraph", label: "Edit Subgraph" }), A }), y = j(() => ({ "--selected": n.selected, "--dragging": n.dragging, "--two-column": !!n.node.twoColumn })), E = j(() => ({ "--reverse-y": n.node.reverseY ?? s.value.settings.nodes.reverseY })), N = j(() => { var A, Z; return { top: `${((A = n.node.position) == null ? void 0 : A.y) ?? 0}px`, left: `${((Z = n.node.position) == null ? void 0 : Z.x) ?? 0}px`, "--width": `${n.node.width ?? s.value.settings.nodes.defaultWidth}px` } }), k = j(() => Object.values(n.node.inputs).filter(A => !A.hidden)), G = j(() => Object.values(n.node.outputs).filter(A => !A.hidden)), C = () => { o("select") }, D = A => { n.selected || C(), o("start-drag", A) }, z = () => { v.value = !0 }, P = async A => { var Z; switch (A) { case "delete": i.value.removeNode(n.node); break; case "rename": u.value = n.node.title, l.value = !0, await In(), (Z = c.value) == null || Z.focus(); break; case "editSubgraph": r(n.node.template); break } }, _ = () => { n.node.title = u.value, l.value = !1 }, M = () => { a.value && s.value.hooks.renderNode.execute({ node: n.node, el: a.value }) }, Y = A => { d.value = !0, p = n.node.width, h = A.clientX, A.preventDefault() }, L = A => { if (!d.value) return; let Z = A.clientX - h, J = p + Z / i.value.scaling, se = s.value.settings.nodes.minWidth, ee = s.value.settings.nodes.maxWidth; n.node.width = Math.max(se, Math.min(ee, J)) }, le = () => { d.value = !1 }; return zt(() => { M(), window.addEventListener("mousemove", L), window.addEventListener("mouseup", le) }), Vn(M), An(() => { window.removeEventListener("mousemove", L), window.removeEventListener("mouseup", le) }), (A, Z) => (S(), H("div", { id: A.node.id, ref_key: "el", ref: a, class: we(["baklava-node", y.value]), style: Ke(N.value), "data-node-type": A.node.type, onPointerdown: C }, [Q(s).settings.nodes.resizable ? (S(), H("div", { key: 0, class: "__resize-handle", onMousedown: Y }, null, 32)) : Se("", !0), We(A.$slots, "title", {}, () => [F("div", { class: "__title", onPointerdown: He(D, ["self", "stop"]), onContextmenu: He(z, ["prevent"]) }, [l.value ? Pt((S(), H("input", { key: 1, ref_key: "renameInputEl", ref: c, "onUpdate:modelValue": Z[1] || (Z[1] = J => u.value = J), type: "text", class: "baklava-input", placeholder: "Node Name", onBlur: _, onKeydown: Pn(_, ["enter"]) }, null, 544)), [[dn, u.value]]) : (S(), H(ae, { key: 0 }, [F("div", Of, Ee(A.node.title), 1), F("div", xf, [oe(Bl, { class: "--clickable", onClick: z }), oe(Q(Ms), { modelValue: v.value, "onUpdate:modelValue": Z[0] || (Z[0] = J => v.value = J), x: 0, y: 0, items: b.value, onClick: P }, null, 8, ["modelValue", "items"])])], 64))], 32)]), We(A.$slots, "content", {}, () => [F("div", { class: we(["__content", E.value]), onKeydown: Z[2] || (Z[2] = Pn(He(() => { }, ["stop"]), ["delete"])) }, [F("div", Cf, [(S(!0), H(ae, null, ct(G.value, J => We(A.$slots, "nodeInterface", { key: J.id, type: "output", node: A.node, intf: J }, () => [oe(Zi, { node: A.node, intf: J }, null, 8, ["node", "intf"])])), 128))]), F("div", Tf, [(S(!0), H(ae, null, ct(k.value, J => We(A.$slots, "nodeInterface", { key: J.id, type: "input", node: A.node, intf: J }, () => [oe(Zi, { node: A.node, intf: J }, null, 8, ["node", "intf"])])), 128))])], 34)])], 46, wf)) } }), Sf = me({ props: { x1: { type: Number, required: !0 }, y1: { type: Number, required: !0 }, x2: { type: Number, required: !0 }, y2: { type: Number, required: !0 }, state: { type: Number, default: tt.NONE }, isTemporary: { type: Boolean, default: !1 } }, setup(e) { let { viewModel: t } = Ye(), { graph: n } = nt(), o = (r, a) => { let l = (r + n.value.panning.x) * n.value.scaling, u = (a + n.value.panning.y) * n.value.scaling; return [l, u] }, s = j(() => { let [r, a] = o(e.x1, e.y1), [l, u] = o(e.x2, e.y2); if (t.value.settings.useStraightConnections) return `M ${r} ${a} L ${l} ${u}`; { let c = .3 * Math.abs(r - l); return `M ${r} ${a} C ${r + c} ${a}, ${l - c} ${u}, ${l} ${u}` } }), i = j(() => ({ "--temporary": e.isTemporary, "--allowed": e.state === tt.ALLOWED, "--forbidden": e.state === tt.FORBIDDEN })); return { d: s, classes: i } } }), Df = ["d"]; function kf(e, t, n, o, s, i) { return S(), H("path", { class: we(["baklava-connection", e.classes]), d: e.d }, null, 10, Df) } var pr = he(Sf, [["render", kf]]); function Wl(e) { return document.getElementById(e.id) } function fn(e) { let t = document.getElementById(e.id), n = t?.getElementsByClassName("__port"); return { node: t?.closest(".baklava-node") ?? null, interface: t, port: n && n.length > 0 ? n[0] : null } } var If = me({ components: { "connection-view": pr }, props: { connection: { type: Object, required: !0 } }, setup(e) { let { graph: t } = nt(), n, o = U({ x1: 0, y1: 0, x2: 0, y2: 0 }), s = j(() => e.connection.isInDanger ? tt.FORBIDDEN : tt.NONE), i = j(() => { var u; return (u = t.value.findNodeById(e.connection.from.nodeId)) == null ? void 0 : u.position }), r = j(() => { var u; return (u = t.value.findNodeById(e.connection.to.nodeId)) == null ? void 0 : u.position }), a = u => u.node && u.interface && u.port ? [u.node.offsetLeft + u.interface.offsetLeft + u.port.offsetLeft + u.port.clientWidth / 2, u.node.offsetTop + u.interface.offsetTop + u.port.offsetTop + u.port.clientHeight / 2] : [0, 0], l = () => { let u = fn(e.connection.from), c = fn(e.connection.to); u.node && c.node && (n || (n = new ResizeObserver(() => { l() }), n.observe(u.node), n.observe(c.node))); let [d, p] = a(u), [h, v] = a(c); o.value = { x1: d, y1: p, x2: h, y2: v } }; return zt(async () => { await In(), l() }), An(() => { n && n.disconnect() }), ze([i, r], () => l(), { deep: !0 }), { d: o, state: s } } }); function Mf(e, t, n, o, s, i) { let r = Yt("connection-view"); return S(), Oe(r, { x1: e.d.x1, y1: e.d.y1, x2: e.d.x2, y2: e.d.y2, state: e.state }, null, 8, ["x1", "y1", "x2", "y2", "state"]) } var Kl = he(If, [["render", Mf]]); function xo(e) { return e.node && e.interface && e.port ? [e.node.offsetLeft + e.interface.offsetLeft + e.port.offsetLeft + e.port.clientWidth / 2, e.node.offsetTop + e.interface.offsetTop + e.port.offsetTop + e.port.clientHeight / 2] : [0, 0] } var Vf = me({ components: { "connection-view": pr }, props: { connection: { type: Object, required: !0 } }, setup(e) { let t = j(() => e.connection ? e.connection.status : tt.NONE); return { d: j(() => { if (!e.connection) return { input: [0, 0], output: [0, 0] }; let o = xo(fn(e.connection.from)), s = e.connection.to ? xo(fn(e.connection.to)) : [e.connection.mx || o[0], e.connection.my || o[1]]; return e.connection.from.isInput ? { input: s, output: o } : { input: o, output: s } }), status: t } } }); function Af(e, t, n, o, s, i) { let r = Yt("connection-view"); return S(), Oe(r, { x1: e.d.input[0], y1: e.d.input[1], x2: e.d.output[0], y2: e.d.output[1], state: e.status, "is-temporary": "" }, null, 8, ["x1", "y1", "x2", "y2", "state"]) } var Gl = he(Vf, [["render", Af]]), Rf = me({ setup() { let { viewModel: e } = Ye(), { graph: t } = nt(), n = U(null), o = $t(e.value.settings.sidebar, "width"), s = j(() => e.value.settings.sidebar.resizable), i = 0, r = 0, a = j(() => { let h = t.value.sidebar.nodeId; return t.value.nodes.find(v => v.id === h) }), l = j(() => ({ width: `${o.value}px` })), u = j(() => a.value ? [...Object.values(a.value.inputs), ...Object.values(a.value.outputs)].filter(v => v.displayInSidebar && v.component) : []), c = () => { t.value.sidebar.visible = !1 }, d = h => { i = o.value, r = h.clientX, window.addEventListener("mousemove", p), window.addEventListener("mouseup", () => { window.removeEventListener("mousemove", p) }, { once: !0 }) }, p = h => { var v, b; let y = ((b = (v = n.value) == null ? void 0 : v.parentElement) == null ? void 0 : b.getBoundingClientRect().width) ?? 500, E = h.clientX - r, N = i - E; N < 300 ? N = 300 : N > .9 * y && (N = .9 * y), o.value = N }; return { el: n, graph: t, resizable: s, node: a, styles: l, displayedInterfaces: u, startResize: d, close: c } } }), $f = { class: "__header" }, Pf = { class: "__node-name" }; function Lf(e, t, n, o, s, i) { return S(), H("div", { ref: "el", class: we(["baklava-sidebar", { "--open": e.graph.sidebar.visible }]), style: Ke(e.styles) }, [e.resizable ? (S(), H("div", { key: 0, class: "__resizer", onMousedown: t[0] || (t[0] = (...r) => e.startResize && e.startResize(...r)) }, null, 32)) : Se("", !0), F("div", $f, [F("button", { tabindex: "-1", class: "__close", onClick: t[1] || (t[1] = (...r) => e.close && e.close(...r)) }, "\xD7"), F("div", Pf, [F("b", null, Ee(e.node ? e.node.title : ""), 1)])]), (S(!0), H(ae, null, ct(e.displayedInterfaces, r => (S(), H("div", { key: r.id, class: "__interface" }, [(S(), Oe(ds(r.component), { modelValue: r.value, "onUpdate:modelValue": a => r.value = a, node: e.node, intf: r }, null, 8, ["modelValue", "onUpdate:modelValue", "node", "intf"]))]))), 128))], 6) } var zl = he(Rf, [["render", Lf]]), Yl = me({ __name: "Minimap", setup(e) { let { viewModel: t } = Ye(), { graph: n } = nt(), o = U(null), s = U(!1), i, r = !1, a = { x1: 0, y1: 0, x2: 0, y2: 0 }, l, u = () => { var D, z; if (!i) return; i.canvas.width = o.value.offsetWidth, i.canvas.height = o.value.offsetHeight; let P = new Map, _ = new Map; for (let A of n.value.nodes) { let Z = Wl(A), J = Z?.offsetWidth ?? 0, se = Z?.offsetHeight ?? 0, ee = ((D = A.position) == null ? void 0 : D.x) ?? 0, xe = ((z = A.position) == null ? void 0 : z.y) ?? 0; P.set(A, { x1: ee, y1: xe, x2: ee + J, y2: xe + se }), _.set(A, Z) } let M = { x1: Number.MAX_SAFE_INTEGER, y1: Number.MAX_SAFE_INTEGER, x2: Number.MIN_SAFE_INTEGER, y2: Number.MIN_SAFE_INTEGER }; for (let A of P.values()) A.x1 < M.x1 && (M.x1 = A.x1), A.y1 < M.y1 && (M.y1 = A.y1), A.x2 > M.x2 && (M.x2 = A.x2), A.y2 > M.y2 && (M.y2 = A.y2); let Y = 50; M.x1 -= Y, M.y1 -= Y, M.x2 += Y, M.y2 += Y, a = M; let L = i.canvas.width / i.canvas.height, le = (a.x2 - a.x1) / (a.y2 - a.y1); if (L > le) { let A = (L - le) * (a.y2 - a.y1) * .5; a.x1 -= A, a.x2 += A } else { let A = a.x2 - a.x1, Z = a.y2 - a.y1, J = (A - L * Z) / L * .5; a.y1 -= J, a.y2 += J } i.clearRect(0, 0, i.canvas.width, i.canvas.height), i.strokeStyle = "white"; for (let A of n.value.connections) { let [Z, J] = xo(fn(A.from)), [se, ee] = xo(fn(A.to)), [xe, pn] = c(Z, J), [pt, ht] = c(se, ee); if (i.beginPath(), i.moveTo(xe, pn), t.value.settings.useStraightConnections) i.lineTo(pt, ht); else { let ut = .3 * Math.abs(xe - pt); i.bezierCurveTo(xe + ut, pn, pt - ut, ht, pt, ht) } i.stroke() } i.strokeStyle = "lightgray"; for (let [A, Z] of P.entries()) { let [J, se] = c(Z.x1, Z.y1), [ee, xe] = c(Z.x2, Z.y2); i.fillStyle = p(_.get(A)), i.beginPath(), i.rect(J, se, ee - J, xe - se), i.fill(), i.stroke() } if (s.value) { let A = v(), [Z, J] = c(A.x1, A.y1), [se, ee] = c(A.x2, A.y2); i.fillStyle = "rgba(255, 255, 255, 0.2)", i.fillRect(Z, J, se - Z, ee - J) } }, c = (D, z) => [(D - a.x1) / (a.x2 - a.x1) * i.canvas.width, (z - a.y1) / (a.y2 - a.y1) * i.canvas.height], d = (D, z) => [D * (a.x2 - a.x1) / i.canvas.width + a.x1, z * (a.y2 - a.y1) / i.canvas.height + a.y1], p = D => { if (D) { let z = D.querySelector(".__content"); if (z) { let _ = h(z); if (_) return _ } let P = h(D); if (P) return P } return "gray" }, h = D => { let z = getComputedStyle(D).backgroundColor; if (z && z !== "rgba(0, 0, 0, 0)") return z }, v = () => { let D = o.value.parentElement.offsetWidth, z = o.value.parentElement.offsetHeight, P = D / n.value.scaling - n.value.panning.x, _ = z / n.value.scaling - n.value.panning.y; return { x1: -n.value.panning.x, y1: -n.value.panning.y, x2: P, y2: _ } }, b = D => { D.button === 0 && (r = !0, y(D)) }, y = D => { if (r) { let [z, P] = d(D.offsetX, D.offsetY), _ = v(), M = (_.x2 - _.x1) / 2, Y = (_.y2 - _.y1) / 2; n.value.panning.x = -(z - M), n.value.panning.y = -(P - Y) } }, E = () => { r = !1 }, N = () => { s.value = !0 }, k = () => { s.value = !1, E() }; ze([s, n.value.panning, () => n.value.scaling, () => n.value.connections.length], () => { u() }); let G = j(() => n.value.nodes.map(D => D.position)), C = j(() => n.value.nodes.map(D => D.width)); return ze([G, C], () => { u() }, { deep: !0 }), zt(() => { i = o.value.getContext("2d"), i.imageSmoothingQuality = "high", u(), l = setInterval(u, 500) }), An(() => { clearInterval(l) }), (D, z) => (S(), H("canvas", { ref_key: "canvas", ref: o, class: "baklava-minimap", onMouseenter: N, onMouseleave: k, onMousedown: He(b, ["self"]), onMousemove: He(y, ["self"]), onMouseup: E, onContextmenu: z[0] || (z[0] = He(() => { }, ["stop", "prevent"])) }, null, 544)) } }), Hf = me({ components: { ContextMenu: Ms, VerticalDots: Bl }, props: { type: { type: String, required: !0 }, title: { type: String, required: !0 } }, setup(e) { let { viewModel: t } = Ye(), { switchGraph: n } = nt(), o = U(!1), s = j(() => e.type.startsWith(Zt)); return { showContextMenu: o, hasContextMenu: s, contextMenuItems: [{ label: "Edit Subgraph", value: "editSubgraph" }, { label: "Delete Subgraph", value: "deleteSubgraph" }], openContextMenu: () => { o.value = !0 }, onContextMenuClick: l => { let u = e.type.substring(Zt.length), c = t.value.editor.graphTemplates.find(d => d.id === u); if (c) switch (l) { case "editSubgraph": n(c); break; case "deleteSubgraph": t.value.editor.removeGraphTemplate(c); break } } } } }), Ff = ["data-node-type"], Uf = { class: "__title" }, Bf = { class: "__title-label" }, jf = { key: 0, class: "__menu" }; function Wf(e, t, n, o, s, i) { let r = Yt("vertical-dots"), a = Yt("context-menu"); return S(), H("div", { class: "baklava-node --palette", "data-node-type": e.type }, [F("div", Uf, [F("div", Bf, Ee(e.title), 1), e.hasContextMenu ? (S(), H("div", jf, [oe(r, { class: "--clickable", onPointerdown: t[0] || (t[0] = He(() => { }, ["stop", "prevent"])), onClick: He(e.openContextMenu, ["stop", "prevent"]) }, null, 8, ["onClick"]), oe(a, { modelValue: e.showContextMenu, "onUpdate:modelValue": t[1] || (t[1] = l => e.showContextMenu = l), x: -100, y: 0, items: e.contextMenuItems, onClick: e.onContextMenuClick, onPointerdown: t[2] || (t[2] = He(() => { }, ["stop", "prevent"])) }, null, 8, ["modelValue", "items", "onClick"])])) : Se("", !0)])], 8, Ff) } var Dl = he(Hf, [["render", Wf]]), Kf = { key: 0 }, ql = me({ __name: "NodePalette", setup(e) { let { viewModel: t } = Ye(), { x: n, y: o } = pf(), { transform: s } = dr(), i = ur(t), r = cn("editorEl"), a = U(null), l = j(() => { if (!a.value || !r?.value) return {}; let { left: c, top: d } = r.value.getBoundingClientRect(); return { top: `${o.value - d}px`, left: `${n.value - c}px` } }), u = (c, d) => { a.value = { type: c, nodeInformation: d }; let p = () => { let h = Le(new d.type); t.value.displayedGraph.addNode(h); let v = r.value.getBoundingClientRect(), [b, y] = s(n.value - v.left, o.value - v.top); h.position.x = b, h.position.y = y, a.value = null, document.removeEventListener("pointerup", p) }; document.addEventListener("pointerup", p) }; return (c, d) => (S(), H(ae, null, [F("div", { class: "baklava-node-palette", onContextmenu: d[0] || (d[0] = He(() => { }, ["stop", "prevent"])) }, [(S(!0), H(ae, null, ct(Q(i), p => (S(), H("section", { key: p.name }, [p.name !== "default" ? (S(), H("h1", Kf, Ee(p.name), 1)) : Se("", !0), (S(!0), H(ae, null, ct(p.nodeTypes, (h, v) => (S(), Oe(Dl, { key: v, type: v, title: h.title, onPointerdown: b => u(v, h) }, null, 8, ["type", "title", "onPointerdown"]))), 128))]))), 128))], 32), oe(ys, { name: "fade" }, { default: Mn(() => [a.value ? (S(), H("div", { key: 0, class: "baklava-dragged-node", style: Ke(l.value) }, [oe(Dl, { type: a.value.type, title: a.value.nodeInformation.title }, null, 8, ["type", "title"])], 4)) : Se("", !0)]), _: 1 })], 64)) } }), Gf = me({ props: { command: { type: String, required: !0 }, title: { type: String, required: !0 }, icon: { type: Object, required: !1, default: void 0 } }, setup() { let { viewModel: e } = Ye(); return { viewModel: e } } }), zf = ["disabled", "title"]; function Yf(e, t, n, o, s, i) { return S(), H("button", { class: "baklava-toolbar-entry baklava-toolbar-button", disabled: !e.viewModel.commandHandler.canExecuteCommand(e.command), title: e.title, onClick: t[0] || (t[0] = r => e.viewModel.commandHandler.executeCommand(e.command)) }, [e.icon ? (S(), Oe(ds(e.icon), { key: 0 })) : (S(), H(ae, { key: 1 }, [Hi(Ee(e.title), 1)], 64))], 8, zf) } var kl = he(Gf, [["render", Yf]]), qf = me({ __name: "Toolbar", setup(e) { let { viewModel: t } = Ye(), n = j(() => t.value.displayedGraph !== t.value.editor.graph), o = j(() => t.value.settings.toolbar.commands), s = j(() => t.value.settings.toolbar.subgraphCommands); return (i, r) => (S(), H("div", { class: "baklava-toolbar", onContextmenu: r[0] || (r[0] = He(() => { }, ["stop", "prevent"])) }, [(S(!0), H(ae, null, ct(o.value, a => (S(), Oe(kl, { key: a.command, command: a.command, title: a.title, icon: a.icon }, null, 8, ["command", "title", "icon"]))), 128)), n.value ? (S(!0), H(ae, { key: 0 }, ct(s.value, a => (S(), Oe(kl, { key: a.command, command: a.command, title: a.title, icon: a.icon }, null, 8, ["command", "title", "icon"]))), 128)) : Se("", !0)], 32)) } }), Xf = { class: "connections-container" }, hr = me({ __name: "Editor", props: { viewModel: {} }, setup(e) { let t = e, n = Symbol("EditorToken"), o = $t(t, "viewModel"); Al(o); let s = U(null); fs("editorEl", s); let i = j(() => t.viewModel.displayedGraph.nodes), r = j(() => t.viewModel.displayedGraph.nodes.map(P => cr($t(P, "position")))), a = j(() => t.viewModel.displayedGraph.connections), l = j(() => t.viewModel.displayedGraph.selectedNodes), u = Jd(), c = Pl(), d = Zd(o), p = Qd(s), h = j(() => ({ ...u.styles.value })), v = U(0); t.viewModel.editor.hooks.load.subscribe(n, P => (v.value++, P)); let b = P => { u.onPointerMove(P), c.onMouseMove(P) }, y = P => { if (P.button === 0) { if (p.onPointerDown(P)) return; P.target === s.value && (C(), u.onPointerDown(P)), c.onMouseDown() } }, E = P => { u.onPointerUp(P), c.onMouseUp() }, N = P => { P.key === "Tab" && P.preventDefault(), t.viewModel.commandHandler.handleKeyDown(P) }, k = P => { t.viewModel.commandHandler.handleKeyUp(P) }, G = P => { ["Control", "Shift"].some(_ => t.viewModel.commandHandler.pressedKeys.includes(_)) || C(), t.viewModel.displayedGraph.selectedNodes.push(P) }, C = () => { t.viewModel.displayedGraph.selectedNodes = [] }, D = P => { for (let _ of t.viewModel.displayedGraph.selectedNodes) { let M = i.value.indexOf(_), Y = r.value[M]; Y.onPointerDown(P), document.addEventListener("pointermove", Y.onPointerMove) } document.addEventListener("pointerup", z) }, z = () => { for (let P of t.viewModel.displayedGraph.selectedNodes) { let _ = i.value.indexOf(P), M = r.value[_]; M.onPointerUp(), document.removeEventListener("pointermove", M.onPointerMove) } document.removeEventListener("pointerup", z) }; return (P, _) => (S(), H("div", { ref_key: "el", ref: s, tabindex: "-1", class: we(["baklava-editor", { "baklava-ignore-mouse": !!Q(c).temporaryConnection.value || Q(u).dragging.value, "--temporary-connection": !!Q(c).temporaryConnection.value, "--start-selection-box": Q(p).startSelection }]), onPointermove: He(b, ["self"]), onPointerdown: y, onPointerup: E, onWheel: _[1] || (_[1] = He((...M) => Q(u).onMouseWheel && Q(u).onMouseWheel(...M), ["self"])), onKeydown: N, onKeyup: k, onContextmenu: _[2] || (_[2] = He((...M) => Q(d).open && Q(d).open(...M), ["self"])) }, [We(P.$slots, "background", {}, () => [oe(nf)]), We(P.$slots, "toolbar", {}, () => [P.viewModel.settings.toolbar.enabled ? (S(), Oe(qf, { key: 0 })) : Se("", !0)]), We(P.$slots, "palette", {}, () => [P.viewModel.settings.palette.enabled ? (S(), Oe(ql, { key: 0 })) : Se("", !0)]), (S(), H("svg", Xf, [(S(!0), H(ae, null, ct(a.value, M => (S(), H("g", { key: M.id + v.value.toString() }, [We(P.$slots, "connection", { connection: M }, () => [oe(Kl, { connection: M }, null, 8, ["connection"])])]))), 128)), We(P.$slots, "temporaryConnection", { temporaryConnection: Q(c).temporaryConnection.value }, () => [Q(c).temporaryConnection.value ? (S(), Oe(Gl, { key: 0, connection: Q(c).temporaryConnection.value }, null, 8, ["connection"])) : Se("", !0)])])), F("div", { class: "node-container", style: Ke(h.value) }, [oe(Cl, { name: "fade" }, { default: Mn(() => [(S(!0), H(ae, null, ct(i.value, (M, Y) => We(P.$slots, "node", { key: M.id + v.value.toString(), node: M, selected: l.value.includes(M), dragging: r.value[Y].dragging.value, onSelect: L => G(M), onStartDrag: D }, () => [oe(jl, { node: M, selected: l.value.includes(M), dragging: r.value[Y].dragging.value, onSelect: L => G(M), onStartDrag: D }, null, 8, ["node", "selected", "dragging", "onSelect"])])), 128))]), _: 3 })], 4), We(P.$slots, "sidebar", {}, () => [P.viewModel.settings.sidebar.enabled ? (S(), Oe(zl, { key: 0 })) : Se("", !0)]), We(P.$slots, "minimap", {}, () => [P.viewModel.settings.enableMinimap ? (S(), Oe(Yl, { key: 0 })) : Se("", !0)]), We(P.$slots, "contextMenu", { contextMenu: Q(d) }, () => [P.viewModel.settings.contextMenu.enabled ? (S(), Oe(Ms, { key: 0, modelValue: Q(d).show.value, "onUpdate:modelValue": _[0] || (_[0] = M => Q(d).show.value = M), items: Q(d).items.value, x: Q(d).x.value, y: Q(d).y.value, onClick: Q(d).onClick }, null, 8, ["modelValue", "items", "x", "y", "onClick"])) : Se("", !0)]), Q(p).isSelecting ? (S(), H("div", { key: 0, class: "selection-box", style: Ke(Q(p).getStyles()) }, null, 4)) : Se("", !0)], 34)) } }); function Jf(e) { let t = U([]), n = U([]); return { pressedKeys: t, handleKeyDown: r => { t.value.includes(r.key) || t.value.push(r.key), !(document.activeElement && lr(document.activeElement)) && n.value.forEach(a => { var l, u; a.keys.every(c => t.value.includes(c)) && ((l = a.options) != null && l.preventDefault && r.preventDefault(), (u = a.options) != null && u.stopPropagation && r.stopPropagation(), e(a.commandName)) }) }, handleKeyUp: r => { let a = t.value.indexOf(r.key); a >= 0 && t.value.splice(a, 1) }, registerHotkey: (r, a, l) => { n.value.push({ keys: r, commandName: a, options: l }) } } } var Xl = () => { let e = U(new Map), t = r => e.value.has(r), n = (r, a) => { if (e.value.has(r)) throw new Error(`Command "${r}" already exists`); e.value.set(r, a) }, o = (r, a = !1, ...l) => { if (!e.value.has(r)) { if (a) throw new Error(`[CommandHandler] Command ${r} not registered`); return } return e.value.get(r).execute(...l) }, s = (r, a = !1, ...l) => { if (!e.value.has(r)) { if (a) throw new Error(`[CommandHandler] Command ${r} not registered`); return !1 } return e.value.get(r).canExecute(l) }, i = Jf(o); return Le({ hasCommand: t, registerCommand: n, executeCommand: o, canExecuteCommand: s, ...i }) }, Zf = me({ props: { intf: { type: Object, required: !0 } }, setup(e) { return { onClick: () => { e.intf.callback && e.intf.callback() } } } }), Qf = ["title"]; function ep(e, t, n, o, s, i) { return S(), H("button", { class: "baklava-button --block", title: e.intf.name, onClick: t[0] || (t[0] = (...r) => e.onClick && e.onClick(...r)) }, Ee(e.intf.name), 9, Qf) } var Jl = he(Zf, [["render", ep]]), Qi = class extends ye { constructor(t, n) { super(t, void 0), this.component = Ze(Jl), this.callback = n, this.setPort(!1) } }, tp = ["title"], np = { class: "__label" }, Zl = me({ __name: "CheckboxInterface", props: { modelValue: { type: Boolean }, intf: {} }, emits: ["update:modelValue"], setup(e, { emit: t }) { let n = t; return (o, s) => (S(), H("div", { class: we(["baklava-checkbox", { "--checked": o.modelValue }]), title: o.intf.name, onClick: s[0] || (s[0] = i => n("update:modelValue", !o.modelValue)) }, [s[1] || (s[1] = F("div", { class: "__checkmark-container" }, [F("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", viewBox: "0 0 18 18" }, [F("path", { class: "__checkmark", d: "M 6 5 L 6 10 L 16 10", transform: "rotate(-45 10 10)" })])], -1)), F("div", np, Ee(o.intf.name), 1)], 10, tp)) } }), er = class extends ye { constructor() { super(...arguments), this.component = Ze(Zl) } }, Il = 9; function op(e) { return "validate" in e } var Co = class extends ye { constructor(t, n, o, s) { super(t, n), this.min = o, this.max = s } validate(t) { return (this.min === void 0 || t >= this.min) && (this.max === void 0 || t <= this.max) } }, mr = (e, t = 3) => { let n = U(null), o = U(!1), s = U(!1), i = U("0"), r = j(() => { let d = e.value.value.toFixed(t); return d.length > Il ? e.value.value.toExponential(Il - 5) : d }), a = d => Number.isNaN(d) ? !1 : op(e.value) ? e.value.validate(d) : !0, l = d => { a(d) && (e.value.value = d) }; return ze(i, () => { s.value = !1 }), { editMode: o, invalid: s, tempValue: i, inputEl: n, stringRepresentation: r, validate: a, setValue: l, enterEditMode: async () => { i.value = e.value.value.toFixed(t), o.value = !0, await In(), n.value && n.value.focus() }, leaveEditMode: () => { let d = parseFloat(i.value); a(d) ? (l(d), o.value = !1) : s.value = !0 } } }, sp = {}, ip = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function rp(e, t) { return S(), H("svg", ip, t[0] || (t[0] = [F("polyline", { points: "6 9 12 15 18 9" }, null, -1)])) } var Es = he(sp, [["render", rp]]), ap = me({ components: { "i-arrow": Es }, props: { intf: { type: Object, required: !0 } }, setup(e) { let t = mr($t(e, "intf"), 0); return { ...t, increment: () => { t.setValue(e.intf.value + 1) }, decrement: () => { t.setValue(e.intf.value - 1) } } } }), lp = { class: "baklava-num-input" }, cp = ["title"], up = { class: "__value" }, dp = { key: 1, class: "__content" }; function fp(e, t, n, o, s, i) { let r = Yt("i-arrow"); return S(), H("div", lp, [F("div", { class: "__button --dec", onClick: t[0] || (t[0] = (...a) => e.decrement && e.decrement(...a)) }, [oe(r)]), e.editMode ? (S(), H("div", dp, [Pt(F("input", { ref: "inputEl", "onUpdate:modelValue": t[2] || (t[2] = a => e.tempValue = a), type: "number", class: we(["baklava-input", { "--invalid": e.invalid }]), style: { "text-align": "right" }, onBlur: t[3] || (t[3] = (...a) => e.leaveEditMode && e.leaveEditMode(...a)), onKeydown: t[4] || (t[4] = Pn((...a) => e.leaveEditMode && e.leaveEditMode(...a), ["enter"])) }, null, 34), [[dn, e.tempValue]])])) : (S(), H("div", { key: 0, class: "__content", onClick: t[1] || (t[1] = (...a) => e.enterEditMode && e.enterEditMode(...a)) }, [F("div", { class: "__label", title: e.intf.name }, Ee(e.intf.name), 9, cp), F("div", up, Ee(e.stringRepresentation), 1)])), F("div", { class: "__button --inc", onClick: t[5] || (t[5] = (...a) => e.increment && e.increment(...a)) }, [oe(r)])]) } var Ql = he(ap, [["render", fp]]), tr = class extends Co { constructor() { super(...arguments), this.component = Ze(Ql) } validate(t) { return Number.isInteger(t) && super.validate(t) } }, pp = { class: "baklava-num-input" }, hp = ["title"], mp = { class: "__value" }, vp = { key: 1, class: "__content" }, ec = me({ __name: "NumberInterface", props: { intf: {} }, setup(e) { let t = e, { editMode: n, invalid: o, tempValue: s, inputEl: i, stringRepresentation: r, enterEditMode: a, leaveEditMode: l, setValue: u } = mr($t(t, "intf")); function c() { let p = parseFloat((t.intf.value + .1).toFixed(3)); u(p) } function d() { let p = parseFloat((t.intf.value - .1).toFixed(3)); u(p) } return (p, h) => (S(), H("div", pp, [F("div", { class: "__button --dec", onClick: d }, [oe(Es)]), Q(n) ? (S(), H("div", vp, [Pt(F("input", { ref_key: "inputEl", ref: i, "onUpdate:modelValue": h[1] || (h[1] = v => be(s) ? s.value = v : null), type: "number", class: we(["baklava-input", { "--invalid": Q(o) }]), style: { "text-align": "right" }, onBlur: h[2] || (h[2] = (...v) => Q(l) && Q(l)(...v)), onKeydown: h[3] || (h[3] = Pn((...v) => Q(l) && Q(l)(...v), ["enter"])) }, null, 34), [[dn, Q(s)]])])) : (S(), H("div", { key: 0, class: "__content", onClick: h[0] || (h[0] = (...v) => Q(a) && Q(a)(...v)) }, [F("div", { class: "__label", title: p.intf.name }, Ee(p.intf.name), 9, hp), F("div", mp, Ee(Q(r)), 1)])), F("div", { class: "__button --inc", onClick: c }, [oe(Es)])])) } }), nr = class extends Co { constructor() { super(...arguments), this.component = Ze(ec) } }, gp = me({ components: { "i-arrow": Es }, props: { intf: { type: Object, required: !0 } }, setup(e) { let t = U(null), n = U(!1), o = j(() => e.intf.items.find(r => typeof r == "string" ? r === e.intf.value : r.value === e.intf.value)), s = j(() => o.value ? typeof o.value == "string" ? o.value : o.value.text : ""), i = r => { e.intf.value = typeof r == "string" ? r : r.value }; return Fl(t, () => { n.value = !1 }), { el: t, open: n, selectedItem: o, selectedText: s, setSelected: i } } }), _p = ["title"], yp = { class: "__selected" }, Ep = { class: "__text" }, bp = { class: "__icon" }, Np = { class: "__dropdown" }, wp = { class: "item --header" }, Op = ["onClick"]; function xp(e, t, n, o, s, i) { let r = Yt("i-arrow"); return S(), H("div", { ref: "el", class: we(["baklava-select", { "--open": e.open }]), title: e.intf.name, onClick: t[0] || (t[0] = a => e.open = !e.open) }, [F("div", yp, [F("div", Ep, Ee(e.selectedText), 1), F("div", bp, [oe(r)])]), oe(ys, { name: "slide-fade" }, { default: Mn(() => [Pt(F("div", Np, [F("div", wp, Ee(e.intf.name), 1), (S(!0), H(ae, null, ct(e.intf.items, (a, l) => (S(), H("div", { key: l, class: we(["item", { "--active": a === e.selectedItem }]), onClick: u => e.setSelected(a) }, Ee(typeof a == "string" ? a : a.text), 11, Op))), 128))], 512), [[Yi, e.open]])]), _: 1 })], 10, _p) } var tc = he(gp, [["render", xp]]), or = class extends ye { constructor(t, n, o) { super(t, n), this.component = Ze(tc), this.items = o } }, Cp = me({ props: { intf: { type: Object, required: !0 } }, setup(e) { let t = U(null), n = mr($t(e, "intf")), o = U(!1), s = U(!1), i = j(() => Math.min(100, Math.max(0, (e.intf.value - e.intf.min) * 100 / (e.intf.max - e.intf.min)))); return { ...n, el: t, percentage: i, mousedown: () => { n.editMode.value || (s.value = !0) }, mouseup: () => { n.editMode.value || (o.value || n.enterEditMode(), s.value = !1, o.value = !1) }, mousemove: c => { if (n.editMode.value) return; let d = Math.max(e.intf.min, Math.min(e.intf.max, (e.intf.max - e.intf.min) * (c.offsetX / t.value.clientWidth) + e.intf.min)); s.value && (n.setValue(d), o.value = !0) }, mouseleave: c => { n.editMode.value || (s.value && (c.offsetX >= t.value.clientWidth ? n.setValue(e.intf.max) : c.offsetX <= 0 && n.setValue(e.intf.min)), s.value = !1, o.value = !1) } } } }), Tp = { key: 0, class: "__content" }, Sp = { class: "__label" }, Dp = { class: "__value" }, kp = { key: 1, class: "__content" }; function Ip(e, t, n, o, s, i) { return S(), H("div", { ref: "el", class: we(["baklava-slider", { "baklava-ignore-mouse": !e.editMode }]), onPointerdown: t[3] || (t[3] = (...r) => e.mousedown && e.mousedown(...r)), onPointerup: t[4] || (t[4] = (...r) => e.mouseup && e.mouseup(...r)), onPointermove: t[5] || (t[5] = (...r) => e.mousemove && e.mousemove(...r)), onPointerleave: t[6] || (t[6] = (...r) => e.mouseleave && e.mouseleave(...r)) }, [F("div", { class: "__slider", style: Ke({ width: e.percentage + "%" }) }, null, 4), e.editMode ? (S(), H("div", kp, [Pt(F("input", { ref: "inputEl", "onUpdate:modelValue": t[0] || (t[0] = r => e.tempValue = r), type: "number", class: we(["baklava-input", { "--invalid": e.invalid }]), style: { "text-align": "right" }, onBlur: t[1] || (t[1] = (...r) => e.leaveEditMode && e.leaveEditMode(...r)), onKeydown: t[2] || (t[2] = Pn((...r) => e.leaveEditMode && e.leaveEditMode(...r), ["enter"])) }, null, 34), [[dn, e.tempValue]])])) : (S(), H("div", Tp, [F("div", Sp, Ee(e.intf.name), 1), F("div", Dp, Ee(e.stringRepresentation), 1)]))], 34) } var nc = he(Cp, [["render", Ip]]), sr = class extends Co { constructor(t, n, o, s) { super(t, n, o, s), this.component = Ze(nc), this.min = o, this.max = s } }, Mp = me({ props: { intf: { type: Object, required: !0 } } }); function Vp(e, t, n, o, s, i) { return S(), H("div", null, Ee(e.intf.value), 1) } var Ap = he(Mp, [["render", Vp]]), ir = class extends ye { constructor(t, n) { super(t, n), this.component = Ze(Ap), this.setPort(!1) } }, Rp = me({ props: { intf: { type: Object, required: !0 }, modelValue: { type: String, required: !0 } }, emits: ["update:modelValue"], setup(e, { emit: t }) { return { v: j({ get: () => e.modelValue, set: o => { t("update:modelValue", o) } }) } } }), $p = ["placeholder", "title"]; function Pp(e, t, n, o, s, i) { return S(), H("div", null, [Pt(F("input", { "onUpdate:modelValue": t[0] || (t[0] = r => e.v = r), type: "text", class: "baklava-input", placeholder: e.intf.name, title: e.intf.name }, null, 8, $p), [[dn, e.v]])]) } var oc = he(Rp, [["render", Pp]]), To = class extends ye { constructor() { super(...arguments), this.component = Ze(oc) } }, Lp = me({ props: { intf: { type: Object, required: !0 }, modelValue: { type: String, required: !0 } }, emits: ["update:modelValue"], setup(e, { emit: t }) { return { v: j({ get: () => e.modelValue, set: o => { t("update:modelValue", o) } }) } } }), Hp = ["placeholder", "title"]; function Fp(e, t, n, o, s, i) { return S(), H("div", null, [Pt(F("textarea", { "onUpdate:modelValue": t[0] || (t[0] = r => e.v = r), rows: "5", class: "baklava-input", placeholder: e.intf.name, title: e.intf.name }, null, 8, Hp), [[dn, e.v]])]) } var sc = he(Lp, [["render", Fp]]), rr = class extends ye { constructor() { super(...arguments), this.component = Ze(sc) } }, Ve = []; for (let e = 0; e < 256; ++e)Ve.push((e + 256).toString(16).slice(1)); function Up(e, t = 0) { return (Ve[e[t + 0]] + Ve[e[t + 1]] + Ve[e[t + 2]] + Ve[e[t + 3]] + "-" + Ve[e[t + 4]] + Ve[e[t + 5]] + "-" + Ve[e[t + 6]] + Ve[e[t + 7]] + "-" + Ve[e[t + 8]] + Ve[e[t + 9]] + "-" + Ve[e[t + 10]] + Ve[e[t + 11]] + Ve[e[t + 12]] + Ve[e[t + 13]] + Ve[e[t + 14]] + Ve[e[t + 15]]).toLowerCase() } var Xi, Bp = new Uint8Array(16); function jp() { if (!Xi) { if (typeof crypto > "u" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"); Xi = crypto.getRandomValues.bind(crypto) } return Xi(Bp) } var Wp = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Ml = { randomUUID: Wp }; function bs(e, t, n) { var o; if (Ml.randomUUID && !e) return Ml.randomUUID(); e = e || {}; let s = e.random ?? ((o = e.rng) == null ? void 0 : o.call(e)) ?? jp(); if (s.length < 16) throw new Error("Random bytes length must be >= 16"); return s[6] = s[6] & 15 | 64, s[8] = s[8] & 63 | 128, Up(s) } var Hn = "SAVE_SUBGRAPH"; function Kp(e, t) { let n = () => { let o = e.value; if (!o.template) throw new Error("Graph template property not set"); o.template.update(o.save()), o.template.panning = o.panning, o.template.scaling = o.scaling }; t.registerCommand(Hn, { canExecute: () => { var o; return e.value !== ((o = e.value.editor) == null ? void 0 : o.graph) }, execute: n }) } var Ns = class extends Vt { constructor() { super(...arguments), this._title = "Subgraph Input", this.inputs = { name: new To("Name", "Input").setPort(!1) }, this.outputs = { placeholder: new ye("Connection", void 0) } } }, ws = class extends At { constructor() { super(...arguments), this._title = "Subgraph Output", this.inputs = { name: new To("Name", "Output").setPort(!1), placeholder: new ye("Connection", void 0) }, this.outputs = { output: new ye("Output", void 0).setHidden(!0) } } }, vr = "CREATE_SUBGRAPH", Vl = [vt, gt]; function Gp(e, t, n) { let o = () => e.value.selectedNodes.filter(i => !Vl.includes(i.type)).length > 0, s = () => { let { viewModel: i } = Ye(), r = e.value, a = e.value.editor; if (r.selectedNodes.length === 0) return; let l = r.selectedNodes.filter(_ => !Vl.includes(_.type)), u = l.flatMap(_ => Object.values(_.inputs)), c = l.flatMap(_ => Object.values(_.outputs)), d = r.connections.filter(_ => !c.includes(_.from) && u.includes(_.to)), p = r.connections.filter(_ => c.includes(_.from) && !u.includes(_.to)), h = r.connections.filter(_ => c.includes(_.from) && u.includes(_.to)), v = l.map(_ => _.save()), b = h.map(_ => ({ id: _.id, from: _.from.id, to: _.to.id })), y = new Map, { xLeft: E, xRight: N, yTop: k } = zp(l); for (let [_, M] of d.entries()) { let Y = new Ns; Y.inputs.name.value = M.to.name, v.push({ ...Y.save(), position: { x: N - i.value.settings.nodes.defaultWidth - 100, y: k + _ * 200 } }), b.push({ id: bs(), from: Y.outputs.placeholder.id, to: M.to.id }), y.set(M.to.id, Y.graphInterfaceId) } for (let [_, M] of p.entries()) { let Y = new ws; Y.inputs.name.value = M.from.name, v.push({ ...Y.save(), position: { x: E + 100, y: k + _ * 200 } }), b.push({ id: bs(), from: M.from.id, to: Y.inputs.placeholder.id }), y.set(M.from.id, Y.graphInterfaceId) } let G = Le(new Qt({ connections: b, nodes: v, inputs: [], outputs: [] }, a)); a.addGraphTemplate(G); let C = a.nodeTypes.get(_t(G)); if (!C) throw new Error("Unable to create subgraph: Could not find corresponding graph node type"); r.activeTransactions++; let D = Le(new C.type); r.addNode(D); let z = Math.round(l.map(_ => _.position.x).reduce((_, M) => _ + M, 0) / l.length), P = Math.round(l.map(_ => _.position.y).reduce((_, M) => _ + M, 0) / l.length); D.position.x = z, D.position.y = P, d.forEach(_ => { r.removeConnection(_), r.addConnection(_.from, D.inputs[y.get(_.to.id)]) }), p.forEach(_ => { r.removeConnection(_), r.addConnection(D.outputs[y.get(_.from.id)], _.to) }), l.forEach(_ => r.removeNode(_)), r.activeTransactions--, t.canExecuteCommand(Hn) && t.executeCommand(Hn), n(G), e.value.panning = { ...r.panning }, e.value.scaling = r.scaling }; t.registerCommand(vr, { canExecute: o, execute: s }) } function zp(e) { let t = e.reduce((s, i) => { let r = i.position.x; return r < s ? r : s }, 1 / 0), n = e.reduce((s, i) => { let r = i.position.y; return r < s ? r : s }, 1 / 0); return { xLeft: e.reduce((s, i) => { let r = i.position.x + i.width; return r > s ? r : s }, -1 / 0), xRight: t, yTop: n } } var Os = class { constructor(t, n) { this.type = t, t === "addNode" ? this.nodeId = n : this.nodeState = n } undo(t) { this.type === "addNode" ? this.removeNode(t) : this.addNode(t) } redo(t) { this.type === "addNode" && this.nodeState ? this.addNode(t) : this.type === "removeNode" && this.nodeId && this.removeNode(t) } addNode(t) { let n = t.editor.nodeTypes.get(this.nodeState.type); if (!n) return; let o = new n.type; t.addNode(o), o.load(this.nodeState), this.nodeId = o.id } removeNode(t) { let n = t.nodes.find(o => o.id === this.nodeId); n && (this.nodeState = n.save(), t.removeNode(n)) } }, xs = class { constructor(t, n) { if (this.type = t, t === "addConnection") this.connectionId = n; else { let o = n; this.connectionState = { id: o.id, from: o.from.id, to: o.to.id } } } undo(t) { this.type === "addConnection" ? this.removeConnection(t) : this.addConnection(t) } redo(t) { this.type === "addConnection" && this.connectionState ? this.addConnection(t) : this.type === "removeConnection" && this.connectionId && this.removeConnection(t) } addConnection(t) { let n = t.findNodeInterface(this.connectionState.from), o = t.findNodeInterface(this.connectionState.to); if (!n || !o) return; let s = t.addConnection(n, o); s && (s.id = this.connectionState.id), this.connectionId = s?.id } removeConnection(t) { let n = t.connections.find(o => o.id === this.connectionId); n && (this.connectionState = { id: n.id, from: n.from.id, to: n.to.id }, t.removeConnection(n)) } }, ar = class { constructor(t) { if (this.type = "transaction", t.length === 0) throw new Error("Can't create a transaction with no steps"); this.steps = t } undo(t) { for (let n = this.steps.length - 1; n >= 0; n--)this.steps[n].undo(t) } redo(t) { for (let n = 0; n < this.steps.length; n++)this.steps[n].redo(t) } }, Cs = "UNDO", Ts = "REDO", Vs = "START_TRANSACTION", As = "COMMIT_TRANSACTION", ic = "CLEAR_HISTORY"; function Yp(e, t) { let n = Symbol("HistoryToken"), o = U(200), s = U([]), i = U(!1), r = U(-1), a = U(!1), l = U([]), u = E => { if (!i.value) if (a.value) l.value.push(E); else { for (r.value !== s.value.length - 1 && (s.value = s.value.slice(0, r.value + 1)), s.value.push(E); s.value.length > o.value;)s.value.shift(); r.value = s.value.length - 1 } }, c = () => { a.value = !0 }, d = () => { a.value = !1, l.value.length > 0 && (u(new ar(l.value)), l.value = []) }, p = () => s.value.length !== 0 && r.value !== -1, h = () => { p() && (i.value = !0, s.value[r.value--].undo(e.value), i.value = !1) }, v = () => s.value.length !== 0 && r.value < s.value.length - 1, b = () => { v() && (i.value = !0, s.value[++r.value].redo(e.value), i.value = !1) }, y = () => { s.value = [], r.value = -1 }; return ze(e, (E, N) => { N && (N.events.addNode.unsubscribe(n), N.events.removeNode.unsubscribe(n), N.events.addConnection.unsubscribe(n), N.events.removeConnection.unsubscribe(n)), E && (E.events.addNode.subscribe(n, k => { u(new Os("addNode", k.id)) }), E.events.removeNode.subscribe(n, k => { u(new Os("removeNode", k.save())) }), E.events.addConnection.subscribe(n, k => { u(new xs("addConnection", k.id)) }), E.events.removeConnection.subscribe(n, k => { u(new xs("removeConnection", k)) })) }, { immediate: !0 }), t.registerCommand(Cs, { canExecute: p, execute: h }), t.registerCommand(Ts, { canExecute: v, execute: b }), t.registerCommand(Vs, { canExecute: () => !a.value, execute: c }), t.registerCommand(As, { canExecute: () => a.value, execute: d }), t.registerCommand(ic, { canExecute: () => s.value.length > 0, execute: y }), t.registerHotkey(["Control", "z"], Cs), t.registerHotkey(["Control", "y"], Ts), Le({ maxSteps: o }) } var Ss = "DELETE_NODES"; function qp(e, t) { t.registerCommand(Ss, { canExecute: () => e.value.selectedNodes.length > 0, execute() { t.executeCommand(Vs); for (let n = e.value.selectedNodes.length - 1; n >= 0; n--) { let o = e.value.selectedNodes[n]; e.value.removeNode(o) } t.executeCommand(As) } }), t.registerHotkey(["Delete"], Ss) } var gr = "SWITCH_TO_MAIN_GRAPH"; function Xp(e, t, n) { t.registerCommand(gr, { canExecute: () => e.value !== e.value.editor.graph, execute: () => { t.executeCommand(Hn), n(e.value.editor.graph) } }) } function Jp(e, t, n) { qp(e, t), Gp(e, t, n), Kp(e, t), Xp(e, t, n) } var Ds = "COPY", ks = "PASTE", rc = "CLEAR_CLIPBOARD"; function Zp(e, t, n) { let o = Symbol("ClipboardToken"), s = U(""), i = U(""), r = j(() => !s.value), a = () => { s.value = "", i.value = "" }, l = () => { let d = e.value.selectedNodes.flatMap(h => [...Object.values(h.inputs), ...Object.values(h.outputs)]), p = e.value.connections.filter(h => d.includes(h.from) || d.includes(h.to)).map(h => ({ from: h.from.id, to: h.to.id })); i.value = JSON.stringify(p), s.value = JSON.stringify(e.value.selectedNodes.map(h => h.save())) }, u = (d, p, h) => { for (let v of d) { let b; if ((!h || h === "input") && (b = Object.values(v.inputs).find(y => y.id === p)), !b && (!h || h === "output") && (b = Object.values(v.outputs).find(y => y.id === p)), b) return b } }, c = () => { if (r.value) return; let d = new Map, p = JSON.parse(s.value), h = JSON.parse(i.value), v = [], b = [], y = e.value; n.executeCommand(Vs); for (let E of p) { let N = t.value.nodeTypes.get(E.type); if (!N) { console.warn(`Node type ${E.type} not registered`); return } let k = new N.type, G = k.id; v.push(k), k.hooks.beforeLoad.subscribe(o, C => { let D = C; return D.position && (D.position.x += 100, D.position.y += 100), k.hooks.beforeLoad.unsubscribe(o), D }), y.addNode(k), k.load({ ...E, id: G }), k.id = G, d.set(E.id, G); for (let C of Object.values(k.inputs)) { let D = bs(); d.set(C.id, D), C.id = D } for (let C of Object.values(k.outputs)) { let D = bs(); d.set(C.id, D), C.id = D } } for (let E of h) { let N = u(v, d.get(E.from), "output"), k = u(v, d.get(E.to), "input"); if (!N || !k) continue; let G = y.addConnection(N, k); G && b.push(G) } return e.value.selectedNodes = v, n.executeCommand(As), { newNodes: v, newConnections: b } }; return n.registerCommand(Ds, { canExecute: () => e.value.selectedNodes.length > 0, execute: l }), n.registerHotkey(["Control", "c"], Ds), n.registerCommand(ks, { canExecute: () => !r.value, execute: c }), n.registerHotkey(["Control", "v"], ks), n.registerCommand(rc, { canExecute: () => !0, execute: a }), Le({ isEmpty: r }) } var ac = "OPEN_SIDEBAR"; function Qp(e, t) { t.registerCommand(ac, { execute: n => { e.value.sidebar.nodeId = n, e.value.sidebar.visible = !0 }, canExecute: () => !0 }) } var eh = (e, t) => { e.displayInSidebar = t }; function th(e, t) { Qp(e, t) } var lc = "ZOOM_TO_FIT_RECT", cc = "ZOOM_TO_FIT_NODES", Is = "ZOOM_TO_FIT_GRAPH"; function nh(e, t, n) { t.registerCommand(lc, { canExecute: () => !0, execute: o => uc(e.value, n, o) }), t.registerCommand(cc, { canExecute: () => !0, execute: o => dc(e.value, n, o) }), t.registerCommand(Is, { canExecute: () => e.value.nodes.length > 0, execute: () => oh(e.value, n) }), t.registerHotkey(["f"], Is) } function uc(e, t, n) { let o = { left: t.zoomToFit.paddingLeft, right: t.zoomToFit.paddingRight, top: t.zoomToFit.paddingTop, bottom: t.zoomToFit.paddingBottom }, i = document.querySelector(".baklava-editor").getBoundingClientRect(), r = Math.max(0, i.width - o.left - o.right), a = Math.max(0, i.height - o.top - o.bottom); n = ih(n); let l = n.x2 - n.x1, u = n.y2 - n.y1, c = l === 0 ? 1 / 0 : r / l, d = u == 0 ? 1 / 0 : a / u, p = Math.min(c, d); (p === 0 || !Number.isFinite(p)) && (p = 1); let h = Math.max(0, r / p - l), v = Math.max(0, a / p - u), b = -n.x1 + o.left / p + h / 2, y = -n.y1 + o.top / p + v / 2; e.panning.x = b, e.panning.y = y, e.scaling = p } function dc(e, t, n) { if (n.length === 0) return; let o = n.map(sh), s = { x1: Math.min(...o.map(i => i.x1)), y1: Math.min(...o.map(i => i.y1)), x2: Math.max(...o.map(i => i.x2)), y2: Math.max(...o.map(i => i.y2)) }; uc(e, t, s) } function oh(e, t) { dc(e, t, e.nodes) } function sh(e) { var t, n; let o = document.getElementById(e.id), s = o?.offsetWidth ?? 0, i = o?.offsetHeight ?? 0, r = ((t = e.position) == null ? void 0 : t.x) ?? 0, a = ((n = e.position) == null ? void 0 : n.y) ?? 0; return { x1: r, y1: a, x2: r + s, y2: a + i } } function ih(e) { return { x1: Math.min(e.x1, e.x2), y1: Math.min(e.y1, e.y2), x2: Math.max(e.x1, e.x2), y2: Math.max(e.y1, e.y2) } } var rh = Object.freeze(Object.defineProperty({ __proto__: null, CLEAR_CLIPBOARD_COMMAND: rc, CLEAR_HISTORY_COMMAND: ic, COMMIT_TRANSACTION_COMMAND: As, COPY_COMMAND: Ds, CREATE_SUBGRAPH_COMMAND: vr, DELETE_NODES_COMMAND: Ss, OPEN_SIDEBAR_COMMAND: ac, PASTE_COMMAND: ks, REDO_COMMAND: Ts, SAVE_SUBGRAPH_COMMAND: Hn, START_SELECTION_BOX_COMMAND: wo, START_TRANSACTION_COMMAND: Vs, SWITCH_TO_MAIN_GRAPH_COMMAND: gr, UNDO_COMMAND: Cs, ZOOM_TO_FIT_GRAPH_COMMAND: Is, ZOOM_TO_FIT_NODES_COMMAND: cc, ZOOM_TO_FIT_RECT_COMMAND: lc }, Symbol.toStringTag, { value: "Module" })), ah = {}, lh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function ch(e, t) { return S(), H("svg", lh, t[0] || (t[0] = [F("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, null, -1), F("path", { d: "M9 13l-4 -4l4 -4m-4 4h11a4 4 0 0 1 0 8h-1" }, null, -1)])) } var uh = he(ah, [["render", ch]]), dh = {}, fh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function ph(e, t) { return S(), H("svg", fh, t[0] || (t[0] = [F("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, null, -1), F("path", { d: "M15 13l4 -4l-4 -4m4 4h-11a4 4 0 0 0 0 8h1" }, null, -1)])) } var hh = he(dh, [["render", ph]]), mh = {}, vh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function gh(e, t) { return S(), H("svg", vh, t[0] || (t[0] = [F("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, null, -1), F("line", { x1: "5", y1: "12", x2: "19", y2: "12" }, null, -1), F("line", { x1: "5", y1: "12", x2: "11", y2: "18" }, null, -1), F("line", { x1: "5", y1: "12", x2: "11", y2: "6" }, null, -1)])) } var _h = he(mh, [["render", gh]]), yh = {}, Eh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function bh(e, t) { return S(), H("svg", Eh, t[0] || (t[0] = [F("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, null, -1), F("path", { d: "M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2" }, null, -1), F("rect", { x: "9", y: "3", width: "6", height: "4", rx: "2" }, null, -1)])) } var Nh = he(yh, [["render", bh]]), wh = {}, Oh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function xh(e, t) { return S(), H("svg", Oh, t[0] || (t[0] = [F("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, null, -1), F("rect", { x: "8", y: "8", width: "12", height: "12", rx: "2" }, null, -1), F("path", { d: "M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2" }, null, -1)])) } var Ch = he(wh, [["render", xh]]), Th = {}, Sh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function Dh(e, t) { return S(), H("svg", Sh, t[0] || (t[0] = [F("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, null, -1), F("path", { d: "M6 4h10l4 4v10a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2" }, null, -1), F("circle", { cx: "12", cy: "14", r: "2" }, null, -1), F("polyline", { points: "14 4 14 8 8 8 8 4" }, null, -1)])) } var kh = he(Th, [["render", Dh]]), Ih = {}, Mh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function Vh(e, t) { return S(), H("svg", Mh, t[0] || (t[0] = [_o('<path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M10 3h4v4h-4z"></path><path d="M3 17h4v4h-4z"></path><path d="M17 17h4v4h-4z"></path><path d="M7 17l5 -4l5 4"></path><line x1="12" y1="7" x2="12" y2="13"></line>', 6)])) } var Ah = he(Ih, [["render", Vh]]), Rh = {}, $h = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "1.5", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function Ph(e, t) { return S(), H("svg", $h, t[0] || (t[0] = [_o('<path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 1a1 1 0 0 1 1 -1h6a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-6a1 1 0 0 1 -1 -1z"></path><path d="M12 20v.01"></path><path d="M16 20v.01"></path><path d="M8 20v.01"></path><path d="M4 20v.01"></path><path d="M4 16v.01"></path><path d="M4 12v.01"></path><path d="M4 8v.01"></path><path d="M4 4v.01"></path><path d="M8 4v.01"></path><path d="M12 4v.01"></path><path d="M16 4v.01"></path><path d="M20 4v.01"></path><path d="M20 8v.01"></path><path d="M20 12v.01"></path><path d="M20 16v.01"></path><path d="M20 20v.01"></path>', 18)])) } var Lh = he(Rh, [["render", Ph]]), Hh = {}, Fh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "1.5", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function Uh(e, t) { return S(), H("svg", Fh, t[0] || (t[0] = [_o('<path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M4 7l16 0"></path><path d="M10 11l0 6"></path><path d="M14 11l0 6"></path><path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12"></path><path d="M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3"></path>', 6)])) } var Bh = he(Hh, [["render", Uh]]), jh = {}, Wh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function Kh(e, t) { return S(), H("svg", Wh, t[0] || (t[0] = [_o('<path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M4 8v-2a2 2 0 0 1 2 -2h2"></path><path d="M4 16v2a2 2 0 0 0 2 2h2"></path><path d="M16 4h2a2 2 0 0 1 2 2v2"></path><path d="M16 20h2a2 2 0 0 0 2 -2v-2"></path><path d="M8 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"></path><path d="M16 16l-2.5 -2.5"></path>', 7)])) } var Gh = he(jh, [["render", Kh]]), fc = { COPY: { command: Ds, title: "Copy", icon: Ch }, PASTE: { command: ks, title: "Paste", icon: Nh }, DELETE_NODES: { command: Ss, title: "Delete selected nodes", icon: Bh }, UNDO: { command: Cs, title: "Undo", icon: uh }, REDO: { command: Ts, title: "Redo", icon: hh }, ZOOM_TO_FIT_GRAPH: { command: Is, title: "Zoom to Fit", icon: Gh }, START_SELECTION_BOX: { command: wo, title: "Box Select", icon: Lh }, CREATE_SUBGRAPH: { command: vr, title: "Create Subgraph", icon: Ah } }, pc = Object.values(fc), hc = { SAVE_SUBGRAPH: { command: Hn, title: "Save Subgraph", icon: kh }, SWITCH_TO_MAIN_GRAPH: { command: gr, title: "Back to Main Graph", icon: _h } }, mc = Object.values(hc), zh = e => !(e instanceof it); function Yh(e, t) { return { switchGraph: o => { let s; if (zh(o)) s = new it(e.value), o.createGraph(s); else { if (o !== e.value.graph) throw new Error("Can only switch using 'Graph' instance when it is the root graph. Otherwise a 'GraphTemplate' must be used."); s = o } t.value && t.value !== e.value.graph && t.value.destroy(), s.panning = s.panning ?? o.panning ?? { x: 0, y: 0 }, s.scaling = s.scaling ?? o.scaling ?? 1, s.selectedNodes = s.selectedNodes ?? [], s.sidebar = s.sidebar ?? { visible: !1, nodeId: "", optionName: "" }, t.value = s } } } function qh(e, t) { e.position = e.position ?? { x: 0, y: 0 }, e.disablePointerEvents = !1, e.twoColumn = e.twoColumn ?? !1, e.width = e.width ?? t.defaultWidth } var Xh = () => ({ useStraightConnections: !1, enableMinimap: !1, toolbar: { enabled: !0, commands: pc, subgraphCommands: mc }, palette: { enabled: !0 }, background: { gridSize: 100, gridDivision: 5, subGridVisibleThreshold: .6 }, sidebar: { enabled: !0, width: 300, resizable: !0 }, displayValueOnHover: !1, nodes: { defaultWidth: 200, maxWidth: 320, minWidth: 150, resizable: !1, reverseY: !1 }, contextMenu: { enabled: !0, additionalItems: [] }, zoomToFit: { paddingLeft: 300, paddingRight: 50, paddingTop: 110, paddingBottom: 50 } }); function _r(e) { let t = U(e ?? new Kn), n = Symbol("ViewModelToken"), o = U(null), s = _i(o), { switchGraph: i } = Yh(t, o), r = j(() => s.value && s.value !== t.value.graph), a = Le(Xh()), l = Xl(), u = Yp(s, l), c = Zp(s, t, l), d = { renderNode: new Ne(null), renderInterface: new Ne(null) }; return Jp(s, l, i), th(s, l), nh(s, l, a), ze(t, (p, h) => { h && (h.events.registerGraph.unsubscribe(n), h.graphEvents.beforeAddNode.unsubscribe(n), p.nodeHooks.beforeLoad.unsubscribe(n), p.nodeHooks.afterSave.unsubscribe(n), p.graphTemplateHooks.beforeLoad.unsubscribe(n), p.graphTemplateHooks.afterSave.unsubscribe(n), p.graph.hooks.load.unsubscribe(n), p.graph.hooks.save.unsubscribe(n)), p && (p.nodeHooks.beforeLoad.subscribe(n, (v, b) => (b.position = v.position ?? { x: 0, y: 0 }, b.width = v.width ?? a.nodes.defaultWidth, b.twoColumn = v.twoColumn ?? !1, v)), p.nodeHooks.afterSave.subscribe(n, (v, b) => (v.position = b.position, v.width = b.width, v.twoColumn = b.twoColumn, v)), p.graphTemplateHooks.beforeLoad.subscribe(n, (v, b) => (b.panning = v.panning, b.scaling = v.scaling, v)), p.graphTemplateHooks.afterSave.subscribe(n, (v, b) => (v.panning = b.panning, v.scaling = b.scaling, v)), p.graph.hooks.load.subscribe(n, (v, b) => (b.panning = v.panning, b.scaling = v.scaling, v)), p.graph.hooks.save.subscribe(n, (v, b) => (v.panning = b.panning, v.scaling = b.scaling, v)), p.graphEvents.beforeAddNode.subscribe(n, v => qh(v, { defaultWidth: a.nodes.defaultWidth })), t.value.registerNodeType(Ns, { category: "Subgraphs" }), t.value.registerNodeType(ws, { category: "Subgraphs" }), i(p.graph)) }, { immediate: !0 }), Le({ editor: t, displayedGraph: s, isSubgraph: r, settings: a, commandHandler: l, history: u, clipboard: c, hooks: d, switchGraph: i }) } var Jh = Object.freeze(Object.defineProperty({ __proto__: null, Connection: pr, ConnectionWrapper: Kl, ContextMenu: Ms, Minimap: Yl, Node: jl, NodeInterface: Zi, NodePalette: ql, Sidebar: zl, TemporaryConnection: Gl }, Symbol.toStringTag, { value: "Module" })); function Zh(e) { let t; return Tl({ setup() { let n = _r(); return t = n, { viewModel: n } }, render() { return ms(hr, { viewModel: this.viewModel }) } }).mount(e), t } return Nc(Qh);
})();
/*! Bundled license information:

@vue/shared/dist/shared.esm-bundler.js:
  (**
  * @vue/shared v3.5.16
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (*! #__NO_SIDE_EFFECTS__ *)

@vue/reactivity/dist/reactivity.esm-bundler.js:
  (**
  * @vue/reactivity v3.5.16
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/runtime-core/dist/runtime-core.esm-bundler.js:
  (**
  * @vue/runtime-core v3.5.16
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/runtime-core/dist/runtime-core.esm-bundler.js:
@vue/runtime-core/dist/runtime-core.esm-bundler.js:
@vue/runtime-core/dist/runtime-core.esm-bundler.js:
@vue/runtime-dom/dist/runtime-dom.esm-bundler.js:
@vue/runtime-dom/dist/runtime-dom.esm-bundler.js:
  (*! #__NO_SIDE_EFFECTS__ *)

@vue/runtime-dom/dist/runtime-dom.esm-bundler.js:
  (**
  * @vue/runtime-dom v3.5.16
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

vue/dist/vue.runtime.esm-bundler.js:
  (**
  * vue v3.5.16
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
*/
//# sourceMappingURL=bundle.js.map