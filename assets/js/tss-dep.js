/*! hotkeys-js v3.6.13 | MIT (c) 2019 kenny wong <wowohoo@qq.com> | http://jaywcjlove.github.io/hotkeys */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).hotkeys=t()}(this,function(){"use strict";var e="undefined"!=typeof navigator&&0<navigator.userAgent.toLowerCase().indexOf("firefox");function s(e,t,n){e.addEventListener?e.addEventListener(t,n,!1):e.attachEvent&&e.attachEvent("on".concat(t),function(){n(window.event)})}function p(e,t){for(var n=t.slice(0,t.length-1),o=0;o<n.length;o++)n[o]=e[n[o].toLowerCase()];return n}function d(e){e||(e="");for(var t=(e=e.replace(/\s/g,"")).split(","),n=t.lastIndexOf("");0<=n;)t[n-1]+=",",t.splice(n,1),n=t.lastIndexOf("");return t}function l(e,t){for(var n=e.length<t.length?t:e,o=e.length<t.length?e:t,r=!0,i=0;i<n.length;i++)~o.indexOf(n[i])||(r=!1);return r}for(var t={backspace:8,tab:9,clear:12,enter:13,return:13,esc:27,escape:27,space:32,left:37,up:38,right:39,down:40,del:46,delete:46,ins:45,insert:45,home:36,end:35,pageup:33,pagedown:34,capslock:20,"\u21ea":20,",":188,".":190,"/":191,"`":192,"-":e?173:189,"=":e?61:187,";":e?59:186,"'":222,"[":219,"]":221,"\\":220},u={"\u21e7":16,shift:16,"\u2325":18,alt:18,option:18,"\u2303":17,ctrl:17,control:17,"\u2318":e?224:91,cmd:e?224:91,command:e?224:91},y={16:"shiftKey",18:"altKey",17:"ctrlKey"},h={16:!1,18:!1,17:!1},v={},n=1;n<20;n++)t["f".concat(n)]=111+n;h[e?224:91]=!(y[e?224:91]="metaKey");var g=[],o="all",w=[],k=function(e){return t[e.toLowerCase()]||u[e.toLowerCase()]||e.toUpperCase().charCodeAt(0)};function i(e){o=e||"all"}function m(){return o||"all"}function O(e,t,n){var o;if(t.scope===n||"all"===t.scope){for(var r in o=0<t.mods.length,h)Object.prototype.hasOwnProperty.call(h,r)&&(!h[r]&&-1<t.mods.indexOf(+r)||h[r]&&!~t.mods.indexOf(+r))&&(o=!1);(0!==t.mods.length||h[16]||h[18]||h[17]||h[91])&&!o&&"*"!==t.shortcut||!1===t.method(e,t)&&(e.preventDefault?e.preventDefault():e.returnValue=!1,e.stopPropagation&&e.stopPropagation(),e.cancelBubble&&(e.cancelBubble=!0))}}function b(e){var t=v["*"],n=e.keyCode||e.which||e.charCode;if(C.filter.call(this,e)){if(~g.indexOf(n)||229===n||g.push(n),93!==n&&224!==n||(n=91),n in h){for(var o in h[n]=!0,u)u[o]===n&&(C[o]=!0);if(!t)return}for(var r in h)Object.prototype.hasOwnProperty.call(h,r)&&(h[r]=e[y[r]]);var i=m();if(t)for(var a=0;a<t.length;a++)t[a].scope===i&&("keydown"===e.type&&t[a].keydown||"keyup"===e.type&&t[a].keyup)&&O(e,t[a],i);if(n in v)for(var c=0;c<v[n].length;c++)if(("keydown"===e.type&&v[n][c].keydown||"keyup"===e.type&&v[n][c].keyup)&&v[n][c].key){for(var f=v[n][c].key.split("+"),l=[],s=0;s<f.length;s++)l.push(k(f[s]));(l=l.sort()).join("")===g.sort().join("")&&O(e,v[n][c],i)}}}function C(e,t,n){var o=d(e),r=[],i="all",a=document,c=0,f=!1,l=!0;for(void 0===n&&"function"==typeof t&&(n=t),"[object Object]"===Object.prototype.toString.call(t)&&(t.scope&&(i=t.scope),t.element&&(a=t.element),t.keyup&&(f=t.keyup),void 0!==t.keydown&&(l=t.keydown)),"string"==typeof t&&(i=t);c<o.length;c++)r=[],1<(e=o[c].split("+")).length&&(r=p(u,e)),(e="*"===(e=e[e.length-1])?"*":k(e))in v||(v[e]=[]),v[e].push({keyup:f,keydown:l,scope:i,mods:r,shortcut:o[c],method:n,key:o[c]});void 0!==a&&!function(e){return-1<w.indexOf(e)}(a)&&window&&(w.push(a),s(a,"keydown",function(e){b(e)}),s(window,"focus",function(){g=[]}),s(a,"keyup",function(e){b(e),function(e){var t=e.keyCode||e.which||e.charCode,n=g.indexOf(t);if(n<0||g.splice(n,1),e.key&&"meta"==e.key.toLowerCase()&&g.splice(0,g.length),93!==t&&224!==t||(t=91),t in h)for(var o in h[t]=!1,u)u[o]===t&&(C[o]=!1)}(e)}))}var r={setScope:i,getScope:m,deleteScope:function(e,t){var n,o;for(var r in e||(e=m()),v)if(Object.prototype.hasOwnProperty.call(v,r))for(n=v[r],o=0;o<n.length;)n[o].scope===e?n.splice(o,1):o++;m()===e&&i(t||"all")},getPressedKeyCodes:function(){return g.slice(0)},isPressed:function(e){return"string"==typeof e&&(e=k(e)),!!~g.indexOf(e)},filter:function(e){var t=e.target||e.srcElement,n=t.tagName,o=!0;return!t.isContentEditable&&"TEXTAREA"!==n&&("INPUT"!==n&&"TEXTAREA"!==n||t.readOnly)||(o=!1),o},unbind:function(e,t,n){var o,r,i=d(e),a=[];"function"==typeof t&&(n=t,t="all");for(var c=0;c<i.length;c++){if(a=1<(o=i[c].split("+")).length?p(u,o):[],e="*"===(e=o[o.length-1])?"*":k(e),t||(t=m()),!v[e])return;for(var f=0;f<v[e].length;f++)r=v[e][f],n&&r.method!==n||r.scope!==t||!l(r.mods,a)||(v[e][f]={})}}};for(var a in r)Object.prototype.hasOwnProperty.call(r,a)&&(C[a]=r[a]);if("undefined"!=typeof window){var c=window.hotkeys;C.noConflict=function(e){return e&&window.hotkeys===C&&(window.hotkeys=c),C},window.hotkeys=C}return C});/**
 * @popperjs/core v2.10.2 - MIT License
 */

"use strict"; !function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).Popper = {}) }(this, (function (e) { function t(e, t) { return { width: (e = e.getBoundingClientRect()).width / 1, height: e.height / 1, top: e.top / 1, right: e.right / 1, bottom: e.bottom / 1, left: e.left / 1, x: e.left / 1, y: e.top / 1 } } function n(e) { return null == e ? window : "[object Window]" !== e.toString() ? (e = e.ownerDocument) && e.defaultView || window : e } function o(e) { return { scrollLeft: (e = n(e)).pageXOffset, scrollTop: e.pageYOffset } } function r(e) { return e instanceof n(e).Element || e instanceof Element } function i(e) { return e instanceof n(e).HTMLElement || e instanceof HTMLElement } function a(e) { return "undefined" != typeof ShadowRoot && (e instanceof n(e).ShadowRoot || e instanceof ShadowRoot) } function s(e) { return e ? (e.nodeName || "").toLowerCase() : null } function f(e) { return ((r(e) ? e.ownerDocument : e.document) || window.document).documentElement } function p(e) { return t(f(e)).left + o(e).scrollLeft } function c(e) { return n(e).getComputedStyle(e) } function l(e) { return e = c(e), /auto|scroll|overlay|hidden/.test(e.overflow + e.overflowY + e.overflowX) } function u(e, r, a) { void 0 === a && (a = !1); var c = i(r); i(r) && r.getBoundingClientRect(); var u = f(r); e = t(e); var d = { scrollLeft: 0, scrollTop: 0 }, m = { x: 0, y: 0 }; return (c || !c && !a) && (("body" !== s(r) || l(u)) && (d = r !== n(r) && i(r) ? { scrollLeft: r.scrollLeft, scrollTop: r.scrollTop } : o(r)), i(r) ? ((m = t(r)).x += r.clientLeft, m.y += r.clientTop) : u && (m.x = p(u))), { x: e.left + d.scrollLeft - m.x, y: e.top + d.scrollTop - m.y, width: e.width, height: e.height } } function d(e) { var n = t(e), o = e.offsetWidth, r = e.offsetHeight; return 1 >= Math.abs(n.width - o) && (o = n.width), 1 >= Math.abs(n.height - r) && (r = n.height), { x: e.offsetLeft, y: e.offsetTop, width: o, height: r } } function m(e) { return "html" === s(e) ? e : e.assignedSlot || e.parentNode || (a(e) ? e.host : null) || f(e) } function h(e) { return 0 <= ["html", "body", "#document"].indexOf(s(e)) ? e.ownerDocument.body : i(e) && l(e) ? e : h(m(e)) } function v(e, t) { var o; void 0 === t && (t = []); var r = h(e); return e = r === (null == (o = e.ownerDocument) ? void 0 : o.body), o = n(r), r = e ? [o].concat(o.visualViewport || [], l(r) ? r : []) : r, t = t.concat(r), e ? t : t.concat(v(m(r))) } function g(e) { return i(e) && "fixed" !== c(e).position ? e.offsetParent : null } function b(e) { for (var t = n(e), o = g(e); o && 0 <= ["table", "td", "th"].indexOf(s(o)) && "static" === c(o).position;)o = g(o); if (o && ("html" === s(o) || "body" === s(o) && "static" === c(o).position)) return t; if (!o) e: { if (o = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox"), -1 === navigator.userAgent.indexOf("Trident") || !i(e) || "fixed" !== c(e).position) for (e = m(e); i(e) && 0 > ["html", "body"].indexOf(s(e));) { var r = c(e); if ("none" !== r.transform || "none" !== r.perspective || "paint" === r.contain || -1 !== ["transform", "perspective"].indexOf(r.willChange) || o && "filter" === r.willChange || o && r.filter && "none" !== r.filter) { o = e; break e } e = e.parentNode } o = null } return o || t } function y(e) { function t(e) { o.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach((function (e) { o.has(e) || (e = n.get(e)) && t(e) })), r.push(e) } var n = new Map, o = new Set, r = []; return e.forEach((function (e) { n.set(e.name, e) })), e.forEach((function (e) { o.has(e.name) || t(e) })), r } function w(e) { var t; return function () { return t || (t = new Promise((function (n) { Promise.resolve().then((function () { t = void 0, n(e()) })) }))), t } } function x(e) { return e.split("-")[0] } function O(e, t) { var n = t.getRootNode && t.getRootNode(); if (e.contains(t)) return !0; if (n && a(n)) do { if (t && e.isSameNode(t)) return !0; t = t.parentNode || t.host } while (t); return !1 } function j(e) { return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }) } function E(e, r) { if ("viewport" === r) { r = n(e); var a = f(e); r = r.visualViewport; var s = a.clientWidth; a = a.clientHeight; var l = 0, u = 0; r && (s = r.width, a = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (l = r.offsetLeft, u = r.offsetTop)), e = j(e = { width: s, height: a, x: l + p(e), y: u }) } else i(r) ? ((e = t(r)).top += r.clientTop, e.left += r.clientLeft, e.bottom = e.top + r.clientHeight, e.right = e.left + r.clientWidth, e.width = r.clientWidth, e.height = r.clientHeight, e.x = e.left, e.y = e.top) : (u = f(e), e = f(u), s = o(u), r = null == (a = u.ownerDocument) ? void 0 : a.body, a = U(e.scrollWidth, e.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0), l = U(e.scrollHeight, e.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0), u = -s.scrollLeft + p(u), s = -s.scrollTop, "rtl" === c(r || e).direction && (u += U(e.clientWidth, r ? r.clientWidth : 0) - a), e = j({ width: a, height: l, x: u, y: s })); return e } function D(e, t, n) { return t = "clippingParents" === t ? function (e) { var t = v(m(e)), n = 0 <= ["absolute", "fixed"].indexOf(c(e).position) && i(e) ? b(e) : e; return r(n) ? t.filter((function (e) { return r(e) && O(e, n) && "body" !== s(e) })) : [] }(e) : [].concat(t), (n = (n = [].concat(t, [n])).reduce((function (t, n) { return n = E(e, n), t.top = U(n.top, t.top), t.right = z(n.right, t.right), t.bottom = z(n.bottom, t.bottom), t.left = U(n.left, t.left), t }), E(e, n[0]))).width = n.right - n.left, n.height = n.bottom - n.top, n.x = n.left, n.y = n.top, n } function L(e) { return e.split("-")[1] } function P(e) { return 0 <= ["top", "bottom"].indexOf(e) ? "x" : "y" } function M(e) { var t = e.reference, n = e.element, o = (e = e.placement) ? x(e) : null; e = e ? L(e) : null; var r = t.x + t.width / 2 - n.width / 2, i = t.y + t.height / 2 - n.height / 2; switch (o) { case "top": r = { x: r, y: t.y - n.height }; break; case "bottom": r = { x: r, y: t.y + t.height }; break; case "right": r = { x: t.x + t.width, y: i }; break; case "left": r = { x: t.x - n.width, y: i }; break; default: r = { x: t.x, y: t.y } }if (null != (o = o ? P(o) : null)) switch (i = "y" === o ? "height" : "width", e) { case "start": r[o] -= t[i] / 2 - n[i] / 2; break; case "end": r[o] += t[i] / 2 - n[i] / 2 }return r } function k(e) { return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, e) } function A(e, t) { return t.reduce((function (t, n) { return t[n] = e, t }), {}) } function B(e, n) { void 0 === n && (n = {}); var o = n; n = void 0 === (n = o.placement) ? e.placement : n; var i = o.boundary, a = void 0 === i ? "clippingParents" : i, s = void 0 === (i = o.rootBoundary) ? "viewport" : i; i = void 0 === (i = o.elementContext) ? "popper" : i; var p = o.altBoundary, c = void 0 !== p && p; o = k("number" != typeof (o = void 0 === (o = o.padding) ? 0 : o) ? o : A(o, N)), p = e.rects.popper, a = D(r(c = e.elements[c ? "popper" === i ? "reference" : "popper" : i]) ? c : c.contextElement || f(e.elements.popper), a, s), c = M({ reference: s = t(e.elements.reference), element: p, strategy: "absolute", placement: n }), p = j(Object.assign({}, p, c)), s = "popper" === i ? p : s; var l = { top: a.top - s.top + o.top, bottom: s.bottom - a.bottom + o.bottom, left: a.left - s.left + o.left, right: s.right - a.right + o.right }; if (e = e.modifiersData.offset, "popper" === i && e) { var u = e[n]; Object.keys(l).forEach((function (e) { var t = 0 <= ["right", "bottom"].indexOf(e) ? 1 : -1, n = 0 <= ["top", "bottom"].indexOf(e) ? "y" : "x"; l[e] += u[n] * t })) } return l } function W() { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return !t.some((function (e) { return !(e && "function" == typeof e.getBoundingClientRect) })) } function T(e) { void 0 === e && (e = {}); var t = e.defaultModifiers, n = void 0 === t ? [] : t, o = void 0 === (e = e.defaultOptions) ? X : e; return function (e, t, i) { function a() { f.forEach((function (e) { return e() })), f = [] } void 0 === i && (i = o); var s = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, X, o), modifiersData: {}, elements: { reference: e, popper: t }, attributes: {}, styles: {} }, f = [], p = !1, c = { state: s, setOptions: function (i) { return i = "function" == typeof i ? i(s.options) : i, a(), s.options = Object.assign({}, o, s.options, i), s.scrollParents = { reference: r(e) ? v(e) : e.contextElement ? v(e.contextElement) : [], popper: v(t) }, i = function (e) { var t = y(e); return _.reduce((function (e, n) { return e.concat(t.filter((function (e) { return e.phase === n }))) }), []) }(function (e) { var t = e.reduce((function (e, t) { var n = e[t.name]; return e[t.name] = n ? Object.assign({}, n, t, { options: Object.assign({}, n.options, t.options), data: Object.assign({}, n.data, t.data) }) : t, e }), {}); return Object.keys(t).map((function (e) { return t[e] })) }([].concat(n, s.options.modifiers))), s.orderedModifiers = i.filter((function (e) { return e.enabled })), s.orderedModifiers.forEach((function (e) { var t = e.name, n = e.options; n = void 0 === n ? {} : n, "function" == typeof (e = e.effect) && (t = e({ state: s, name: t, instance: c, options: n }), f.push(t || function () { })) })), c.update() }, forceUpdate: function () { if (!p) { var e = s.elements, t = e.reference; if (W(t, e = e.popper)) for (s.rects = { reference: u(t, b(e), "fixed" === s.options.strategy), popper: d(e) }, s.reset = !1, s.placement = s.options.placement, s.orderedModifiers.forEach((function (e) { return s.modifiersData[e.name] = Object.assign({}, e.data) })), t = 0; t < s.orderedModifiers.length; t++)if (!0 === s.reset) s.reset = !1, t = -1; else { var n = s.orderedModifiers[t]; e = n.fn; var o = n.options; o = void 0 === o ? {} : o, n = n.name, "function" == typeof e && (s = e({ state: s, options: o, name: n, instance: c }) || s) } } }, update: w((function () { return new Promise((function (e) { c.forceUpdate(), e(s) })) })), destroy: function () { a(), p = !0 } }; return W(e, t) ? (c.setOptions(i).then((function (e) { !p && i.onFirstUpdate && i.onFirstUpdate(e) })), c) : c } } function R(e) { var t, o = e.popper, r = e.popperRect, i = e.placement, a = e.variation, s = e.offsets, p = e.position, l = e.gpuAcceleration, u = e.adaptive; if (!0 === (e = e.roundOffsets)) { e = s.y; var d = window.devicePixelRatio || 1; e = { x: F(F(s.x * d) / d) || 0, y: F(F(e * d) / d) || 0 } } else e = "function" == typeof e ? e(s) : s; e = void 0 === (e = (d = e).x) ? 0 : e, d = void 0 === (d = d.y) ? 0 : d; var m = s.hasOwnProperty("x"); s = s.hasOwnProperty("y"); var h, v = "left", g = "top", y = window; if (u) { var w = b(o), x = "clientHeight", O = "clientWidth"; w === n(o) && ("static" !== c(w = f(o)).position && "absolute" === p && (x = "scrollHeight", O = "scrollWidth")), "top" !== i && ("left" !== i && "right" !== i || "end" !== a) || (g = "bottom", d -= w[x] - r.height, d *= l ? 1 : -1), "left" !== i && ("top" !== i && "bottom" !== i || "end" !== a) || (v = "right", e -= w[O] - r.width, e *= l ? 1 : -1) } return o = Object.assign({ position: p }, u && K), l ? Object.assign({}, o, ((h = {})[g] = s ? "0" : "", h[v] = m ? "0" : "", h.transform = 1 >= (y.devicePixelRatio || 1) ? "translate(" + e + "px, " + d + "px)" : "translate3d(" + e + "px, " + d + "px, 0)", h)) : Object.assign({}, o, ((t = {})[g] = s ? d + "px" : "", t[v] = m ? e + "px" : "", t.transform = "", t)) } function H(e) { return e.replace(/left|right|bottom|top/g, (function (e) { return ee[e] })) } function S(e) { return e.replace(/start|end/g, (function (e) { return te[e] })) } function C(e, t, n) { return void 0 === n && (n = { x: 0, y: 0 }), { top: e.top - t.height - n.y, right: e.right - t.width + n.x, bottom: e.bottom - t.height + n.y, left: e.left - t.width - n.x } } function q(e) { return ["top", "right", "bottom", "left"].some((function (t) { return 0 <= e[t] })) } var N = ["top", "bottom", "right", "left"], V = N.reduce((function (e, t) { return e.concat([t + "-start", t + "-end"]) }), []), I = [].concat(N, ["auto"]).reduce((function (e, t) { return e.concat([t, t + "-start", t + "-end"]) }), []), _ = "beforeRead read afterRead beforeMain main afterMain beforeWrite write afterWrite".split(" "), U = Math.max, z = Math.min, F = Math.round, X = { placement: "bottom", modifiers: [], strategy: "absolute" }, Y = { passive: !0 }, G = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: function (e) { var t = e.state, o = e.instance, r = (e = e.options).scroll, i = void 0 === r || r, a = void 0 === (e = e.resize) || e, s = n(t.elements.popper), f = [].concat(t.scrollParents.reference, t.scrollParents.popper); return i && f.forEach((function (e) { e.addEventListener("scroll", o.update, Y) })), a && s.addEventListener("resize", o.update, Y), function () { i && f.forEach((function (e) { e.removeEventListener("scroll", o.update, Y) })), a && s.removeEventListener("resize", o.update, Y) } }, data: {} }, J = { name: "popperOffsets", enabled: !0, phase: "read", fn: function (e) { var t = e.state; t.modifiersData[e.name] = M({ reference: t.rects.reference, element: t.rects.popper, strategy: "absolute", placement: t.placement }) }, data: {} }, K = { top: "auto", right: "auto", bottom: "auto", left: "auto" }, Q = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function (e) { var t = e.state, n = e.options; e = void 0 === (e = n.gpuAcceleration) || e; var o = n.adaptive; o = void 0 === o || o, n = void 0 === (n = n.roundOffsets) || n, e = { placement: x(t.placement), variation: L(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: e }, null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, R(Object.assign({}, e, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: o, roundOffsets: n })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, R(Object.assign({}, e, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: n })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement }) }, data: {} }, Z = { name: "applyStyles", enabled: !0, phase: "write", fn: function (e) { var t = e.state; Object.keys(t.elements).forEach((function (e) { var n = t.styles[e] || {}, o = t.attributes[e] || {}, r = t.elements[e]; i(r) && s(r) && (Object.assign(r.style, n), Object.keys(o).forEach((function (e) { var t = o[e]; !1 === t ? r.removeAttribute(e) : r.setAttribute(e, !0 === t ? "" : t) }))) })) }, effect: function (e) { var t = e.state, n = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function () { Object.keys(t.elements).forEach((function (e) { var o = t.elements[e], r = t.attributes[e] || {}; e = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce((function (e, t) { return e[t] = "", e }), {}), i(o) && s(o) && (Object.assign(o.style, e), Object.keys(r).forEach((function (e) { o.removeAttribute(e) }))) })) } }, requires: ["computeStyles"] }, $ = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function (e) { var t = e.state, n = e.name, o = void 0 === (e = e.options.offset) ? [0, 0] : e, r = (e = I.reduce((function (e, n) { var r = t.rects, i = x(n), a = 0 <= ["left", "top"].indexOf(i) ? -1 : 1, s = "function" == typeof o ? o(Object.assign({}, r, { placement: n })) : o; return r = (r = s[0]) || 0, s = ((s = s[1]) || 0) * a, i = 0 <= ["left", "right"].indexOf(i) ? { x: s, y: r } : { x: r, y: s }, e[n] = i, e }), {}))[t.placement], i = r.x; r = r.y, null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += i, t.modifiersData.popperOffsets.y += r), t.modifiersData[n] = e } }, ee = { left: "right", right: "left", bottom: "top", top: "bottom" }, te = { start: "end", end: "start" }, ne = { name: "flip", enabled: !0, phase: "main", fn: function (e) { var t = e.state, n = e.options; if (e = e.name, !t.modifiersData[e]._skip) { var o = n.mainAxis; o = void 0 === o || o; var r = n.altAxis; r = void 0 === r || r; var i = n.fallbackPlacements, a = n.padding, s = n.boundary, f = n.rootBoundary, p = n.altBoundary, c = n.flipVariations, l = void 0 === c || c, u = n.allowedAutoPlacements; c = x(n = t.options.placement), i = i || (c !== n && l ? function (e) { if ("auto" === x(e)) return []; var t = H(e); return [S(e), t, S(t)] }(n) : [H(n)]); var d = [n].concat(i).reduce((function (e, n) { return e.concat("auto" === x(n) ? function (e, t) { void 0 === t && (t = {}); var n = t.boundary, o = t.rootBoundary, r = t.padding, i = t.flipVariations, a = t.allowedAutoPlacements, s = void 0 === a ? I : a, f = L(t.placement); 0 === (i = (t = f ? i ? V : V.filter((function (e) { return L(e) === f })) : N).filter((function (e) { return 0 <= s.indexOf(e) }))).length && (i = t); var p = i.reduce((function (t, i) { return t[i] = B(e, { placement: i, boundary: n, rootBoundary: o, padding: r })[x(i)], t }), {}); return Object.keys(p).sort((function (e, t) { return p[e] - p[t] })) }(t, { placement: n, boundary: s, rootBoundary: f, padding: a, flipVariations: l, allowedAutoPlacements: u }) : n) }), []); n = t.rects.reference, i = t.rects.popper; var m = new Map; c = !0; for (var h = d[0], v = 0; v < d.length; v++) { var g = d[v], b = x(g), y = "start" === L(g), w = 0 <= ["top", "bottom"].indexOf(b), O = w ? "width" : "height", j = B(t, { placement: g, boundary: s, rootBoundary: f, altBoundary: p, padding: a }); if (y = w ? y ? "right" : "left" : y ? "bottom" : "top", n[O] > i[O] && (y = H(y)), O = H(y), w = [], o && w.push(0 >= j[b]), r && w.push(0 >= j[y], 0 >= j[O]), w.every((function (e) { return e }))) { h = g, c = !1; break } m.set(g, w) } if (c) for (o = function (e) { var t = d.find((function (t) { if (t = m.get(t)) return t.slice(0, e).every((function (e) { return e })) })); if (t) return h = t, "break" }, r = l ? 3 : 1; 0 < r && "break" !== o(r); r--); t.placement !== h && (t.modifiersData[e]._skip = !0, t.placement = h, t.reset = !0) } }, requiresIfExists: ["offset"], data: { _skip: !1 } }, oe = { name: "preventOverflow", enabled: !0, phase: "main", fn: function (e) { var t = e.state, n = e.options; e = e.name; var o = n.mainAxis, r = void 0 === o || o, i = void 0 !== (o = n.altAxis) && o; o = void 0 === (o = n.tether) || o; var a = n.tetherOffset, s = void 0 === a ? 0 : a, f = B(t, { boundary: n.boundary, rootBoundary: n.rootBoundary, padding: n.padding, altBoundary: n.altBoundary }); n = x(t.placement); var p = L(t.placement), c = !p, l = P(n); n = "x" === l ? "y" : "x", a = t.modifiersData.popperOffsets; var u = t.rects.reference, m = t.rects.popper, h = "function" == typeof s ? s(Object.assign({}, t.rects, { placement: t.placement })) : s; if (s = { x: 0, y: 0 }, a) { if (r || i) { var v = "y" === l ? "top" : "left", g = "y" === l ? "bottom" : "right", y = "y" === l ? "height" : "width", w = a[l], O = a[l] + f[v], j = a[l] - f[g], E = o ? -m[y] / 2 : 0, D = "start" === p ? u[y] : m[y]; p = "start" === p ? -m[y] : -u[y], m = t.elements.arrow, m = o && m ? d(m) : { width: 0, height: 0 }; var M = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }; v = M[v], g = M[g], m = U(0, z(u[y], m[y])), D = c ? u[y] / 2 - E - m - v - h : D - m - v - h, u = c ? -u[y] / 2 + E + m + g + h : p + m + g + h, c = t.elements.arrow && b(t.elements.arrow), h = t.modifiersData.offset ? t.modifiersData.offset[t.placement][l] : 0, c = a[l] + D - h - (c ? "y" === l ? c.clientTop || 0 : c.clientLeft || 0 : 0), u = a[l] + u - h, r && (r = o ? z(O, c) : O, j = o ? U(j, u) : j, r = U(r, z(w, j)), a[l] = r, s[l] = r - w), i && (r = (i = a[n]) + f["x" === l ? "top" : "left"], f = i - f["x" === l ? "bottom" : "right"], r = o ? z(r, c) : r, o = o ? U(f, u) : f, o = U(r, z(i, o)), a[n] = o, s[n] = o - i) } t.modifiersData[e] = s } }, requiresIfExists: ["offset"] }, re = { name: "arrow", enabled: !0, phase: "main", fn: function (e) { var t, n = e.state, o = e.name, r = e.options, i = n.elements.arrow, a = n.modifiersData.popperOffsets, s = x(n.placement); if (e = P(s), s = 0 <= ["left", "right"].indexOf(s) ? "height" : "width", i && a) { r = k("number" != typeof (r = "function" == typeof (r = r.padding) ? r(Object.assign({}, n.rects, { placement: n.placement })) : r) ? r : A(r, N)); var f = d(i), p = "y" === e ? "top" : "left", c = "y" === e ? "bottom" : "right", l = n.rects.reference[s] + n.rects.reference[e] - a[e] - n.rects.popper[s]; a = a[e] - n.rects.reference[e], a = (i = (i = b(i)) ? "y" === e ? i.clientHeight || 0 : i.clientWidth || 0 : 0) / 2 - f[s] / 2 + (l / 2 - a / 2), s = U(r[p], z(a, i - f[s] - r[c])), n.modifiersData[o] = ((t = {})[e] = s, t.centerOffset = s - a, t) } }, effect: function (e) { var t = e.state; if (null != (e = void 0 === (e = e.options.element) ? "[data-popper-arrow]" : e)) { if ("string" == typeof e && !(e = t.elements.popper.querySelector(e))) return; O(t.elements.popper, e) && (t.elements.arrow = e) } }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }, ie = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function (e) { var t = e.state; e = e.name; var n = t.rects.reference, o = t.rects.popper, r = t.modifiersData.preventOverflow, i = B(t, { elementContext: "reference" }), a = B(t, { altBoundary: !0 }); n = C(i, n), o = C(a, o, r), r = q(n), a = q(o), t.modifiersData[e] = { referenceClippingOffsets: n, popperEscapeOffsets: o, isReferenceHidden: r, hasPopperEscaped: a }, t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": r, "data-popper-escaped": a }) } }, ae = T({ defaultModifiers: [G, J, Q, Z] }), se = [G, J, Q, Z, $, ne, oe, re, ie], fe = T({ defaultModifiers: se }); e.applyStyles = Z, e.arrow = re, e.computeStyles = Q, e.createPopper = fe, e.createPopperLite = ae, e.defaultModifiers = se, e.detectOverflow = B, e.eventListeners = G, e.flip = ne, e.hide = ie, e.offset = $, e.popperGenerator = T, e.popperOffsets = J, e.preventOverflow = oe, Object.defineProperty(e, "__esModule", { value: !0 }) }));/* @tippyjs/core v6.3.2 - MIT License */
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e(require("@popperjs/core")) : "function" == typeof define && define.amd ? define(["@popperjs/core"], e) : (t = t || self).tippy = e(t.Popper) }(this, (function (t) { "use strict"; var e = "undefined" != typeof window && "undefined" != typeof document, n = !!e && !!window.msCrypto, r = { passive: !0, capture: !0 }, o = function () { return document.body }; function i(t, e, n) { if (Array.isArray(t)) { var r = t[e]; return null == r ? Array.isArray(n) ? n[e] : n : r } return t } function a(t, e) { var n = {}.toString.call(t); return 0 === n.indexOf("[object") && n.indexOf(e + "]") > -1 } function s(t, e) { return "function" == typeof t ? t.apply(void 0, e) : t } function u(t, e) { return 0 === e ? t : function (r) { clearTimeout(n), n = setTimeout((function () { t(r) }), e) }; var n } function p(t, e) { var n = Object.assign({}, t); return e.forEach((function (t) { delete n[t] })), n } function c(t) { return [].concat(t) } function f(t, e) { -1 === t.indexOf(e) && t.push(e) } function l(t) { return t.split("-")[0] } function d(t) { return [].slice.call(t) } function v() { return document.createElement("div") } function m(t) { return ["Element", "Fragment"].some((function (e) { return a(t, e) })) } function h(t) { return a(t, "MouseEvent") } function g(t) { return !(!t || !t._tippy || t._tippy.reference !== t) } function b(t) { return m(t) ? [t] : function (t) { return a(t, "NodeList") }(t) ? d(t) : Array.isArray(t) ? t : d(document.querySelectorAll(t)) } function y(t, e) { t.forEach((function (t) { t && (t.style.transitionDuration = e + "ms") })) } function w(t, e) { t.forEach((function (t) { t && t.setAttribute("data-state", e) })) } function x(t) { var e, n = c(t)[0]; return (null == n || null == (e = n.ownerDocument) ? void 0 : e.body) ? n.ownerDocument : document } function E(t, e, n) { var r = e + "EventListener";["transitionend", "webkitTransitionEnd"].forEach((function (e) { t[r](e, n) })) } function O(t, e) { for (var n = e; n;) { var r; if (t.contains(n)) return !0; n = null == (r = null == n.getRootNode ? void 0 : n.getRootNode()) ? void 0 : r.host } return !1 } var C = { isTouch: !1 }, T = 0; function A() { C.isTouch || (C.isTouch = !0, window.performance && document.addEventListener("mousemove", L)) } function L() { var t = performance.now(); t - T < 20 && (C.isTouch = !1, document.removeEventListener("mousemove", L)), T = t } function D() { var t = document.activeElement; if (g(t)) { var e = t._tippy; t.blur && !e.state.isVisible && t.blur() } } var k = Object.assign({ appendTo: o, aria: { content: "auto", expanded: "auto" }, delay: 0, duration: [300, 250], getReferenceClientRect: null, hideOnClick: !0, ignoreAttributes: !1, interactive: !1, interactiveBorder: 2, interactiveDebounce: 0, moveTransition: "", offset: [0, 10], onAfterUpdate: function () { }, onBeforeUpdate: function () { }, onCreate: function () { }, onDestroy: function () { }, onHidden: function () { }, onHide: function () { }, onMount: function () { }, onShow: function () { }, onShown: function () { }, onTrigger: function () { }, onUntrigger: function () { }, onClickOutside: function () { }, placement: "top", plugins: [], popperOptions: {}, render: null, showOnCreate: !1, touch: !0, trigger: "mouseenter focus", triggerTarget: null }, { animateFill: !1, followCursor: !1, inlinePositioning: !1, sticky: !1 }, {}, { allowHTML: !1, animation: "fade", arrow: !0, content: "", inertia: !1, maxWidth: 350, role: "tooltip", theme: "", zIndex: 9999 }), R = Object.keys(k); function P(t) { var e = (t.plugins || []).reduce((function (e, n) { var r, o = n.name, i = n.defaultValue; o && (e[o] = void 0 !== t[o] ? t[o] : null != (r = k[o]) ? r : i); return e }), {}); return Object.assign({}, t, {}, e) } function j(t, e) { var n = Object.assign({}, e, { content: s(e.content, [t]) }, e.ignoreAttributes ? {} : function (t, e) { return (e ? Object.keys(P(Object.assign({}, k, { plugins: e }))) : R).reduce((function (e, n) { var r = (t.getAttribute("data-tippy-" + n) || "").trim(); if (!r) return e; if ("content" === n) e[n] = r; else try { e[n] = JSON.parse(r) } catch (t) { e[n] = r } return e }), {}) }(t, e.plugins)); return n.aria = Object.assign({}, k.aria, {}, n.aria), n.aria = { expanded: "auto" === n.aria.expanded ? e.interactive : n.aria.expanded, content: "auto" === n.aria.content ? e.interactive ? null : "describedby" : n.aria.content }, n } function M(t, e) { t.innerHTML = e } function V(t) { var e = v(); return !0 === t ? e.className = "tippy-arrow" : (e.className = "tippy-svg-arrow", m(t) ? e.appendChild(t) : M(e, t)), e } function I(t, e) { m(e.content) ? (M(t, ""), t.appendChild(e.content)) : "function" != typeof e.content && (e.allowHTML ? M(t, e.content) : t.textContent = e.content) } function S(t) { var e = t.firstElementChild, n = d(e.children); return { box: e, content: n.find((function (t) { return t.classList.contains("tippy-content") })), arrow: n.find((function (t) { return t.classList.contains("tippy-arrow") || t.classList.contains("tippy-svg-arrow") })), backdrop: n.find((function (t) { return t.classList.contains("tippy-backdrop") })) } } function B(t) { var e = v(), n = v(); n.className = "tippy-box", n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1"); var r = v(); function o(n, r) { var o = S(e), i = o.box, a = o.content, s = o.arrow; r.theme ? i.setAttribute("data-theme", r.theme) : i.removeAttribute("data-theme"), "string" == typeof r.animation ? i.setAttribute("data-animation", r.animation) : i.removeAttribute("data-animation"), r.inertia ? i.setAttribute("data-inertia", "") : i.removeAttribute("data-inertia"), i.style.maxWidth = "number" == typeof r.maxWidth ? r.maxWidth + "px" : r.maxWidth, r.role ? i.setAttribute("role", r.role) : i.removeAttribute("role"), n.content === r.content && n.allowHTML === r.allowHTML || I(a, t.props), r.arrow ? s ? n.arrow !== r.arrow && (i.removeChild(s), i.appendChild(V(r.arrow))) : i.appendChild(V(r.arrow)) : s && i.removeChild(s) } return r.className = "tippy-content", r.setAttribute("data-state", "hidden"), I(r, t.props), e.appendChild(n), n.appendChild(r), o(t.props, t.props), { popper: e, onUpdate: o } } B.$$tippy = !0; var N = 1, H = [], U = []; function _(e, a) { var p, m, g, b, T, A, L, D, R, M = j(e, Object.assign({}, k, {}, P((p = a, Object.keys(p).reduce((function (t, e) { return void 0 !== p[e] && (t[e] = p[e]), t }), {}))))), V = !1, I = !1, B = !1, _ = !1, z = [], F = u(wt, M.interactiveDebounce), W = N++, X = (R = M.plugins).filter((function (t, e) { return R.indexOf(t) === e })), Y = { id: W, reference: e, popper: v(), popperInstance: null, props: M, state: { isEnabled: !0, isVisible: !1, isDestroyed: !1, isMounted: !1, isShown: !1 }, plugins: X, clearDelayTimeouts: function () { clearTimeout(m), clearTimeout(g), cancelAnimationFrame(b) }, setProps: function (t) { if (Y.state.isDestroyed) return; at("onBeforeUpdate", [Y, t]), bt(); var n = Y.props, r = j(e, Object.assign({}, Y.props, {}, t, { ignoreAttributes: !0 })); Y.props = r, gt(), n.interactiveDebounce !== r.interactiveDebounce && (pt(), F = u(wt, r.interactiveDebounce)); n.triggerTarget && !r.triggerTarget ? c(n.triggerTarget).forEach((function (t) { t.removeAttribute("aria-expanded") })) : r.triggerTarget && e.removeAttribute("aria-expanded"); ut(), it(), J && J(n, r); Y.popperInstance && (Ct(), At().forEach((function (t) { requestAnimationFrame(t._tippy.popperInstance.forceUpdate) }))); at("onAfterUpdate", [Y, t]) }, setContent: function (t) { Y.setProps({ content: t }) }, show: function () { var t = Y.state.isVisible, e = Y.state.isDestroyed, n = !Y.state.isEnabled, r = C.isTouch && !Y.props.touch, a = i(Y.props.duration, 0, k.duration); if (t || e || n || r) return; if (et().hasAttribute("disabled")) return; if (at("onShow", [Y], !1), !1 === Y.props.onShow(Y)) return; Y.state.isVisible = !0, tt() && ($.style.visibility = "visible"); it(), dt(), Y.state.isMounted || ($.style.transition = "none"); if (tt()) { var u = rt(), p = u.box, c = u.content; y([p, c], 0) } L = function () { var t; if (Y.state.isVisible && !_) { if (_ = !0, $.offsetHeight, $.style.transition = Y.props.moveTransition, tt() && Y.props.animation) { var e = rt(), n = e.box, r = e.content; y([n, r], a), w([n, r], "visible") } st(), ut(), f(U, Y), null == (t = Y.popperInstance) || t.forceUpdate(), Y.state.isMounted = !0, at("onMount", [Y]), Y.props.animation && tt() && function (t, e) { mt(t, e) }(a, (function () { Y.state.isShown = !0, at("onShown", [Y]) })) } }, function () { var t, e = Y.props.appendTo, n = et(); t = Y.props.interactive && e === o || "parent" === e ? n.parentNode : s(e, [n]); t.contains($) || t.appendChild($); Ct() }() }, hide: function () { var t = !Y.state.isVisible, e = Y.state.isDestroyed, n = !Y.state.isEnabled, r = i(Y.props.duration, 1, k.duration); if (t || e || n) return; if (at("onHide", [Y], !1), !1 === Y.props.onHide(Y)) return; Y.state.isVisible = !1, Y.state.isShown = !1, _ = !1, V = !1, tt() && ($.style.visibility = "hidden"); if (pt(), vt(), it(), tt()) { var o = rt(), a = o.box, s = o.content; Y.props.animation && (y([a, s], r), w([a, s], "hidden")) } st(), ut(), Y.props.animation ? tt() && function (t, e) { mt(t, (function () { !Y.state.isVisible && $.parentNode && $.parentNode.contains($) && e() })) }(r, Y.unmount) : Y.unmount() }, hideWithInteractivity: function (t) { nt().addEventListener("mousemove", F), f(H, F), F(t) }, enable: function () { Y.state.isEnabled = !0 }, disable: function () { Y.hide(), Y.state.isEnabled = !1 }, unmount: function () { Y.state.isVisible && Y.hide(); if (!Y.state.isMounted) return; Tt(), At().forEach((function (t) { t._tippy.unmount() })), $.parentNode && $.parentNode.removeChild($); U = U.filter((function (t) { return t !== Y })), Y.state.isMounted = !1, at("onHidden", [Y]) }, destroy: function () { if (Y.state.isDestroyed) return; Y.clearDelayTimeouts(), Y.unmount(), bt(), delete e._tippy, Y.state.isDestroyed = !0, at("onDestroy", [Y]) } }; if (!M.render) return Y; var q = M.render(Y), $ = q.popper, J = q.onUpdate; $.setAttribute("data-tippy-root", ""), $.id = "tippy-" + Y.id, Y.popper = $, e._tippy = Y, $._tippy = Y; var G = X.map((function (t) { return t.fn(Y) })), K = e.hasAttribute("aria-expanded"); return gt(), ut(), it(), at("onCreate", [Y]), M.showOnCreate && Lt(), $.addEventListener("mouseenter", (function () { Y.props.interactive && Y.state.isVisible && Y.clearDelayTimeouts() })), $.addEventListener("mouseleave", (function (t) { Y.props.interactive && Y.props.trigger.indexOf("mouseenter") >= 0 && (nt().addEventListener("mousemove", F), F(t)) })), Y; function Q() { var t = Y.props.touch; return Array.isArray(t) ? t : [t, 0] } function Z() { return "hold" === Q()[0] } function tt() { var t; return !!(null == (t = Y.props.render) ? void 0 : t.$$tippy) } function et() { return D || e } function nt() { var t = et().parentNode; return t ? x(t) : document } function rt() { return S($) } function ot(t) { return Y.state.isMounted && !Y.state.isVisible || C.isTouch || T && "focus" === T.type ? 0 : i(Y.props.delay, t ? 0 : 1, k.delay) } function it() { $.style.pointerEvents = Y.props.interactive && Y.state.isVisible ? "" : "none", $.style.zIndex = "" + Y.props.zIndex } function at(t, e, n) { var r; (void 0 === n && (n = !0), G.forEach((function (n) { n[t] && n[t].apply(void 0, e) })), n) && (r = Y.props)[t].apply(r, e) } function st() { var t = Y.props.aria; if (t.content) { var n = "aria-" + t.content, r = $.id; c(Y.props.triggerTarget || e).forEach((function (t) { var e = t.getAttribute(n); if (Y.state.isVisible) t.setAttribute(n, e ? e + " " + r : r); else { var o = e && e.replace(r, "").trim(); o ? t.setAttribute(n, o) : t.removeAttribute(n) } })) } } function ut() { !K && Y.props.aria.expanded && c(Y.props.triggerTarget || e).forEach((function (t) { Y.props.interactive ? t.setAttribute("aria-expanded", Y.state.isVisible && t === et() ? "true" : "false") : t.removeAttribute("aria-expanded") })) } function pt() { nt().removeEventListener("mousemove", F), H = H.filter((function (t) { return t !== F })) } function ct(t) { if (!C.isTouch || !B && "mousedown" !== t.type) { var e = t.composedPath && t.composedPath()[0] || t.target; if (!Y.props.interactive || !O($, e)) { if (O(et(), e)) { if (C.isTouch) return; if (Y.state.isVisible && Y.props.trigger.indexOf("click") >= 0) return } else at("onClickOutside", [Y, t]); !0 === Y.props.hideOnClick && (Y.clearDelayTimeouts(), Y.hide(), I = !0, setTimeout((function () { I = !1 })), Y.state.isMounted || vt()) } } } function ft() { B = !0 } function lt() { B = !1 } function dt() { var t = nt(); t.addEventListener("mousedown", ct, !0), t.addEventListener("touchend", ct, r), t.addEventListener("touchstart", lt, r), t.addEventListener("touchmove", ft, r) } function vt() { var t = nt(); t.removeEventListener("mousedown", ct, !0), t.removeEventListener("touchend", ct, r), t.removeEventListener("touchstart", lt, r), t.removeEventListener("touchmove", ft, r) } function mt(t, e) { var n = rt().box; function r(t) { t.target === n && (E(n, "remove", r), e()) } if (0 === t) return e(); E(n, "remove", A), E(n, "add", r), A = r } function ht(t, n, r) { void 0 === r && (r = !1), c(Y.props.triggerTarget || e).forEach((function (e) { e.addEventListener(t, n, r), z.push({ node: e, eventType: t, handler: n, options: r }) })) } function gt() { var t; Z() && (ht("touchstart", yt, { passive: !0 }), ht("touchend", xt, { passive: !0 })), (t = Y.props.trigger, t.split(/\s+/).filter(Boolean)).forEach((function (t) { if ("manual" !== t) switch (ht(t, yt), t) { case "mouseenter": ht("mouseleave", xt); break; case "focus": ht(n ? "focusout" : "blur", Et); break; case "focusin": ht("focusout", Et) } })) } function bt() { z.forEach((function (t) { var e = t.node, n = t.eventType, r = t.handler, o = t.options; e.removeEventListener(n, r, o) })), z = [] } function yt(t) { var e, n = !1; if (Y.state.isEnabled && !Ot(t) && !I) { var r = "focus" === (null == (e = T) ? void 0 : e.type); T = t, D = t.currentTarget, ut(), !Y.state.isVisible && h(t) && H.forEach((function (e) { return e(t) })), "click" === t.type && (Y.props.trigger.indexOf("mouseenter") < 0 || V) && !1 !== Y.props.hideOnClick && Y.state.isVisible ? n = !0 : Lt(t), "click" === t.type && (V = !n), n && !r && Dt(t) } } function wt(t) { var e = t.target, n = et().contains(e) || $.contains(e); "mousemove" === t.type && n || function (t, e) { var n = e.clientX, r = e.clientY; return t.every((function (t) { var e = t.popperRect, o = t.popperState, i = t.props.interactiveBorder, a = l(o.placement), s = o.modifiersData.offset; if (!s) return !0; var u = "bottom" === a ? s.top.y : 0, p = "top" === a ? s.bottom.y : 0, c = "right" === a ? s.left.x : 0, f = "left" === a ? s.right.x : 0, d = e.top - r + u > i, v = r - e.bottom - p > i, m = e.left - n + c > i, h = n - e.right - f > i; return d || v || m || h })) }(At().concat($).map((function (t) { var e, n = null == (e = t._tippy.popperInstance) ? void 0 : e.state; return n ? { popperRect: t.getBoundingClientRect(), popperState: n, props: M } : null })).filter(Boolean), t) && (pt(), Dt(t)) } function xt(t) { Ot(t) || Y.props.trigger.indexOf("click") >= 0 && V || (Y.props.interactive ? Y.hideWithInteractivity(t) : Dt(t)) } function Et(t) { Y.props.trigger.indexOf("focusin") < 0 && t.target !== et() || Y.props.interactive && t.relatedTarget && $.contains(t.relatedTarget) || Dt(t) } function Ot(t) { return !!C.isTouch && Z() !== t.type.indexOf("touch") >= 0 } function Ct() { Tt(); var n = Y.props, r = n.popperOptions, o = n.placement, i = n.offset, a = n.getReferenceClientRect, s = n.moveTransition, u = tt() ? S($).arrow : null, p = a ? { getBoundingClientRect: a, contextElement: a.contextElement || et() } : e, c = [{ name: "offset", options: { offset: i } }, { name: "preventOverflow", options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } } }, { name: "flip", options: { padding: 5 } }, { name: "computeStyles", options: { adaptive: !s } }, { name: "$$tippy", enabled: !0, phase: "beforeWrite", requires: ["computeStyles"], fn: function (t) { var e = t.state; if (tt()) { var n = rt().box;["placement", "reference-hidden", "escaped"].forEach((function (t) { "placement" === t ? n.setAttribute("data-placement", e.placement) : e.attributes.popper["data-popper-" + t] ? n.setAttribute("data-" + t, "") : n.removeAttribute("data-" + t) })), e.attributes.popper = {} } } }]; tt() && u && c.push({ name: "arrow", options: { element: u, padding: 3 } }), c.push.apply(c, (null == r ? void 0 : r.modifiers) || []), Y.popperInstance = t.createPopper(p, $, Object.assign({}, r, { placement: o, onFirstUpdate: L, modifiers: c })) } function Tt() { Y.popperInstance && (Y.popperInstance.destroy(), Y.popperInstance = null) } function At() { return d($.querySelectorAll("[data-tippy-root]")) } function Lt(t) { Y.clearDelayTimeouts(), t && at("onTrigger", [Y, t]), dt(); var e = ot(!0), n = Q(), r = n[0], o = n[1]; C.isTouch && "hold" === r && o && (e = o), e ? m = setTimeout((function () { Y.show() }), e) : Y.show() } function Dt(t) { if (Y.clearDelayTimeouts(), at("onUntrigger", [Y, t]), Y.state.isVisible) { if (!(Y.props.trigger.indexOf("mouseenter") >= 0 && Y.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(t.type) >= 0 && V)) { var e = ot(!1); e ? g = setTimeout((function () { Y.state.isVisible && Y.hide() }), e) : b = requestAnimationFrame((function () { Y.hide() })) } } else vt() } } function z(t, e) { void 0 === e && (e = {}); var n = k.plugins.concat(e.plugins || []); document.addEventListener("touchstart", A, r), window.addEventListener("blur", D); var o = Object.assign({}, e, { plugins: n }), i = b(t).reduce((function (t, e) { var n = e && _(e, o); return n && t.push(n), t }), []); return m(t) ? i[0] : i } z.defaultProps = k, z.setDefaultProps = function (t) { Object.keys(t).forEach((function (e) { k[e] = t[e] })) }, z.currentInput = C; var F = Object.assign({}, t.applyStyles, { effect: function (t) { var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow) } }), W = { mouseover: "mouseenter", focusin: "focus", click: "click" }; var X = { name: "animateFill", defaultValue: !1, fn: function (t) { var e; if (!(null == (e = t.props.render) ? void 0 : e.$$tippy)) return {}; var n = S(t.popper), r = n.box, o = n.content, i = t.props.animateFill ? function () { var t = v(); return t.className = "tippy-backdrop", w([t], "hidden"), t }() : null; return { onCreate: function () { i && (r.insertBefore(i, r.firstElementChild), r.setAttribute("data-animatefill", ""), r.style.overflow = "hidden", t.setProps({ arrow: !1, animation: "shift-away" })) }, onMount: function () { if (i) { var t = r.style.transitionDuration, e = Number(t.replace("ms", "")); o.style.transitionDelay = Math.round(e / 10) + "ms", i.style.transitionDuration = t, w([i], "visible") } }, onShow: function () { i && (i.style.transitionDuration = "0ms") }, onHide: function () { i && w([i], "hidden") } } } }; var Y = { clientX: 0, clientY: 0 }, q = []; function $(t) { var e = t.clientX, n = t.clientY; Y = { clientX: e, clientY: n } } var J = { name: "followCursor", defaultValue: !1, fn: function (t) { var e = t.reference, n = x(t.props.triggerTarget || e), r = !1, o = !1, i = !0, a = t.props; function s() { return "initial" === t.props.followCursor && t.state.isVisible } function u() { n.addEventListener("mousemove", f) } function p() { n.removeEventListener("mousemove", f) } function c() { r = !0, t.setProps({ getReferenceClientRect: null }), r = !1 } function f(n) { var r = !n.target || e.contains(n.target), o = t.props.followCursor, i = n.clientX, a = n.clientY, s = e.getBoundingClientRect(), u = i - s.left, p = a - s.top; !r && t.props.interactive || t.setProps({ getReferenceClientRect: function () { var t = e.getBoundingClientRect(), n = i, r = a; "initial" === o && (n = t.left + u, r = t.top + p); var s = "horizontal" === o ? t.top : r, c = "vertical" === o ? t.right : n, f = "horizontal" === o ? t.bottom : r, l = "vertical" === o ? t.left : n; return { width: c - l, height: f - s, top: s, right: c, bottom: f, left: l } } }) } function l() { t.props.followCursor && (q.push({ instance: t, doc: n }), function (t) { t.addEventListener("mousemove", $) }(n)) } function d() { 0 === (q = q.filter((function (e) { return e.instance !== t }))).filter((function (t) { return t.doc === n })).length && function (t) { t.removeEventListener("mousemove", $) }(n) } return { onCreate: l, onDestroy: d, onBeforeUpdate: function () { a = t.props }, onAfterUpdate: function (e, n) { var i = n.followCursor; r || void 0 !== i && a.followCursor !== i && (d(), i ? (l(), !t.state.isMounted || o || s() || u()) : (p(), c())) }, onMount: function () { t.props.followCursor && !o && (i && (f(Y), i = !1), s() || u()) }, onTrigger: function (t, e) { h(e) && (Y = { clientX: e.clientX, clientY: e.clientY }), o = "focus" === e.type }, onHidden: function () { t.props.followCursor && (c(), p(), i = !0) } } } }; var G = { name: "inlinePositioning", defaultValue: !1, fn: function (t) { var e, n = t.reference; var r = -1, o = !1, i = { name: "tippyInlinePositioning", enabled: !0, phase: "afterWrite", fn: function (o) { var i = o.state; t.props.inlinePositioning && (e !== i.placement && t.setProps({ getReferenceClientRect: function () { return function (t) { return function (t, e, n, r) { if (n.length < 2 || null === t) return e; if (2 === n.length && r >= 0 && n[0].left > n[1].right) return n[r] || e; switch (t) { case "top": case "bottom": var o = n[0], i = n[n.length - 1], a = "top" === t, s = o.top, u = i.bottom, p = a ? o.left : i.left, c = a ? o.right : i.right; return { top: s, bottom: u, left: p, right: c, width: c - p, height: u - s }; case "left": case "right": var f = Math.min.apply(Math, n.map((function (t) { return t.left }))), l = Math.max.apply(Math, n.map((function (t) { return t.right }))), d = n.filter((function (e) { return "left" === t ? e.left === f : e.right === l })), v = d[0].top, m = d[d.length - 1].bottom; return { top: v, bottom: m, left: f, right: l, width: l - f, height: m - v }; default: return e } }(l(t), n.getBoundingClientRect(), d(n.getClientRects()), r) }(i.placement) } }), e = i.placement) } }; function a() { var e; o || (e = function (t, e) { var n; return { popperOptions: Object.assign({}, t.popperOptions, { modifiers: [].concat(((null == (n = t.popperOptions) ? void 0 : n.modifiers) || []).filter((function (t) { return t.name !== e.name })), [e]) }) } }(t.props, i), o = !0, t.setProps(e), o = !1) } return { onCreate: a, onAfterUpdate: a, onTrigger: function (e, n) { if (h(n)) { var o = d(t.reference.getClientRects()), i = o.find((function (t) { return t.left - 2 <= n.clientX && t.right + 2 >= n.clientX && t.top - 2 <= n.clientY && t.bottom + 2 >= n.clientY })), a = o.indexOf(i); r = a > -1 ? a : r } }, onHidden: function () { r = -1 } } } }; var K = { name: "sticky", defaultValue: !1, fn: function (t) { var e = t.reference, n = t.popper; function r(e) { return !0 === t.props.sticky || t.props.sticky === e } var o = null, i = null; function a() { var s = r("reference") ? (t.popperInstance ? t.popperInstance.state.elements.reference : e).getBoundingClientRect() : null, u = r("popper") ? n.getBoundingClientRect() : null; (s && Q(o, s) || u && Q(i, u)) && t.popperInstance && t.popperInstance.update(), o = s, i = u, t.state.isMounted && requestAnimationFrame(a) } return { onMount: function () { t.props.sticky && a() } } } }; function Q(t, e) { return !t || !e || (t.top !== e.top || t.right !== e.right || t.bottom !== e.bottom || t.left !== e.left) } return e && function (t) { var e = document.createElement("style"); e.textContent = t, e.setAttribute("data-tippy-stylesheet", ""); var n = document.head, r = document.querySelector("head>style,head>link"); r ? n.insertBefore(e, r) : n.appendChild(e) }('.tippy-box[data-animation=fade][data-state=hidden]{opacity:0}[data-tippy-root]{max-width:calc(100vw - 10px)}.tippy-box{position:relative;background-color:#333;color:#fff;border-radius:4px;font-size:14px;line-height:1.4;white-space:normal;outline:0;transition-property:transform,visibility,opacity}.tippy-box[data-placement^=top]>.tippy-arrow{bottom:0}.tippy-box[data-placement^=top]>.tippy-arrow:before{bottom:-7px;left:0;border-width:8px 8px 0;border-top-color:initial;transform-origin:center top}.tippy-box[data-placement^=bottom]>.tippy-arrow{top:0}.tippy-box[data-placement^=bottom]>.tippy-arrow:before{top:-7px;left:0;border-width:0 8px 8px;border-bottom-color:initial;transform-origin:center bottom}.tippy-box[data-placement^=left]>.tippy-arrow{right:0}.tippy-box[data-placement^=left]>.tippy-arrow:before{border-width:8px 0 8px 8px;border-left-color:initial;right:-7px;transform-origin:center left}.tippy-box[data-placement^=right]>.tippy-arrow{left:0}.tippy-box[data-placement^=right]>.tippy-arrow:before{left:-7px;border-width:8px 8px 8px 0;border-right-color:initial;transform-origin:center right}.tippy-box[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-arrow{width:16px;height:16px;color:#333}.tippy-arrow:before{content:"";position:absolute;border-color:transparent;border-style:solid}.tippy-content{position:relative;padding:5px 9px;z-index:1}'), z.setDefaultProps({ plugins: [X, J, G, K], render: B }), z.createSingleton = function (t, e) { var n; void 0 === e && (e = {}); var r, o = t, i = [], a = e.overrides, s = [], u = !1; function c() { i = o.map((function (t) { return t.reference })) } function f(t) { o.forEach((function (e) { t ? e.enable() : e.disable() })) } function l(t) { return o.map((function (e) { var n = e.setProps; return e.setProps = function (o) { n(o), e.reference === r && t.setProps(o) }, function () { e.setProps = n } })) } function d(t, e) { var n = i.indexOf(e); if (e !== r) { r = e; var s = (a || []).concat("content").reduce((function (t, e) { return t[e] = o[n].props[e], t }), {}); t.setProps(Object.assign({}, s, { getReferenceClientRect: "function" == typeof s.getReferenceClientRect ? s.getReferenceClientRect : function () { return e.getBoundingClientRect() } })) } } f(!1), c(); var m = { fn: function () { return { onDestroy: function () { f(!0) }, onHidden: function () { r = null }, onClickOutside: function (t) { t.props.showOnCreate && !u && (u = !0, r = null) }, onShow: function (t) { t.props.showOnCreate && !u && (u = !0, d(t, i[0])) }, onTrigger: function (t, e) { d(t, e.currentTarget) } } } }, h = z(v(), Object.assign({}, p(e, ["overrides"]), { plugins: [m].concat(e.plugins || []), triggerTarget: i, popperOptions: Object.assign({}, e.popperOptions, { modifiers: [].concat((null == (n = e.popperOptions) ? void 0 : n.modifiers) || [], [F]) }) })), g = h.show; h.show = function (t) { if (g(), !r && null == t) return d(h, i[0]); if (!r || null != t) { if ("number" == typeof t) return i[t] && d(h, i[t]); if (o.indexOf(t) >= 0) { var e = t.reference; return d(h, e) } return i.indexOf(t) >= 0 ? d(h, t) : void 0 } }, h.showNext = function () { var t = i[0]; if (!r) return h.show(0); var e = i.indexOf(r); h.show(i[e + 1] || t) }, h.showPrevious = function () { var t = i[i.length - 1]; if (!r) return h.show(t); var e = i.indexOf(r), n = i[e - 1] || t; h.show(n) }; var b = h.setProps; return h.setProps = function (t) { a = t.overrides || a, b(t) }, h.setInstances = function (t) { f(!0), s.forEach((function (t) { return t() })), o = t, f(!1), c(), l(h), h.setProps({ triggerTarget: i }) }, s = l(h), h }, z.delegate = function (t, e) { var n = [], o = [], i = !1, a = e.target, s = p(e, ["target"]), u = Object.assign({}, s, { trigger: "manual", touch: !1 }), f = Object.assign({}, s, { showOnCreate: !0 }), l = z(t, u); function d(t) { if (t.target && !i) { var n = t.target.closest(a); if (n) { var r = n.getAttribute("data-tippy-trigger") || e.trigger || k.trigger; if (!n._tippy && !("touchstart" === t.type && "boolean" == typeof f.touch || "touchstart" !== t.type && r.indexOf(W[t.type]) < 0)) { var s = z(n, f); s && (o = o.concat(s)) } } } } function v(t, e, r, o) { void 0 === o && (o = !1), t.addEventListener(e, r, o), n.push({ node: t, eventType: e, handler: r, options: o }) } return c(l).forEach((function (t) { var e = t.destroy, a = t.enable, s = t.disable; t.destroy = function (t) { void 0 === t && (t = !0), t && o.forEach((function (t) { t.destroy() })), o = [], n.forEach((function (t) { var e = t.node, n = t.eventType, r = t.handler, o = t.options; e.removeEventListener(n, r, o) })), n = [], e() }, t.enable = function () { a(), o.forEach((function (t) { return t.enable() })), i = !1 }, t.disable = function () { s(), o.forEach((function (t) { return t.disable() })), i = !0 }, function (t) { var e = t.reference; v(e, "touchstart", d, r), v(e, "mouseover", d), v(e, "focusin", d), v(e, "click", d) }(t) })), l }, z.hideAll = function (t) { var e = void 0 === t ? {} : t, n = e.exclude, r = e.duration; U.forEach((function (t) { var e = !1; if (n && (e = g(n) ? t.reference === n : t.popper === n.popper), !e) { var o = t.props.duration; t.setProps({ duration: r }), t.hide(), t.state.isDestroyed || t.setProps({ duration: o }) } })) }, z.roundArrow = '<svg width="16" height="6" xmlns="http://www.w3.org/2000/svg"><path d="M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z"></svg>', z }));/*!
 * Masonry PACKAGED v4.2.2
 * Cascading grid layout library
 * https://masonry.desandro.com
 * MIT License
 * by David DeSandro
 * modified by Curiosity to remove require and jquery 
 */
!function (t, i) { t.EvEmitter = function () { function t() { } var i = t.prototype; return i.on = function (t, i) { if (t && i) { var e = this._events = this._events || {}, n = e[t] = e[t] || []; return -1 == n.indexOf(i) && n.push(i), this } }, i.once = function (t, i) { if (t && i) { this.on(t, i); var e = this._onceEvents = this._onceEvents || {}; return (e[t] = e[t] || {})[i] = !0, this } }, i.off = function (t, i) { var e = this._events && this._events[t]; if (e && e.length) { var n = e.indexOf(i); return -1 != n && e.splice(n, 1), this } }, i.emitEvent = function (t, i) { var e = this._events && this._events[t]; if (e && e.length) { e = e.slice(0), i = i || []; for (var n = this._onceEvents && this._onceEvents[t], o = 0; o < e.length; o++) { var s = e[o]; n && n[s] && (this.off(t, s), delete n[s]), s.apply(this, i) } return this } }, i.allOff = function () { delete this._events, delete this._onceEvents }, t }() }("undefined" != typeof window ? window : this), function (t, i) { t.getSize = function () { "use strict"; function t(t) { var i = parseFloat(t), e = -1 == t.indexOf("%") && !isNaN(i); return e && i } var i = "undefined" == typeof console ? function () { } : function (t) { console.error(t) }, e = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"], n = e.length; function o(t) { var e = getComputedStyle(t); return e || i("Style returned " + e + ". Are you running this code in a hidden iframe on Firefox? See https://bit.ly/getsizebug1"), e } var s, r = !1; function a(i) { if (function () { if (r) return; r = !0; var i = document.createElement("div"); i.style.width = "200px", i.style.padding = "1px 2px 3px 4px", i.style.borderStyle = "solid", i.style.borderWidth = "1px 2px 3px 4px", i.style.boxSizing = "border-box"; var e = document.body || document.documentElement; e.appendChild(i); var n = o(i); s = 200 == Math.round(t(n.width)), a.isBoxSizeOuter = s, e.removeChild(i) }(), "string" == typeof i && (i = document.querySelector(i)), i && "object" == typeof i && i.nodeType) { var h = o(i); if ("none" == h.display) return function () { for (var t = { width: 0, height: 0, innerWidth: 0, innerHeight: 0, outerWidth: 0, outerHeight: 0 }, i = 0; i < n; i++) { var o = e[i]; t[o] = 0 } return t }(); var u = {}; u.width = i.offsetWidth, u.height = i.offsetHeight; for (var l = u.isBorderBox = "border-box" == h.boxSizing, d = 0; d < n; d++) { var c = e[d], f = h[c], m = parseFloat(f); u[c] = isNaN(m) ? 0 : m } var p = u.paddingLeft + u.paddingRight, g = u.paddingTop + u.paddingBottom, v = u.marginLeft + u.marginRight, y = u.marginTop + u.marginBottom, _ = u.borderLeftWidth + u.borderRightWidth, E = u.borderTopWidth + u.borderBottomWidth, z = l && s, b = t(h.width); !1 !== b && (u.width = b + (z ? 0 : p + _)); var T = t(h.height); return !1 !== T && (u.height = T + (z ? 0 : g + E)), u.innerWidth = u.width - (p + _), u.innerHeight = u.height - (g + E), u.outerWidth = u.width + v, u.outerHeight = u.height + y, u } } return a }() }(window), function (t, i) { "use strict"; t.matchesSelector = i() }(window, function () { "use strict"; var t = function () { var t = window.Element.prototype; if (t.matches) return "matches"; if (t.matchesSelector) return "matchesSelector"; for (var i = ["webkit", "moz", "ms", "o"], e = 0; e < i.length; e++) { var n = i[e] + "MatchesSelector"; if (t[n]) return n } }(); return function (i, e) { return i[t](e) } }), function (t, i) { t.fizzyUIUtils = function (t, i) { var e = { extend: function (t, i) { for (var e in i) t[e] = i[e]; return t }, modulo: function (t, i) { return (t % i + i) % i } }, n = Array.prototype.slice; e.makeArray = function (t) { if (Array.isArray(t)) return t; if (null == t) return []; var i = "object" == typeof t && "number" == typeof t.length; return i ? n.call(t) : [t] }, e.removeFrom = function (t, i) { var e = t.indexOf(i); -1 != e && t.splice(e, 1) }, e.getParent = function (t, e) { for (; t.parentNode && t != document.body;)if (t = t.parentNode, i(t, e)) return t }, e.getQueryElement = function (t) { return "string" == typeof t ? document.querySelector(t) : t }, e.handleEvent = function (t) { var i = "on" + t.type; this[i] && this[i](t) }, e.filterFindElements = function (t, n) { t = e.makeArray(t); var o = []; return t.forEach(function (t) { if (t instanceof HTMLElement) if (n) { i(t, n) && o.push(t); for (var e = t.querySelectorAll(n), s = 0; s < e.length; s++)o.push(e[s]) } else o.push(t) }), o }, e.debounceMethod = function (t, i, e) { e = e || 100; var n = t.prototype[i], o = i + "Timeout"; t.prototype[i] = function () { var t = this[o]; clearTimeout(t); var i = arguments, s = this; this[o] = setTimeout(function () { n.apply(s, i), delete s[o] }, e) } }, e.docReady = function (t) { var i = document.readyState; "complete" == i || "interactive" == i ? setTimeout(t) : document.addEventListener("DOMContentLoaded", t) }, e.toDashed = function (t) { return t.replace(/(.)([A-Z])/g, function (t, i, e) { return i + "-" + e }).toLowerCase() }; var o = t.console; return e.htmlInit = function (t, i) { e.docReady(function () { var n = e.toDashed(i), s = "data-" + n, r = document.querySelectorAll("[" + s + "]"), a = document.querySelectorAll(".js-" + n), h = e.makeArray(r).concat(e.makeArray(a)), u = s + "-options"; h.forEach(function (i) { var e, n = i.getAttribute(s) || i.getAttribute(u); try { e = n && JSON.parse(n) } catch (t) { return void (o && o.error("Error parsing " + s + " on " + i.className + ": " + t)) } new t(i, e) }) }) }, e }(t, t.matchesSelector) }(window), function (t, i) { t.Outlayer = {}, t.Outlayer.Item = function (t, i) { "use strict"; var e = document.documentElement.style, n = "string" == typeof e.transition ? "transition" : "WebkitTransition", o = "string" == typeof e.transform ? "transform" : "WebkitTransform", s = { WebkitTransition: "webkitTransitionEnd", transition: "transitionend" }[n], r = { transform: o, transition: n, transitionDuration: n + "Duration", transitionProperty: n + "Property", transitionDelay: n + "Delay" }; function a(t, i) { t && (this.element = t, this.layout = i, this.position = { x: 0, y: 0 }, this._create()) } var h = a.prototype = Object.create(t.prototype); h.constructor = a, h._create = function () { this._transn = { ingProperties: {}, clean: {}, onEnd: {} }, this.css({ position: "absolute" }) }, h.handleEvent = function (t) { var i = "on" + t.type; this[i] && this[i](t) }, h.getSize = function () { this.size = i(this.element) }, h.css = function (t) { var i = this.element.style; for (var e in t) { var n = r[e] || e; i[n] = t[e] } }, h.getPosition = function () { var t = getComputedStyle(this.element), i = this.layout._getOption("originLeft"), e = this.layout._getOption("originTop"), n = t[i ? "left" : "right"], o = t[e ? "top" : "bottom"], s = parseFloat(n), r = parseFloat(o), a = this.layout.size; -1 != n.indexOf("%") && (s = s / 100 * a.width), -1 != o.indexOf("%") && (r = r / 100 * a.height), s = isNaN(s) ? 0 : s, r = isNaN(r) ? 0 : r, s -= i ? a.paddingLeft : a.paddingRight, r -= e ? a.paddingTop : a.paddingBottom, this.position.x = s, this.position.y = r }, h.layoutPosition = function () { var t = this.layout.size, i = {}, e = this.layout._getOption("originLeft"), n = this.layout._getOption("originTop"), o = e ? "paddingLeft" : "paddingRight", s = e ? "left" : "right", r = e ? "right" : "left", a = this.position.x + t[o]; i[s] = this.getXValue(a), i[r] = ""; var h = n ? "paddingTop" : "paddingBottom", u = n ? "top" : "bottom", l = n ? "bottom" : "top", d = this.position.y + t[h]; i[u] = this.getYValue(d), i[l] = "", this.css(i), this.emitEvent("layout", [this]) }, h.getXValue = function (t) { var i = this.layout._getOption("horizontal"); return this.layout.options.percentPosition && !i ? t / this.layout.size.width * 100 + "%" : t + "px" }, h.getYValue = function (t) { var i = this.layout._getOption("horizontal"); return this.layout.options.percentPosition && i ? t / this.layout.size.height * 100 + "%" : t + "px" }, h._transitionTo = function (t, i) { this.getPosition(); var e = this.position.x, n = this.position.y, o = t == this.position.x && i == this.position.y; if (this.setPosition(t, i), !o || this.isTransitioning) { var s = t - e, r = i - n, a = {}; a.transform = this.getTranslate(s, r), this.transition({ to: a, onTransitionEnd: { transform: this.layoutPosition }, isCleaning: !0 }) } else this.layoutPosition() }, h.getTranslate = function (t, i) { var e = this.layout._getOption("originLeft"), n = this.layout._getOption("originTop"); return "translate3d(" + (t = e ? t : -t) + "px, " + (i = n ? i : -i) + "px, 0)" }, h.goTo = function (t, i) { this.setPosition(t, i), this.layoutPosition() }, h.moveTo = h._transitionTo, h.setPosition = function (t, i) { this.position.x = parseFloat(t), this.position.y = parseFloat(i) }, h._nonTransition = function (t) { for (var i in this.css(t.to), t.isCleaning && this._removeStyles(t.to), t.onTransitionEnd) t.onTransitionEnd[i].call(this) }, h.transition = function (t) { if (parseFloat(this.layout.options.transitionDuration)) { var i = this._transn; for (var e in t.onTransitionEnd) i.onEnd[e] = t.onTransitionEnd[e]; for (e in t.to) i.ingProperties[e] = !0, t.isCleaning && (i.clean[e] = !0); if (t.from) { this.css(t.from); this.element.offsetHeight; null } this.enableTransition(t.to), this.css(t.to), this.isTransitioning = !0 } else this._nonTransition(t) }; var u = "opacity," + (l = o, l.replace(/([A-Z])/g, function (t) { return "-" + t.toLowerCase() })); var l; h.enableTransition = function () { if (!this.isTransitioning) { var t = this.layout.options.transitionDuration; t = "number" == typeof t ? t + "ms" : t, this.css({ transitionProperty: u, transitionDuration: t, transitionDelay: this.staggerDelay || 0 }), this.element.addEventListener(s, this, !1) } }, h.onwebkitTransitionEnd = function (t) { this.ontransitionend(t) }, h.onotransitionend = function (t) { this.ontransitionend(t) }; var d = { "-webkit-transform": "transform" }; h.ontransitionend = function (t) { if (t.target === this.element) { var i = this._transn, e = d[t.propertyName] || t.propertyName; if (delete i.ingProperties[e], function (t) { for (var i in t) return !1; return null, !0 }(i.ingProperties) && this.disableTransition(), e in i.clean && (this.element.style[t.propertyName] = "", delete i.clean[e]), e in i.onEnd) { var n = i.onEnd[e]; n.call(this), delete i.onEnd[e] } this.emitEvent("transitionEnd", [this]) } }, h.disableTransition = function () { this.removeTransitionStyles(), this.element.removeEventListener(s, this, !1), this.isTransitioning = !1 }, h._removeStyles = function (t) { var i = {}; for (var e in t) i[e] = ""; this.css(i) }; var c = { transitionProperty: "", transitionDuration: "", transitionDelay: "" }; return h.removeTransitionStyles = function () { this.css(c) }, h.stagger = function (t) { t = isNaN(t) ? 0 : t, this.staggerDelay = t + "ms" }, h.removeElem = function () { this.element.parentNode.removeChild(this.element), this.css({ display: "" }), this.emitEvent("remove", [this]) }, h.remove = function () { n && parseFloat(this.layout.options.transitionDuration) ? (this.once("transitionEnd", function () { this.removeElem() }), this.hide()) : this.removeElem() }, h.reveal = function () { delete this.isHidden, this.css({ display: "" }); var t = this.layout.options, i = {}; i[this.getHideRevealTransitionEndProperty("visibleStyle")] = this.onRevealTransitionEnd, this.transition({ from: t.hiddenStyle, to: t.visibleStyle, isCleaning: !0, onTransitionEnd: i }) }, h.onRevealTransitionEnd = function () { this.isHidden || this.emitEvent("reveal") }, h.getHideRevealTransitionEndProperty = function (t) { var i = this.layout.options[t]; if (i.opacity) return "opacity"; for (var e in i) return e }, h.hide = function () { this.isHidden = !0, this.css({ display: "" }); var t = this.layout.options, i = {}; i[this.getHideRevealTransitionEndProperty("hiddenStyle")] = this.onHideTransitionEnd, this.transition({ from: t.visibleStyle, to: t.hiddenStyle, isCleaning: !0, onTransitionEnd: i }) }, h.onHideTransitionEnd = function () { this.isHidden && (this.css({ display: "none" }), this.emitEvent("hide")) }, h.destroy = function () { this.css({ position: "", left: "", right: "", top: "", bottom: "", transition: "", transform: "" }) }, a }(t.EvEmitter, t.getSize) }(window), function (t, i) { "use strict"; t.Outlayer = function (t, i, e, n, o) { var s = t.console, r = function () { }, a = 0, h = {}; function u(t, i) { var e = n.getQueryElement(t); if (e) { this.element = e, this.options = n.extend({}, this.constructor.defaults), this.option(i); var o = ++a; this.element.outlayerGUID = o, h[o] = this, this._create(); var r = this._getOption("initLayout"); r && this.layout() } else s && s.error("Bad element for " + this.constructor.namespace + ": " + (e || t)) } u.namespace = "outlayer", u.Item = o, u.defaults = { containerStyle: { position: "relative" }, initLayout: !0, originLeft: !0, originTop: !0, resize: !0, resizeContainer: !0, transitionDuration: "0.4s", hiddenStyle: { opacity: 0, transform: "scale(0.001)" }, visibleStyle: { opacity: 1, transform: "scale(1)" } }; var l = u.prototype; function d(t) { function i() { t.apply(this, arguments) } return i.prototype = Object.create(t.prototype), i.prototype.constructor = i, i } n.extend(l, i.prototype), l.option = function (t) { n.extend(this.options, t) }, l._getOption = function (t) { var i = this.constructor.compatOptions[t]; return i && void 0 !== this.options[i] ? this.options[i] : this.options[t] }, u.compatOptions = { initLayout: "isInitLayout", horizontal: "isHorizontal", layoutInstant: "isLayoutInstant", originLeft: "isOriginLeft", originTop: "isOriginTop", resize: "isResizeBound", resizeContainer: "isResizingContainer" }, l._create = function () { this.reloadItems(), this.stamps = [], this.stamp(this.options.stamp), n.extend(this.element.style, this.options.containerStyle); var t = this._getOption("resize"); t && this.bindResize() }, l.reloadItems = function () { this.items = this._itemize(this.element.children) }, l._itemize = function (t) { for (var i = this._filterFindItemElements(t), e = this.constructor.Item, n = [], o = 0; o < i.length; o++) { var s = i[o], r = new e(s, this); n.push(r) } return n }, l._filterFindItemElements = function (t) { return n.filterFindElements(t, this.options.itemSelector) }, l.getItemElements = function () { return this.items.map(function (t) { return t.element }) }, l.layout = function () { this._resetLayout(), this._manageStamps(); var t = this._getOption("layoutInstant"), i = void 0 !== t ? t : !this._isLayoutInited; this.layoutItems(this.items, i), this._isLayoutInited = !0 }, l._init = l.layout, l._resetLayout = function () { this.getSize() }, l.getSize = function () { this.size = e(this.element) }, l._getMeasurement = function (t, i) { var n, o = this.options[t]; o ? ("string" == typeof o ? n = this.element.querySelector(o) : o instanceof HTMLElement && (n = o), this[t] = n ? e(n)[i] : o) : this[t] = 0 }, l.layoutItems = function (t, i) { t = this._getItemsForLayout(t), this._layoutItems(t, i), this._postLayout() }, l._getItemsForLayout = function (t) { return t.filter(function (t) { return !t.isIgnored }) }, l._layoutItems = function (t, i) { if (this._emitCompleteOnItems("layout", t), t && t.length) { var e = []; t.forEach(function (t) { var n = this._getItemLayoutPosition(t); n.item = t, n.isInstant = i || t.isLayoutInstant, e.push(n) }, this), this._processLayoutQueue(e) } }, l._getItemLayoutPosition = function () { return { x: 0, y: 0 } }, l._processLayoutQueue = function (t) { this.updateStagger(), t.forEach(function (t, i) { this._positionItem(t.item, t.x, t.y, t.isInstant, i) }, this) }, l.updateStagger = function () { var t = this.options.stagger; if (null != t) return this.stagger = function (t) { if ("number" == typeof t) return t; var i = t.match(/(^\d*\.?\d*)(\w*)/), e = i && i[1], n = i && i[2]; if (!e.length) return 0; e = parseFloat(e); var o = c[n] || 1; return e * o }(t), this.stagger; this.stagger = 0 }, l._positionItem = function (t, i, e, n, o) { n ? t.goTo(i, e) : (t.stagger(o * this.stagger), t.moveTo(i, e)) }, l._postLayout = function () { this.resizeContainer() }, l.resizeContainer = function () { var t = this._getOption("resizeContainer"); if (t) { var i = this._getContainerSize(); i && (this._setContainerMeasure(i.width, !0), this._setContainerMeasure(i.height, !1)) } }, l._getContainerSize = r, l._setContainerMeasure = function (t, i) { if (void 0 !== t) { var e = this.size; e.isBorderBox && (t += i ? e.paddingLeft + e.paddingRight + e.borderLeftWidth + e.borderRightWidth : e.paddingBottom + e.paddingTop + e.borderTopWidth + e.borderBottomWidth), t = Math.max(t, 0), this.element.style[i ? "width" : "height"] = t + "px" } }, l._emitCompleteOnItems = function (t, i) { var e = this; function n() { e.dispatchEvent(t + "Complete", null, [i]) } var o = i.length; if (i && o) { var s = 0; i.forEach(function (i) { i.once(t, r) }) } else n(); function r() { ++s == o && n() } }, l.dispatchEvent = function (t, i, e) { var n = i ? [i].concat(e) : e; this.emitEvent(t, n) }, l.ignore = function (t) { var i = this.getItem(t); i && (i.isIgnored = !0) }, l.unignore = function (t) { var i = this.getItem(t); i && delete i.isIgnored }, l.stamp = function (t) { (t = this._find(t)) && (this.stamps = this.stamps.concat(t), t.forEach(this.ignore, this)) }, l.unstamp = function (t) { (t = this._find(t)) && t.forEach(function (t) { n.removeFrom(this.stamps, t), this.unignore(t) }, this) }, l._find = function (t) { if (t) return "string" == typeof t && (t = this.element.querySelectorAll(t)), t = n.makeArray(t) }, l._manageStamps = function () { this.stamps && this.stamps.length && (this._getBoundingRect(), this.stamps.forEach(this._manageStamp, this)) }, l._getBoundingRect = function () { var t = this.element.getBoundingClientRect(), i = this.size; this._boundingRect = { left: t.left + i.paddingLeft + i.borderLeftWidth, top: t.top + i.paddingTop + i.borderTopWidth, right: t.right - (i.paddingRight + i.borderRightWidth), bottom: t.bottom - (i.paddingBottom + i.borderBottomWidth) } }, l._manageStamp = r, l._getElementOffset = function (t) { var i = t.getBoundingClientRect(), n = this._boundingRect, o = e(t), s = { left: i.left - n.left - o.marginLeft, top: i.top - n.top - o.marginTop, right: n.right - i.right - o.marginRight, bottom: n.bottom - i.bottom - o.marginBottom }; return s }, l.handleEvent = n.handleEvent, l.bindResize = function () { t.addEventListener("resize", this), this.isResizeBound = !0 }, l.unbindResize = function () { t.removeEventListener("resize", this), this.isResizeBound = !1 }, l.onresize = function () { this.resize() }, n.debounceMethod(u, "onresize", 100), l.resize = function () { this.isResizeBound && this.needsResizeLayout() && this.layout() }, l.needsResizeLayout = function () { var t = e(this.element), i = this.size && t; return i && t.innerWidth !== this.size.innerWidth }, l.addItems = function (t) { var i = this._itemize(t); return i.length && (this.items = this.items.concat(i)), i }, l.appended = function (t) { var i = this.addItems(t); i.length && (this.layoutItems(i, !0), this.reveal(i)) }, l.prepended = function (t) { var i = this._itemize(t); if (i.length) { var e = this.items.slice(0); this.items = i.concat(e), this._resetLayout(), this._manageStamps(), this.layoutItems(i, !0), this.reveal(i), this.layoutItems(e) } }, l.reveal = function (t) { if (this._emitCompleteOnItems("reveal", t), t && t.length) { var i = this.updateStagger(); t.forEach(function (t, e) { t.stagger(e * i), t.reveal() }) } }, l.hide = function (t) { if (this._emitCompleteOnItems("hide", t), t && t.length) { var i = this.updateStagger(); t.forEach(function (t, e) { t.stagger(e * i), t.hide() }) } }, l.revealItemElements = function (t) { var i = this.getItems(t); this.reveal(i) }, l.hideItemElements = function (t) { var i = this.getItems(t); this.hide(i) }, l.getItem = function (t) { for (var i = 0; i < this.items.length; i++) { var e = this.items[i]; if (e.element == t) return e } }, l.getItems = function (t) { t = n.makeArray(t); var i = []; return t.forEach(function (t) { var e = this.getItem(t); e && i.push(e) }, this), i }, l.remove = function (t) { var i = this.getItems(t); this._emitCompleteOnItems("remove", i), i && i.length && i.forEach(function (t) { t.remove(), n.removeFrom(this.items, t) }, this) }, l.destroy = function () { var t = this.element.style; t.height = "", t.position = "", t.width = "", this.items.forEach(function (t) { t.destroy() }), this.unbindResize(); var i = this.element.outlayerGUID; delete h[i], delete this.element.outlayerGUID, jQuery && jQuery.removeData(this.element, this.constructor.namespace) }, u.data = function (t) { var i = (t = n.getQueryElement(t)) && t.outlayerGUID; return i && h[i] }, u.create = function (t, i) { var e = d(u); return e.defaults = n.extend({}, u.defaults), n.extend(e.defaults, i), e.compatOptions = n.extend({}, u.compatOptions), e.namespace = t, e.data = u.data, e.Item = d(o), n.htmlInit(e, t), e }; var c = { ms: 1, s: 1e3 }; return u.Item = o, u }(t, t.EvEmitter, t.getSize, t.fizzyUIUtils, t.Outlayer.Item) }(window), function (t, i) { t.Masonry = function (t, i) { var e = t.create("masonry"); e.compatOptions.fitWidth = "isFitWidth"; var n = e.prototype; return n._resetLayout = function () { this.getSize(), this._getMeasurement("columnWidth", "outerWidth"), this._getMeasurement("gutter", "outerWidth"), this.measureColumns(), this.colYs = []; for (var t = 0; t < this.cols; t++)this.colYs.push(0); this.maxY = 0, this.horizontalColIndex = 0 }, n.measureColumns = function () { if (this.getContainerWidth(), !this.columnWidth) { var t = this.items[0], e = t && t.element; this.columnWidth = e && i(e).outerWidth || this.containerWidth } var n = this.columnWidth += this.gutter, o = this.containerWidth + this.gutter, s = o / n, r = n - o % n; s = Math[r && r < 1 ? "round" : "floor"](s), this.cols = Math.max(s, 1) }, n.getContainerWidth = function () { var t = this._getOption("fitWidth") ? this.element.parentNode : this.element, e = i(t); this.containerWidth = e && e.innerWidth }, n._getItemLayoutPosition = function (t) { t.getSize(); var i = t.size.outerWidth % this.columnWidth, e = Math[i && i < 1 ? "round" : "ceil"](t.size.outerWidth / this.columnWidth); e = Math.min(e, this.cols); for (var n = this[this.options.horizontalOrder ? "_getHorizontalColPosition" : "_getTopColPosition"](e, t), o = { x: this.columnWidth * n.col, y: n.y }, s = n.y + t.size.outerHeight, r = e + n.col, a = n.col; a < r; a++)this.colYs[a] = s; return o }, n._getTopColPosition = function (t) { var i = this._getTopColGroup(t), e = Math.min.apply(Math, i); return { col: i.indexOf(e), y: e } }, n._getTopColGroup = function (t) { if (t < 2) return this.colYs; for (var i = [], e = this.cols + 1 - t, n = 0; n < e; n++)i[n] = this._getColGroupY(n, t); return i }, n._getColGroupY = function (t, i) { if (i < 2) return this.colYs[t]; var e = this.colYs.slice(t, t + i); return Math.max.apply(Math, e) }, n._getHorizontalColPosition = function (t, i) { var e = this.horizontalColIndex % this.cols; e = t > 1 && e + t > this.cols ? 0 : e; var n = i.size.outerWidth && i.size.outerHeight; return this.horizontalColIndex = n ? e + t : this.horizontalColIndex, { col: e, y: this._getColGroupY(e, t) } }, n._manageStamp = function (t) { var e = i(t), n = this._getElementOffset(t), o = this._getOption("originLeft") ? n.left : n.right, s = o + e.outerWidth, r = Math.floor(o / this.columnWidth); r = Math.max(0, r); var a = Math.floor(s / this.columnWidth); a -= s % this.columnWidth ? 0 : 1, a = Math.min(this.cols - 1, a); for (var h = (this._getOption("originTop") ? n.top : n.bottom) + e.outerHeight, u = r; u <= a; u++)this.colYs[u] = Math.max(h, this.colYs[u]) }, n._getContainerSize = function () { this.maxY = Math.max.apply(Math, this.colYs); var t = { height: this.maxY }; return this._getOption("fitWidth") && (t.width = this._getContainerFitWidth()), t }, n._getContainerFitWidth = function () { for (var t = 0, i = this.cols; --i && 0 === this.colYs[i];)t++; return (this.cols - t) * this.columnWidth - this.gutter }, n.needsResizeLayout = function () { var t = this.containerWidth; return this.getContainerWidth(), t != this.containerWidth }, e }(t.Outlayer, t.getSize) }(window);/*! Sortable 1.15.2 - MIT | git://github.com/SortableJS/Sortable.git */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).Sortable=e()}(this,function(){"use strict";function e(e,t){var n,o=Object.keys(e);return Object.getOwnPropertySymbols&&(n=Object.getOwnPropertySymbols(e),t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),o.push.apply(o,n)),o}function I(o){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?e(Object(i),!0).forEach(function(t){var e,n;e=o,t=i[n=t],n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t}):Object.getOwnPropertyDescriptors?Object.defineProperties(o,Object.getOwnPropertyDescriptors(i)):e(Object(i)).forEach(function(t){Object.defineProperty(o,t,Object.getOwnPropertyDescriptor(i,t))})}return o}function o(t){return(o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function a(){return(a=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n,o=arguments[e];for(n in o)Object.prototype.hasOwnProperty.call(o,n)&&(t[n]=o[n])}return t}).apply(this,arguments)}function i(t,e){if(null==t)return{};var n,o=function(t,e){if(null==t)return{};for(var n,o={},i=Object.keys(t),r=0;r<i.length;r++)n=i[r],0<=e.indexOf(n)||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols)for(var i=Object.getOwnPropertySymbols(t),r=0;r<i.length;r++)n=i[r],0<=e.indexOf(n)||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n]);return o}function r(t){return function(t){if(Array.isArray(t))return l(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,e){if(t){if("string"==typeof t)return l(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return"Map"===(n="Object"===n&&t.constructor?t.constructor.name:n)||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?l(t,e):void 0}}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function l(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,o=new Array(e);n<e;n++)o[n]=t[n];return o}function t(t){if("undefined"!=typeof window&&window.navigator)return!!navigator.userAgent.match(t)}var y=t(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i),w=t(/Edge/i),s=t(/firefox/i),u=t(/safari/i)&&!t(/chrome/i)&&!t(/android/i),n=t(/iP(ad|od|hone)/i),c=t(/chrome/i)&&t(/android/i),d={capture:!1,passive:!1};function h(t,e,n){t.addEventListener(e,n,!y&&d)}function f(t,e,n){t.removeEventListener(e,n,!y&&d)}function p(t,e){if(e&&(">"===e[0]&&(e=e.substring(1)),t))try{if(t.matches)return t.matches(e);if(t.msMatchesSelector)return t.msMatchesSelector(e);if(t.webkitMatchesSelector)return t.webkitMatchesSelector(e)}catch(t){return}}function P(t,e,n,o){if(t){n=n||document;do{if(null!=e&&(">"!==e[0]||t.parentNode===n)&&p(t,e)||o&&t===n)return t}while(t!==n&&(t=(i=t).host&&i!==document&&i.host.nodeType?i.host:i.parentNode))}var i;return null}var g,m=/\s+/g;function k(t,e,n){var o;t&&e&&(t.classList?t.classList[n?"add":"remove"](e):(o=(" "+t.className+" ").replace(m," ").replace(" "+e+" "," "),t.className=(o+(n?" "+e:"")).replace(m," ")))}function R(t,e,n){var o=t&&t.style;if(o){if(void 0===n)return document.defaultView&&document.defaultView.getComputedStyle?n=document.defaultView.getComputedStyle(t,""):t.currentStyle&&(n=t.currentStyle),void 0===e?n:n[e];o[e=!(e in o||-1!==e.indexOf("webkit"))?"-webkit-"+e:e]=n+("string"==typeof n?"":"px")}}function v(t,e){var n="";if("string"==typeof t)n=t;else do{var o=R(t,"transform")}while(o&&"none"!==o&&(n=o+" "+n),!e&&(t=t.parentNode));var i=window.DOMMatrix||window.WebKitCSSMatrix||window.CSSMatrix||window.MSCSSMatrix;return i&&new i(n)}function b(t,e,n){if(t){var o=t.getElementsByTagName(e),i=0,r=o.length;if(n)for(;i<r;i++)n(o[i],i);return o}return[]}function O(){var t=document.scrollingElement;return t||document.documentElement}function X(t,e,n,o,i){if(t.getBoundingClientRect||t===window){var r,a,l,s,c,u,d=t!==window&&t.parentNode&&t!==O()?(a=(r=t.getBoundingClientRect()).top,l=r.left,s=r.bottom,c=r.right,u=r.height,r.width):(l=a=0,s=window.innerHeight,c=window.innerWidth,u=window.innerHeight,window.innerWidth);if((e||n)&&t!==window&&(i=i||t.parentNode,!y))do{if(i&&i.getBoundingClientRect&&("none"!==R(i,"transform")||n&&"static"!==R(i,"position"))){var h=i.getBoundingClientRect();a-=h.top+parseInt(R(i,"border-top-width")),l-=h.left+parseInt(R(i,"border-left-width")),s=a+r.height,c=l+r.width;break}}while(i=i.parentNode);return o&&t!==window&&(o=(e=v(i||t))&&e.a,t=e&&e.d,e&&(s=(a/=t)+(u/=t),c=(l/=o)+(d/=o))),{top:a,left:l,bottom:s,right:c,width:d,height:u}}}function Y(t,e,n){for(var o=M(t,!0),i=X(t)[e];o;){var r=X(o)[n];if(!("top"===n||"left"===n?r<=i:i<=r))return o;if(o===O())break;o=M(o,!1)}return!1}function B(t,e,n,o){for(var i=0,r=0,a=t.children;r<a.length;){if("none"!==a[r].style.display&&a[r]!==Ft.ghost&&(o||a[r]!==Ft.dragged)&&P(a[r],n.draggable,t,!1)){if(i===e)return a[r];i++}r++}return null}function F(t,e){for(var n=t.lastElementChild;n&&(n===Ft.ghost||"none"===R(n,"display")||e&&!p(n,e));)n=n.previousElementSibling;return n||null}function j(t,e){var n=0;if(!t||!t.parentNode)return-1;for(;t=t.previousElementSibling;)"TEMPLATE"===t.nodeName.toUpperCase()||t===Ft.clone||e&&!p(t,e)||n++;return n}function E(t){var e=0,n=0,o=O();if(t)do{var i=v(t),r=i.a,i=i.d}while(e+=t.scrollLeft*r,n+=t.scrollTop*i,t!==o&&(t=t.parentNode));return[e,n]}function M(t,e){if(!t||!t.getBoundingClientRect)return O();var n=t,o=!1;do{if(n.clientWidth<n.scrollWidth||n.clientHeight<n.scrollHeight){var i=R(n);if(n.clientWidth<n.scrollWidth&&("auto"==i.overflowX||"scroll"==i.overflowX)||n.clientHeight<n.scrollHeight&&("auto"==i.overflowY||"scroll"==i.overflowY)){if(!n.getBoundingClientRect||n===document.body)return O();if(o||e)return n;o=!0}}}while(n=n.parentNode);return O()}function D(t,e){return Math.round(t.top)===Math.round(e.top)&&Math.round(t.left)===Math.round(e.left)&&Math.round(t.height)===Math.round(e.height)&&Math.round(t.width)===Math.round(e.width)}function S(e,n){return function(){var t;g||(1===(t=arguments).length?e.call(this,t[0]):e.apply(this,t),g=setTimeout(function(){g=void 0},n))}}function H(t,e,n){t.scrollLeft+=e,t.scrollTop+=n}function _(t){var e=window.Polymer,n=window.jQuery||window.Zepto;return e&&e.dom?e.dom(t).cloneNode(!0):n?n(t).clone(!0)[0]:t.cloneNode(!0)}function C(t,e){R(t,"position","absolute"),R(t,"top",e.top),R(t,"left",e.left),R(t,"width",e.width),R(t,"height",e.height)}function T(t){R(t,"position",""),R(t,"top",""),R(t,"left",""),R(t,"width",""),R(t,"height","")}function L(n,o,i){var r={};return Array.from(n.children).forEach(function(t){var e;P(t,o.draggable,n,!1)&&!t.animated&&t!==i&&(e=X(t),r.left=Math.min(null!==(t=r.left)&&void 0!==t?t:1/0,e.left),r.top=Math.min(null!==(t=r.top)&&void 0!==t?t:1/0,e.top),r.right=Math.max(null!==(t=r.right)&&void 0!==t?t:-1/0,e.right),r.bottom=Math.max(null!==(t=r.bottom)&&void 0!==t?t:-1/0,e.bottom))}),r.width=r.right-r.left,r.height=r.bottom-r.top,r.x=r.left,r.y=r.top,r}var K="Sortable"+(new Date).getTime();function x(){var e,o=[];return{captureAnimationState:function(){o=[],this.options.animation&&[].slice.call(this.el.children).forEach(function(t){var e,n;"none"!==R(t,"display")&&t!==Ft.ghost&&(o.push({target:t,rect:X(t)}),e=I({},o[o.length-1].rect),!t.thisAnimationDuration||(n=v(t,!0))&&(e.top-=n.f,e.left-=n.e),t.fromRect=e)})},addAnimationState:function(t){o.push(t)},removeAnimationState:function(t){o.splice(function(t,e){for(var n in t)if(t.hasOwnProperty(n))for(var o in e)if(e.hasOwnProperty(o)&&e[o]===t[n][o])return Number(n);return-1}(o,{target:t}),1)},animateAll:function(t){var c=this;if(!this.options.animation)return clearTimeout(e),void("function"==typeof t&&t());var u=!1,d=0;o.forEach(function(t){var e=0,n=t.target,o=n.fromRect,i=X(n),r=n.prevFromRect,a=n.prevToRect,l=t.rect,s=v(n,!0);s&&(i.top-=s.f,i.left-=s.e),n.toRect=i,n.thisAnimationDuration&&D(r,i)&&!D(o,i)&&(l.top-i.top)/(l.left-i.left)==(o.top-i.top)/(o.left-i.left)&&(t=l,s=r,r=a,a=c.options,e=Math.sqrt(Math.pow(s.top-t.top,2)+Math.pow(s.left-t.left,2))/Math.sqrt(Math.pow(s.top-r.top,2)+Math.pow(s.left-r.left,2))*a.animation),D(i,o)||(n.prevFromRect=o,n.prevToRect=i,e=e||c.options.animation,c.animate(n,l,i,e)),e&&(u=!0,d=Math.max(d,e),clearTimeout(n.animationResetTimer),n.animationResetTimer=setTimeout(function(){n.animationTime=0,n.prevFromRect=null,n.fromRect=null,n.prevToRect=null,n.thisAnimationDuration=null},e),n.thisAnimationDuration=e)}),clearTimeout(e),u?e=setTimeout(function(){"function"==typeof t&&t()},d):"function"==typeof t&&t(),o=[]},animate:function(t,e,n,o){var i,r;o&&(R(t,"transition",""),R(t,"transform",""),i=(r=v(this.el))&&r.a,r=r&&r.d,i=(e.left-n.left)/(i||1),r=(e.top-n.top)/(r||1),t.animatingX=!!i,t.animatingY=!!r,R(t,"transform","translate3d("+i+"px,"+r+"px,0)"),this.forRepaintDummy=t.offsetWidth,R(t,"transition","transform "+o+"ms"+(this.options.easing?" "+this.options.easing:"")),R(t,"transform","translate3d(0,0,0)"),"number"==typeof t.animated&&clearTimeout(t.animated),t.animated=setTimeout(function(){R(t,"transition",""),R(t,"transform",""),t.animated=!1,t.animatingX=!1,t.animatingY=!1},o))}}}var A=[],N={initializeByDefault:!0},W={mount:function(e){for(var t in N)!N.hasOwnProperty(t)||t in e||(e[t]=N[t]);A.forEach(function(t){if(t.pluginName===e.pluginName)throw"Sortable: Cannot mount plugin ".concat(e.pluginName," more than once")}),A.push(e)},pluginEvent:function(e,n,o){var t=this;this.eventCanceled=!1,o.cancel=function(){t.eventCanceled=!0};var i=e+"Global";A.forEach(function(t){n[t.pluginName]&&(n[t.pluginName][i]&&n[t.pluginName][i](I({sortable:n},o)),n.options[t.pluginName]&&n[t.pluginName][e]&&n[t.pluginName][e](I({sortable:n},o)))})},initializePlugins:function(n,o,i,t){for(var e in A.forEach(function(t){var e=t.pluginName;(n.options[e]||t.initializeByDefault)&&((t=new t(n,o,n.options)).sortable=n,t.options=n.options,n[e]=t,a(i,t.defaults))}),n.options){var r;n.options.hasOwnProperty(e)&&(void 0!==(r=this.modifyOption(n,e,n.options[e]))&&(n.options[e]=r))}},getEventProperties:function(e,n){var o={};return A.forEach(function(t){"function"==typeof t.eventProperties&&a(o,t.eventProperties.call(n[t.pluginName],e))}),o},modifyOption:function(e,n,o){var i;return A.forEach(function(t){e[t.pluginName]&&t.optionListeners&&"function"==typeof t.optionListeners[n]&&(i=t.optionListeners[n].call(e[t.pluginName],o))}),i}};function z(t){var e=t.sortable,n=t.rootEl,o=t.name,i=t.targetEl,r=t.cloneEl,a=t.toEl,l=t.fromEl,s=t.oldIndex,c=t.newIndex,u=t.oldDraggableIndex,d=t.newDraggableIndex,h=t.originalEvent,f=t.putSortable,p=t.extraEventProperties;if(e=e||n&&n[K]){var g,m=e.options,t="on"+o.charAt(0).toUpperCase()+o.substr(1);!window.CustomEvent||y||w?(g=document.createEvent("Event")).initEvent(o,!0,!0):g=new CustomEvent(o,{bubbles:!0,cancelable:!0}),g.to=a||n,g.from=l||n,g.item=i||n,g.clone=r,g.oldIndex=s,g.newIndex=c,g.oldDraggableIndex=u,g.newDraggableIndex=d,g.originalEvent=h,g.pullMode=f?f.lastPutMode:void 0;var v,b=I(I({},p),W.getEventProperties(o,e));for(v in b)g[v]=b[v];n&&n.dispatchEvent(g),m[t]&&m[t].call(e,g)}}function G(t,e){var n=(o=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{}).evt,o=i(o,U);W.pluginEvent.bind(Ft)(t,e,I({dragEl:V,parentEl:Z,ghostEl:$,rootEl:Q,nextEl:J,lastDownEl:tt,cloneEl:et,cloneHidden:nt,dragStarted:gt,putSortable:st,activeSortable:Ft.active,originalEvent:n,oldIndex:ot,oldDraggableIndex:rt,newIndex:it,newDraggableIndex:at,hideGhostForTarget:Rt,unhideGhostForTarget:Xt,cloneNowHidden:function(){nt=!0},cloneNowShown:function(){nt=!1},dispatchSortableEvent:function(t){q({sortable:e,name:t,originalEvent:n})}},o))}var U=["evt"];function q(t){z(I({putSortable:st,cloneEl:et,targetEl:V,rootEl:Q,oldIndex:ot,oldDraggableIndex:rt,newIndex:it,newDraggableIndex:at},t))}var V,Z,$,Q,J,tt,et,nt,ot,it,rt,at,lt,st,ct,ut,dt,ht,ft,pt,gt,mt,vt,bt,yt,wt=!1,Et=!1,Dt=[],St=!1,_t=!1,Ct=[],Tt=!1,xt=[],Ot="undefined"!=typeof document,Mt=n,At=w||y?"cssFloat":"float",Nt=Ot&&!c&&!n&&"draggable"in document.createElement("div"),It=function(){if(Ot){if(y)return!1;var t=document.createElement("x");return t.style.cssText="pointer-events:auto","auto"===t.style.pointerEvents}}(),Pt=function(t,e){var n=R(t),o=parseInt(n.width)-parseInt(n.paddingLeft)-parseInt(n.paddingRight)-parseInt(n.borderLeftWidth)-parseInt(n.borderRightWidth),i=B(t,0,e),r=B(t,1,e),a=i&&R(i),l=r&&R(r),s=a&&parseInt(a.marginLeft)+parseInt(a.marginRight)+X(i).width,t=l&&parseInt(l.marginLeft)+parseInt(l.marginRight)+X(r).width;if("flex"===n.display)return"column"===n.flexDirection||"column-reverse"===n.flexDirection?"vertical":"horizontal";if("grid"===n.display)return n.gridTemplateColumns.split(" ").length<=1?"vertical":"horizontal";if(i&&a.float&&"none"!==a.float){e="left"===a.float?"left":"right";return!r||"both"!==l.clear&&l.clear!==e?"horizontal":"vertical"}return i&&("block"===a.display||"flex"===a.display||"table"===a.display||"grid"===a.display||o<=s&&"none"===n[At]||r&&"none"===n[At]&&o<s+t)?"vertical":"horizontal"},kt=function(t){function l(r,a){return function(t,e,n,o){var i=t.options.group.name&&e.options.group.name&&t.options.group.name===e.options.group.name;if(null==r&&(a||i))return!0;if(null==r||!1===r)return!1;if(a&&"clone"===r)return r;if("function"==typeof r)return l(r(t,e,n,o),a)(t,e,n,o);e=(a?t:e).options.group.name;return!0===r||"string"==typeof r&&r===e||r.join&&-1<r.indexOf(e)}}var e={},n=t.group;n&&"object"==o(n)||(n={name:n}),e.name=n.name,e.checkPull=l(n.pull,!0),e.checkPut=l(n.put),e.revertClone=n.revertClone,t.group=e},Rt=function(){!It&&$&&R($,"display","none")},Xt=function(){!It&&$&&R($,"display","")};Ot&&!c&&document.addEventListener("click",function(t){if(Et)return t.preventDefault(),t.stopPropagation&&t.stopPropagation(),t.stopImmediatePropagation&&t.stopImmediatePropagation(),Et=!1},!0);function Yt(t){if(V){t=t.touches?t.touches[0]:t;var e=(i=t.clientX,r=t.clientY,Dt.some(function(t){var e=t[K].options.emptyInsertThreshold;if(e&&!F(t)){var n=X(t),o=i>=n.left-e&&i<=n.right+e,e=r>=n.top-e&&r<=n.bottom+e;return o&&e?a=t:void 0}}),a);if(e){var n,o={};for(n in t)t.hasOwnProperty(n)&&(o[n]=t[n]);o.target=o.rootEl=e,o.preventDefault=void 0,o.stopPropagation=void 0,e[K]._onDragOver(o)}}var i,r,a}function Bt(t){V&&V.parentNode[K]._isOutsideThisEl(t.target)}function Ft(t,e){if(!t||!t.nodeType||1!==t.nodeType)throw"Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(t));this.el=t,this.options=e=a({},e),t[K]=this;var n,o,i={group:null,sort:!0,disabled:!1,store:null,handle:null,draggable:/^[uo]l$/i.test(t.nodeName)?">li":">*",swapThreshold:1,invertSwap:!1,invertedSwapThreshold:null,removeCloneOnHide:!0,direction:function(){return Pt(t,this.options)},ghostClass:"sortable-ghost",chosenClass:"sortable-chosen",dragClass:"sortable-drag",ignore:"a, img",filter:null,preventOnFilter:!0,animation:0,easing:null,setData:function(t,e){t.setData("Text",e.textContent)},dropBubble:!1,dragoverBubble:!1,dataIdAttr:"data-id",delay:0,delayOnTouchOnly:!1,touchStartThreshold:(Number.parseInt?Number:window).parseInt(window.devicePixelRatio,10)||1,forceFallback:!1,fallbackClass:"sortable-fallback",fallbackOnBody:!1,fallbackTolerance:0,fallbackOffset:{x:0,y:0},supportPointer:!1!==Ft.supportPointer&&"PointerEvent"in window&&!u,emptyInsertThreshold:5};for(n in W.initializePlugins(this,t,i),i)n in e||(e[n]=i[n]);for(o in kt(e),this)"_"===o.charAt(0)&&"function"==typeof this[o]&&(this[o]=this[o].bind(this));this.nativeDraggable=!e.forceFallback&&Nt,this.nativeDraggable&&(this.options.touchStartThreshold=1),e.supportPointer?h(t,"pointerdown",this._onTapStart):(h(t,"mousedown",this._onTapStart),h(t,"touchstart",this._onTapStart)),this.nativeDraggable&&(h(t,"dragover",this),h(t,"dragenter",this)),Dt.push(this.el),e.store&&e.store.get&&this.sort(e.store.get(this)||[]),a(this,x())}function jt(t,e,n,o,i,r,a,l){var s,c,u=t[K],d=u.options.onMove;return!window.CustomEvent||y||w?(s=document.createEvent("Event")).initEvent("move",!0,!0):s=new CustomEvent("move",{bubbles:!0,cancelable:!0}),s.to=e,s.from=t,s.dragged=n,s.draggedRect=o,s.related=i||e,s.relatedRect=r||X(e),s.willInsertAfter=l,s.originalEvent=a,t.dispatchEvent(s),c=d?d.call(u,s,a):c}function Ht(t){t.draggable=!1}function Lt(){Tt=!1}function Kt(t){return setTimeout(t,0)}function Wt(t){return clearTimeout(t)}Ft.prototype={constructor:Ft,_isOutsideThisEl:function(t){this.el.contains(t)||t===this.el||(mt=null)},_getDirection:function(t,e){return"function"==typeof this.options.direction?this.options.direction.call(this,t,e,V):this.options.direction},_onTapStart:function(e){if(e.cancelable){var n=this,o=this.el,t=this.options,i=t.preventOnFilter,r=e.type,a=e.touches&&e.touches[0]||e.pointerType&&"touch"===e.pointerType&&e,l=(a||e).target,s=e.target.shadowRoot&&(e.path&&e.path[0]||e.composedPath&&e.composedPath()[0])||l,c=t.filter;if(!function(t){xt.length=0;var e=t.getElementsByTagName("input"),n=e.length;for(;n--;){var o=e[n];o.checked&&xt.push(o)}}(o),!V&&!(/mousedown|pointerdown/.test(r)&&0!==e.button||t.disabled)&&!s.isContentEditable&&(this.nativeDraggable||!u||!l||"SELECT"!==l.tagName.toUpperCase())&&!((l=P(l,t.draggable,o,!1))&&l.animated||tt===l)){if(ot=j(l),rt=j(l,t.draggable),"function"==typeof c){if(c.call(this,e,l,this))return q({sortable:n,rootEl:s,name:"filter",targetEl:l,toEl:o,fromEl:o}),G("filter",n,{evt:e}),void(i&&e.cancelable&&e.preventDefault())}else if(c=c&&c.split(",").some(function(t){if(t=P(s,t.trim(),o,!1))return q({sortable:n,rootEl:t,name:"filter",targetEl:l,fromEl:o,toEl:o}),G("filter",n,{evt:e}),!0}))return void(i&&e.cancelable&&e.preventDefault());t.handle&&!P(s,t.handle,o,!1)||this._prepareDragStart(e,a,l)}}},_prepareDragStart:function(t,e,n){var o,i=this,r=i.el,a=i.options,l=r.ownerDocument;n&&!V&&n.parentNode===r&&(o=X(n),Q=r,Z=(V=n).parentNode,J=V.nextSibling,tt=n,lt=a.group,ct={target:Ft.dragged=V,clientX:(e||t).clientX,clientY:(e||t).clientY},ft=ct.clientX-o.left,pt=ct.clientY-o.top,this._lastX=(e||t).clientX,this._lastY=(e||t).clientY,V.style["will-change"]="all",o=function(){G("delayEnded",i,{evt:t}),Ft.eventCanceled?i._onDrop():(i._disableDelayedDragEvents(),!s&&i.nativeDraggable&&(V.draggable=!0),i._triggerDragStart(t,e),q({sortable:i,name:"choose",originalEvent:t}),k(V,a.chosenClass,!0))},a.ignore.split(",").forEach(function(t){b(V,t.trim(),Ht)}),h(l,"dragover",Yt),h(l,"mousemove",Yt),h(l,"touchmove",Yt),h(l,"mouseup",i._onDrop),h(l,"touchend",i._onDrop),h(l,"touchcancel",i._onDrop),s&&this.nativeDraggable&&(this.options.touchStartThreshold=4,V.draggable=!0),G("delayStart",this,{evt:t}),!a.delay||a.delayOnTouchOnly&&!e||this.nativeDraggable&&(w||y)?o():Ft.eventCanceled?this._onDrop():(h(l,"mouseup",i._disableDelayedDrag),h(l,"touchend",i._disableDelayedDrag),h(l,"touchcancel",i._disableDelayedDrag),h(l,"mousemove",i._delayedDragTouchMoveHandler),h(l,"touchmove",i._delayedDragTouchMoveHandler),a.supportPointer&&h(l,"pointermove",i._delayedDragTouchMoveHandler),i._dragStartTimer=setTimeout(o,a.delay)))},_delayedDragTouchMoveHandler:function(t){t=t.touches?t.touches[0]:t;Math.max(Math.abs(t.clientX-this._lastX),Math.abs(t.clientY-this._lastY))>=Math.floor(this.options.touchStartThreshold/(this.nativeDraggable&&window.devicePixelRatio||1))&&this._disableDelayedDrag()},_disableDelayedDrag:function(){V&&Ht(V),clearTimeout(this._dragStartTimer),this._disableDelayedDragEvents()},_disableDelayedDragEvents:function(){var t=this.el.ownerDocument;f(t,"mouseup",this._disableDelayedDrag),f(t,"touchend",this._disableDelayedDrag),f(t,"touchcancel",this._disableDelayedDrag),f(t,"mousemove",this._delayedDragTouchMoveHandler),f(t,"touchmove",this._delayedDragTouchMoveHandler),f(t,"pointermove",this._delayedDragTouchMoveHandler)},_triggerDragStart:function(t,e){e=e||"touch"==t.pointerType&&t,!this.nativeDraggable||e?this.options.supportPointer?h(document,"pointermove",this._onTouchMove):h(document,e?"touchmove":"mousemove",this._onTouchMove):(h(V,"dragend",this),h(Q,"dragstart",this._onDragStart));try{document.selection?Kt(function(){document.selection.empty()}):window.getSelection().removeAllRanges()}catch(t){}},_dragStarted:function(t,e){var n;wt=!1,Q&&V?(G("dragStarted",this,{evt:e}),this.nativeDraggable&&h(document,"dragover",Bt),n=this.options,t||k(V,n.dragClass,!1),k(V,n.ghostClass,!0),Ft.active=this,t&&this._appendGhost(),q({sortable:this,name:"start",originalEvent:e})):this._nulling()},_emulateDragOver:function(){if(ut){this._lastX=ut.clientX,this._lastY=ut.clientY,Rt();for(var t=document.elementFromPoint(ut.clientX,ut.clientY),e=t;t&&t.shadowRoot&&(t=t.shadowRoot.elementFromPoint(ut.clientX,ut.clientY))!==e;)e=t;if(V.parentNode[K]._isOutsideThisEl(t),e)do{if(e[K])if(e[K]._onDragOver({clientX:ut.clientX,clientY:ut.clientY,target:t,rootEl:e})&&!this.options.dragoverBubble)break}while(e=(t=e).parentNode);Xt()}},_onTouchMove:function(t){if(ct){var e=this.options,n=e.fallbackTolerance,o=e.fallbackOffset,i=t.touches?t.touches[0]:t,r=$&&v($,!0),a=$&&r&&r.a,l=$&&r&&r.d,e=Mt&&yt&&E(yt),a=(i.clientX-ct.clientX+o.x)/(a||1)+(e?e[0]-Ct[0]:0)/(a||1),l=(i.clientY-ct.clientY+o.y)/(l||1)+(e?e[1]-Ct[1]:0)/(l||1);if(!Ft.active&&!wt){if(n&&Math.max(Math.abs(i.clientX-this._lastX),Math.abs(i.clientY-this._lastY))<n)return;this._onDragStart(t,!0)}$&&(r?(r.e+=a-(dt||0),r.f+=l-(ht||0)):r={a:1,b:0,c:0,d:1,e:a,f:l},r="matrix(".concat(r.a,",").concat(r.b,",").concat(r.c,",").concat(r.d,",").concat(r.e,",").concat(r.f,")"),R($,"webkitTransform",r),R($,"mozTransform",r),R($,"msTransform",r),R($,"transform",r),dt=a,ht=l,ut=i),t.cancelable&&t.preventDefault()}},_appendGhost:function(){if(!$){var t=this.options.fallbackOnBody?document.body:Q,e=X(V,!0,Mt,!0,t),n=this.options;if(Mt){for(yt=t;"static"===R(yt,"position")&&"none"===R(yt,"transform")&&yt!==document;)yt=yt.parentNode;yt!==document.body&&yt!==document.documentElement?(yt===document&&(yt=O()),e.top+=yt.scrollTop,e.left+=yt.scrollLeft):yt=O(),Ct=E(yt)}k($=V.cloneNode(!0),n.ghostClass,!1),k($,n.fallbackClass,!0),k($,n.dragClass,!0),R($,"transition",""),R($,"transform",""),R($,"box-sizing","border-box"),R($,"margin",0),R($,"top",e.top),R($,"left",e.left),R($,"width",e.width),R($,"height",e.height),R($,"opacity","0.8"),R($,"position",Mt?"absolute":"fixed"),R($,"zIndex","100000"),R($,"pointerEvents","none"),Ft.ghost=$,t.appendChild($),R($,"transform-origin",ft/parseInt($.style.width)*100+"% "+pt/parseInt($.style.height)*100+"%")}},_onDragStart:function(t,e){var n=this,o=t.dataTransfer,i=n.options;G("dragStart",this,{evt:t}),Ft.eventCanceled?this._onDrop():(G("setupClone",this),Ft.eventCanceled||((et=_(V)).removeAttribute("id"),et.draggable=!1,et.style["will-change"]="",this._hideClone(),k(et,this.options.chosenClass,!1),Ft.clone=et),n.cloneId=Kt(function(){G("clone",n),Ft.eventCanceled||(n.options.removeCloneOnHide||Q.insertBefore(et,V),n._hideClone(),q({sortable:n,name:"clone"}))}),e||k(V,i.dragClass,!0),e?(Et=!0,n._loopId=setInterval(n._emulateDragOver,50)):(f(document,"mouseup",n._onDrop),f(document,"touchend",n._onDrop),f(document,"touchcancel",n._onDrop),o&&(o.effectAllowed="move",i.setData&&i.setData.call(n,o,V)),h(document,"drop",n),R(V,"transform","translateZ(0)")),wt=!0,n._dragStartId=Kt(n._dragStarted.bind(n,e,t)),h(document,"selectstart",n),gt=!0,u&&R(document.body,"user-select","none"))},_onDragOver:function(n){var o,i,r,t,e,a=this.el,l=n.target,s=this.options,c=s.group,u=Ft.active,d=lt===c,h=s.sort,f=st||u,p=this,g=!1;if(!Tt){if(void 0!==n.preventDefault&&n.cancelable&&n.preventDefault(),l=P(l,s.draggable,a,!0),O("dragOver"),Ft.eventCanceled)return g;if(V.contains(n.target)||l.animated&&l.animatingX&&l.animatingY||p._ignoreWhileAnimating===l)return A(!1);if(Et=!1,u&&!s.disabled&&(d?h||(i=Z!==Q):st===this||(this.lastPutMode=lt.checkPull(this,u,V,n))&&c.checkPut(this,u,V,n))){if(r="vertical"===this._getDirection(n,l),o=X(V),O("dragOverValid"),Ft.eventCanceled)return g;if(i)return Z=Q,M(),this._hideClone(),O("revert"),Ft.eventCanceled||(J?Q.insertBefore(V,J):Q.appendChild(V)),A(!0);var m=F(a,s.draggable);if(m&&(S=n,c=r,x=X(F((D=this).el,D.options.draggable)),D=L(D.el,D.options,$),!(c?S.clientX>D.right+10||S.clientY>x.bottom&&S.clientX>x.left:S.clientY>D.bottom+10||S.clientX>x.right&&S.clientY>x.top)||m.animated)){if(m&&(t=n,e=r,C=X(B((_=this).el,0,_.options,!0)),_=L(_.el,_.options,$),e?t.clientX<_.left-10||t.clientY<C.top&&t.clientX<C.right:t.clientY<_.top-10||t.clientY<C.bottom&&t.clientX<C.left)){var v=B(a,0,s,!0);if(v===V)return A(!1);if(E=X(l=v),!1!==jt(Q,a,V,o,l,E,n,!1))return M(),a.insertBefore(V,v),Z=a,N(),A(!0)}else if(l.parentNode===a){var b,y,w,E=X(l),D=V.parentNode!==a,S=(S=V.animated&&V.toRect||o,x=l.animated&&l.toRect||E,_=(e=r)?S.left:S.top,t=e?S.right:S.bottom,C=e?S.width:S.height,v=e?x.left:x.top,S=e?x.right:x.bottom,x=e?x.width:x.height,!(_===v||t===S||_+C/2===v+x/2)),_=r?"top":"left",C=Y(l,"top","top")||Y(V,"top","top"),v=C?C.scrollTop:void 0;if(mt!==l&&(y=E[_],St=!1,_t=!S&&s.invertSwap||D),0!==(b=function(t,e,n,o,i,r,a,l){var s=o?t.clientY:t.clientX,c=o?n.height:n.width,t=o?n.top:n.left,o=o?n.bottom:n.right,n=!1;if(!a)if(l&&bt<c*i){if(St=!St&&(1===vt?t+c*r/2<s:s<o-c*r/2)?!0:St)n=!0;else if(1===vt?s<t+bt:o-bt<s)return-vt}else if(t+c*(1-i)/2<s&&s<o-c*(1-i)/2)return function(t){return j(V)<j(t)?1:-1}(e);if((n=n||a)&&(s<t+c*r/2||o-c*r/2<s))return t+c/2<s?1:-1;return 0}(n,l,E,r,S?1:s.swapThreshold,null==s.invertedSwapThreshold?s.swapThreshold:s.invertedSwapThreshold,_t,mt===l)))for(var T=j(V);(w=Z.children[T-=b])&&("none"===R(w,"display")||w===$););if(0===b||w===l)return A(!1);vt=b;var x=(mt=l).nextElementSibling,D=!1,S=jt(Q,a,V,o,l,E,n,D=1===b);if(!1!==S)return 1!==S&&-1!==S||(D=1===S),Tt=!0,setTimeout(Lt,30),M(),D&&!x?a.appendChild(V):l.parentNode.insertBefore(V,D?x:l),C&&H(C,0,v-C.scrollTop),Z=V.parentNode,void 0===y||_t||(bt=Math.abs(y-X(l)[_])),N(),A(!0)}}else{if(m===V)return A(!1);if((l=m&&a===n.target?m:l)&&(E=X(l)),!1!==jt(Q,a,V,o,l,E,n,!!l))return M(),m&&m.nextSibling?a.insertBefore(V,m.nextSibling):a.appendChild(V),Z=a,N(),A(!0)}if(a.contains(V))return A(!1)}return!1}function O(t,e){G(t,p,I({evt:n,isOwner:d,axis:r?"vertical":"horizontal",revert:i,dragRect:o,targetRect:E,canSort:h,fromSortable:f,target:l,completed:A,onMove:function(t,e){return jt(Q,a,V,o,t,X(t),n,e)},changed:N},e))}function M(){O("dragOverAnimationCapture"),p.captureAnimationState(),p!==f&&f.captureAnimationState()}function A(t){return O("dragOverCompleted",{insertion:t}),t&&(d?u._hideClone():u._showClone(p),p!==f&&(k(V,(st||u).options.ghostClass,!1),k(V,s.ghostClass,!0)),st!==p&&p!==Ft.active?st=p:p===Ft.active&&st&&(st=null),f===p&&(p._ignoreWhileAnimating=l),p.animateAll(function(){O("dragOverAnimationComplete"),p._ignoreWhileAnimating=null}),p!==f&&(f.animateAll(),f._ignoreWhileAnimating=null)),(l===V&&!V.animated||l===a&&!l.animated)&&(mt=null),s.dragoverBubble||n.rootEl||l===document||(V.parentNode[K]._isOutsideThisEl(n.target),t||Yt(n)),!s.dragoverBubble&&n.stopPropagation&&n.stopPropagation(),g=!0}function N(){it=j(V),at=j(V,s.draggable),q({sortable:p,name:"change",toEl:a,newIndex:it,newDraggableIndex:at,originalEvent:n})}},_ignoreWhileAnimating:null,_offMoveEvents:function(){f(document,"mousemove",this._onTouchMove),f(document,"touchmove",this._onTouchMove),f(document,"pointermove",this._onTouchMove),f(document,"dragover",Yt),f(document,"mousemove",Yt),f(document,"touchmove",Yt)},_offUpEvents:function(){var t=this.el.ownerDocument;f(t,"mouseup",this._onDrop),f(t,"touchend",this._onDrop),f(t,"pointerup",this._onDrop),f(t,"touchcancel",this._onDrop),f(document,"selectstart",this)},_onDrop:function(t){var e=this.el,n=this.options;it=j(V),at=j(V,n.draggable),G("drop",this,{evt:t}),Z=V&&V.parentNode,it=j(V),at=j(V,n.draggable),Ft.eventCanceled||(St=_t=wt=!1,clearInterval(this._loopId),clearTimeout(this._dragStartTimer),Wt(this.cloneId),Wt(this._dragStartId),this.nativeDraggable&&(f(document,"drop",this),f(e,"dragstart",this._onDragStart)),this._offMoveEvents(),this._offUpEvents(),u&&R(document.body,"user-select",""),R(V,"transform",""),t&&(gt&&(t.cancelable&&t.preventDefault(),n.dropBubble||t.stopPropagation()),$&&$.parentNode&&$.parentNode.removeChild($),(Q===Z||st&&"clone"!==st.lastPutMode)&&et&&et.parentNode&&et.parentNode.removeChild(et),V&&(this.nativeDraggable&&f(V,"dragend",this),Ht(V),V.style["will-change"]="",gt&&!wt&&k(V,(st||this).options.ghostClass,!1),k(V,this.options.chosenClass,!1),q({sortable:this,name:"unchoose",toEl:Z,newIndex:null,newDraggableIndex:null,originalEvent:t}),Q!==Z?(0<=it&&(q({rootEl:Z,name:"add",toEl:Z,fromEl:Q,originalEvent:t}),q({sortable:this,name:"remove",toEl:Z,originalEvent:t}),q({rootEl:Z,name:"sort",toEl:Z,fromEl:Q,originalEvent:t}),q({sortable:this,name:"sort",toEl:Z,originalEvent:t})),st&&st.save()):it!==ot&&0<=it&&(q({sortable:this,name:"update",toEl:Z,originalEvent:t}),q({sortable:this,name:"sort",toEl:Z,originalEvent:t})),Ft.active&&(null!=it&&-1!==it||(it=ot,at=rt),q({sortable:this,name:"end",toEl:Z,originalEvent:t}),this.save())))),this._nulling()},_nulling:function(){G("nulling",this),Q=V=Z=$=J=et=tt=nt=ct=ut=gt=it=at=ot=rt=mt=vt=st=lt=Ft.dragged=Ft.ghost=Ft.clone=Ft.active=null,xt.forEach(function(t){t.checked=!0}),xt.length=dt=ht=0},handleEvent:function(t){switch(t.type){case"drop":case"dragend":this._onDrop(t);break;case"dragenter":case"dragover":V&&(this._onDragOver(t),function(t){t.dataTransfer&&(t.dataTransfer.dropEffect="move");t.cancelable&&t.preventDefault()}(t));break;case"selectstart":t.preventDefault()}},toArray:function(){for(var t,e=[],n=this.el.children,o=0,i=n.length,r=this.options;o<i;o++)P(t=n[o],r.draggable,this.el,!1)&&e.push(t.getAttribute(r.dataIdAttr)||function(t){var e=t.tagName+t.className+t.src+t.href+t.textContent,n=e.length,o=0;for(;n--;)o+=e.charCodeAt(n);return o.toString(36)}(t));return e},sort:function(t,e){var n={},o=this.el;this.toArray().forEach(function(t,e){e=o.children[e];P(e,this.options.draggable,o,!1)&&(n[t]=e)},this),e&&this.captureAnimationState(),t.forEach(function(t){n[t]&&(o.removeChild(n[t]),o.appendChild(n[t]))}),e&&this.animateAll()},save:function(){var t=this.options.store;t&&t.set&&t.set(this)},closest:function(t,e){return P(t,e||this.options.draggable,this.el,!1)},option:function(t,e){var n=this.options;if(void 0===e)return n[t];var o=W.modifyOption(this,t,e);n[t]=void 0!==o?o:e,"group"===t&&kt(n)},destroy:function(){G("destroy",this);var t=this.el;t[K]=null,f(t,"mousedown",this._onTapStart),f(t,"touchstart",this._onTapStart),f(t,"pointerdown",this._onTapStart),this.nativeDraggable&&(f(t,"dragover",this),f(t,"dragenter",this)),Array.prototype.forEach.call(t.querySelectorAll("[draggable]"),function(t){t.removeAttribute("draggable")}),this._onDrop(),this._disableDelayedDragEvents(),Dt.splice(Dt.indexOf(this.el),1),this.el=t=null},_hideClone:function(){nt||(G("hideClone",this),Ft.eventCanceled||(R(et,"display","none"),this.options.removeCloneOnHide&&et.parentNode&&et.parentNode.removeChild(et),nt=!0))},_showClone:function(t){"clone"===t.lastPutMode?nt&&(G("showClone",this),Ft.eventCanceled||(V.parentNode!=Q||this.options.group.revertClone?J?Q.insertBefore(et,J):Q.appendChild(et):Q.insertBefore(et,V),this.options.group.revertClone&&this.animate(V,et),R(et,"display",""),nt=!1)):this._hideClone()}},Ot&&h(document,"touchmove",function(t){(Ft.active||wt)&&t.cancelable&&t.preventDefault()}),Ft.utils={on:h,off:f,css:R,find:b,is:function(t,e){return!!P(t,e,t,!1)},extend:function(t,e){if(t&&e)for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t},throttle:S,closest:P,toggleClass:k,clone:_,index:j,nextTick:Kt,cancelNextTick:Wt,detectDirection:Pt,getChild:B},Ft.get=function(t){return t[K]},Ft.mount=function(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];(e=e[0].constructor===Array?e[0]:e).forEach(function(t){if(!t.prototype||!t.prototype.constructor)throw"Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(t));t.utils&&(Ft.utils=I(I({},Ft.utils),t.utils)),W.mount(t)})},Ft.create=function(t,e){return new Ft(t,e)};var zt,Gt,Ut,qt,Vt,Zt,$t=[],Qt=!(Ft.version="1.15.2");function Jt(){$t.forEach(function(t){clearInterval(t.pid)}),$t=[]}function te(){clearInterval(Zt)}var ee,ne=S(function(n,t,e,o){if(t.scroll){var i,r=(n.touches?n.touches[0]:n).clientX,a=(n.touches?n.touches[0]:n).clientY,l=t.scrollSensitivity,s=t.scrollSpeed,c=O(),u=!1;Gt!==e&&(Gt=e,Jt(),zt=t.scroll,i=t.scrollFn,!0===zt&&(zt=M(e,!0)));var d=0,h=zt;do{var f=h,p=X(f),g=p.top,m=p.bottom,v=p.left,b=p.right,y=p.width,w=p.height,E=void 0,D=void 0,S=f.scrollWidth,_=f.scrollHeight,C=R(f),T=f.scrollLeft,p=f.scrollTop,D=f===c?(E=y<S&&("auto"===C.overflowX||"scroll"===C.overflowX||"visible"===C.overflowX),w<_&&("auto"===C.overflowY||"scroll"===C.overflowY||"visible"===C.overflowY)):(E=y<S&&("auto"===C.overflowX||"scroll"===C.overflowX),w<_&&("auto"===C.overflowY||"scroll"===C.overflowY)),T=E&&(Math.abs(b-r)<=l&&T+y<S)-(Math.abs(v-r)<=l&&!!T),p=D&&(Math.abs(m-a)<=l&&p+w<_)-(Math.abs(g-a)<=l&&!!p);if(!$t[d])for(var x=0;x<=d;x++)$t[x]||($t[x]={});$t[d].vx==T&&$t[d].vy==p&&$t[d].el===f||($t[d].el=f,$t[d].vx=T,$t[d].vy=p,clearInterval($t[d].pid),0==T&&0==p||(u=!0,$t[d].pid=setInterval(function(){o&&0===this.layer&&Ft.active._onTouchMove(Vt);var t=$t[this.layer].vy?$t[this.layer].vy*s:0,e=$t[this.layer].vx?$t[this.layer].vx*s:0;"function"==typeof i&&"continue"!==i.call(Ft.dragged.parentNode[K],e,t,n,Vt,$t[this.layer].el)||H($t[this.layer].el,e,t)}.bind({layer:d}),24))),d++}while(t.bubbleScroll&&h!==c&&(h=M(h,!1)));Qt=u}},30),c=function(t){var e=t.originalEvent,n=t.putSortable,o=t.dragEl,i=t.activeSortable,r=t.dispatchSortableEvent,a=t.hideGhostForTarget,t=t.unhideGhostForTarget;e&&(i=n||i,a(),e=e.changedTouches&&e.changedTouches.length?e.changedTouches[0]:e,e=document.elementFromPoint(e.clientX,e.clientY),t(),i&&!i.el.contains(e)&&(r("spill"),this.onSpill({dragEl:o,putSortable:n})))};function oe(){}function ie(){}oe.prototype={startIndex:null,dragStart:function(t){t=t.oldDraggableIndex;this.startIndex=t},onSpill:function(t){var e=t.dragEl,n=t.putSortable;this.sortable.captureAnimationState(),n&&n.captureAnimationState();t=B(this.sortable.el,this.startIndex,this.options);t?this.sortable.el.insertBefore(e,t):this.sortable.el.appendChild(e),this.sortable.animateAll(),n&&n.animateAll()},drop:c},a(oe,{pluginName:"revertOnSpill"}),ie.prototype={onSpill:function(t){var e=t.dragEl,t=t.putSortable||this.sortable;t.captureAnimationState(),e.parentNode&&e.parentNode.removeChild(e),t.animateAll()},drop:c},a(ie,{pluginName:"removeOnSpill"});var re,ae,le,se,ce,ue=[],de=[],he=!1,fe=!1,pe=!1;function ge(n,o){de.forEach(function(t,e){e=o.children[t.sortableIndex+(n?Number(e):0)];e?o.insertBefore(t,e):o.appendChild(t)})}function me(){ue.forEach(function(t){t!==le&&t.parentNode&&t.parentNode.removeChild(t)})}return Ft.mount(new function(){function t(){for(var t in this.defaults={scroll:!0,forceAutoScrollFallback:!1,scrollSensitivity:30,scrollSpeed:10,bubbleScroll:!0},this)"_"===t.charAt(0)&&"function"==typeof this[t]&&(this[t]=this[t].bind(this))}return t.prototype={dragStarted:function(t){t=t.originalEvent;this.sortable.nativeDraggable?h(document,"dragover",this._handleAutoScroll):this.options.supportPointer?h(document,"pointermove",this._handleFallbackAutoScroll):t.touches?h(document,"touchmove",this._handleFallbackAutoScroll):h(document,"mousemove",this._handleFallbackAutoScroll)},dragOverCompleted:function(t){t=t.originalEvent;this.options.dragOverBubble||t.rootEl||this._handleAutoScroll(t)},drop:function(){this.sortable.nativeDraggable?f(document,"dragover",this._handleAutoScroll):(f(document,"pointermove",this._handleFallbackAutoScroll),f(document,"touchmove",this._handleFallbackAutoScroll),f(document,"mousemove",this._handleFallbackAutoScroll)),te(),Jt(),clearTimeout(g),g=void 0},nulling:function(){Vt=Gt=zt=Qt=Zt=Ut=qt=null,$t.length=0},_handleFallbackAutoScroll:function(t){this._handleAutoScroll(t,!0)},_handleAutoScroll:function(e,n){var o,i=this,r=(e.touches?e.touches[0]:e).clientX,a=(e.touches?e.touches[0]:e).clientY,t=document.elementFromPoint(r,a);Vt=e,n||this.options.forceAutoScrollFallback||w||y||u?(ne(e,this.options,t,n),o=M(t,!0),!Qt||Zt&&r===Ut&&a===qt||(Zt&&te(),Zt=setInterval(function(){var t=M(document.elementFromPoint(r,a),!0);t!==o&&(o=t,Jt()),ne(e,i.options,t,n)},10),Ut=r,qt=a)):this.options.bubbleScroll&&M(t,!0)!==O()?ne(e,this.options,M(t,!1),!1):Jt()}},a(t,{pluginName:"scroll",initializeByDefault:!0})}),Ft.mount(ie,oe),Ft.mount(new function(){function t(){this.defaults={swapClass:"sortable-swap-highlight"}}return t.prototype={dragStart:function(t){t=t.dragEl;ee=t},dragOverValid:function(t){var e=t.completed,n=t.target,o=t.onMove,i=t.activeSortable,r=t.changed,a=t.cancel;i.options.swap&&(t=this.sortable.el,i=this.options,n&&n!==t&&(t=ee,ee=!1!==o(n)?(k(n,i.swapClass,!0),n):null,t&&t!==ee&&k(t,i.swapClass,!1)),r(),e(!0),a())},drop:function(t){var e,n,o=t.activeSortable,i=t.putSortable,r=t.dragEl,a=i||this.sortable,l=this.options;ee&&k(ee,l.swapClass,!1),ee&&(l.swap||i&&i.options.swap)&&r!==ee&&(a.captureAnimationState(),a!==o&&o.captureAnimationState(),n=ee,t=(e=r).parentNode,l=n.parentNode,t&&l&&!t.isEqualNode(n)&&!l.isEqualNode(e)&&(i=j(e),r=j(n),t.isEqualNode(l)&&i<r&&r++,t.insertBefore(n,t.children[i]),l.insertBefore(e,l.children[r])),a.animateAll(),a!==o&&o.animateAll())},nulling:function(){ee=null}},a(t,{pluginName:"swap",eventProperties:function(){return{swapItem:ee}}})}),Ft.mount(new function(){function t(o){for(var t in this)"_"===t.charAt(0)&&"function"==typeof this[t]&&(this[t]=this[t].bind(this));o.options.avoidImplicitDeselect||(o.options.supportPointer?h(document,"pointerup",this._deselectMultiDrag):(h(document,"mouseup",this._deselectMultiDrag),h(document,"touchend",this._deselectMultiDrag))),h(document,"keydown",this._checkKeyDown),h(document,"keyup",this._checkKeyUp),this.defaults={selectedClass:"sortable-selected",multiDragKey:null,avoidImplicitDeselect:!1,setData:function(t,e){var n="";ue.length&&ae===o?ue.forEach(function(t,e){n+=(e?", ":"")+t.textContent}):n=e.textContent,t.setData("Text",n)}}}return t.prototype={multiDragKeyDown:!1,isMultiDrag:!1,delayStartGlobal:function(t){t=t.dragEl;le=t},delayEnded:function(){this.isMultiDrag=~ue.indexOf(le)},setupClone:function(t){var e=t.sortable,t=t.cancel;if(this.isMultiDrag){for(var n=0;n<ue.length;n++)de.push(_(ue[n])),de[n].sortableIndex=ue[n].sortableIndex,de[n].draggable=!1,de[n].style["will-change"]="",k(de[n],this.options.selectedClass,!1),ue[n]===le&&k(de[n],this.options.chosenClass,!1);e._hideClone(),t()}},clone:function(t){var e=t.sortable,n=t.rootEl,o=t.dispatchSortableEvent,t=t.cancel;this.isMultiDrag&&(this.options.removeCloneOnHide||ue.length&&ae===e&&(ge(!0,n),o("clone"),t()))},showClone:function(t){var e=t.cloneNowShown,n=t.rootEl,t=t.cancel;this.isMultiDrag&&(ge(!1,n),de.forEach(function(t){R(t,"display","")}),e(),ce=!1,t())},hideClone:function(t){var e=this,n=(t.sortable,t.cloneNowHidden),t=t.cancel;this.isMultiDrag&&(de.forEach(function(t){R(t,"display","none"),e.options.removeCloneOnHide&&t.parentNode&&t.parentNode.removeChild(t)}),n(),ce=!0,t())},dragStartGlobal:function(t){t.sortable;!this.isMultiDrag&&ae&&ae.multiDrag._deselectMultiDrag(),ue.forEach(function(t){t.sortableIndex=j(t)}),ue=ue.sort(function(t,e){return t.sortableIndex-e.sortableIndex}),pe=!0},dragStarted:function(t){var e,n=this,t=t.sortable;this.isMultiDrag&&(this.options.sort&&(t.captureAnimationState(),this.options.animation&&(ue.forEach(function(t){t!==le&&R(t,"position","absolute")}),e=X(le,!1,!0,!0),ue.forEach(function(t){t!==le&&C(t,e)}),he=fe=!0)),t.animateAll(function(){he=fe=!1,n.options.animation&&ue.forEach(function(t){T(t)}),n.options.sort&&me()}))},dragOver:function(t){var e=t.target,n=t.completed,t=t.cancel;fe&&~ue.indexOf(e)&&(n(!1),t())},revert:function(t){var n,o,e=t.fromSortable,i=t.rootEl,r=t.sortable,a=t.dragRect;1<ue.length&&(ue.forEach(function(t){r.addAnimationState({target:t,rect:fe?X(t):a}),T(t),t.fromRect=a,e.removeAnimationState(t)}),fe=!1,n=!this.options.removeCloneOnHide,o=i,ue.forEach(function(t,e){e=o.children[t.sortableIndex+(n?Number(e):0)];e?o.insertBefore(t,e):o.appendChild(t)}))},dragOverCompleted:function(t){var e,n=t.sortable,o=t.isOwner,i=t.insertion,r=t.activeSortable,a=t.parentEl,l=t.putSortable,t=this.options;i&&(o&&r._hideClone(),he=!1,t.animation&&1<ue.length&&(fe||!o&&!r.options.sort&&!l)&&(e=X(le,!1,!0,!0),ue.forEach(function(t){t!==le&&(C(t,e),a.appendChild(t))}),fe=!0),o||(fe||me(),1<ue.length?(o=ce,r._showClone(n),r.options.animation&&!ce&&o&&de.forEach(function(t){r.addAnimationState({target:t,rect:se}),t.fromRect=se,t.thisAnimationDuration=null})):r._showClone(n)))},dragOverAnimationCapture:function(t){var e=t.dragRect,n=t.isOwner,t=t.activeSortable;ue.forEach(function(t){t.thisAnimationDuration=null}),t.options.animation&&!n&&t.multiDrag.isMultiDrag&&(se=a({},e),e=v(le,!0),se.top-=e.f,se.left-=e.e)},dragOverAnimationComplete:function(){fe&&(fe=!1,me())},drop:function(t){var e=t.originalEvent,n=t.rootEl,o=t.parentEl,i=t.sortable,r=t.dispatchSortableEvent,a=t.oldIndex,l=t.putSortable,s=l||this.sortable;if(e){var c,u,d,h=this.options,f=o.children;if(!pe)if(h.multiDragKey&&!this.multiDragKeyDown&&this._deselectMultiDrag(),k(le,h.selectedClass,!~ue.indexOf(le)),~ue.indexOf(le))ue.splice(ue.indexOf(le),1),re=null,z({sortable:i,rootEl:n,name:"deselect",targetEl:le,originalEvent:e});else{if(ue.push(le),z({sortable:i,rootEl:n,name:"select",targetEl:le,originalEvent:e}),e.shiftKey&&re&&i.el.contains(re)){var p=j(re),t=j(le);if(~p&&~t&&p!==t)for(var g,m=p<t?(g=p,t):(g=t,p+1);g<m;g++)~ue.indexOf(f[g])||(k(f[g],h.selectedClass,!0),ue.push(f[g]),z({sortable:i,rootEl:n,name:"select",targetEl:f[g],originalEvent:e}))}else re=le;ae=s}pe&&this.isMultiDrag&&(fe=!1,(o[K].options.sort||o!==n)&&1<ue.length&&(c=X(le),u=j(le,":not(."+this.options.selectedClass+")"),!he&&h.animation&&(le.thisAnimationDuration=null),s.captureAnimationState(),he||(h.animation&&(le.fromRect=c,ue.forEach(function(t){var e;t.thisAnimationDuration=null,t!==le&&(e=fe?X(t):c,t.fromRect=e,s.addAnimationState({target:t,rect:e}))})),me(),ue.forEach(function(t){f[u]?o.insertBefore(t,f[u]):o.appendChild(t),u++}),a===j(le)&&(d=!1,ue.forEach(function(t){t.sortableIndex!==j(t)&&(d=!0)}),d&&(r("update"),r("sort")))),ue.forEach(function(t){T(t)}),s.animateAll()),ae=s),(n===o||l&&"clone"!==l.lastPutMode)&&de.forEach(function(t){t.parentNode&&t.parentNode.removeChild(t)})}},nullingGlobal:function(){this.isMultiDrag=pe=!1,de.length=0},destroyGlobal:function(){this._deselectMultiDrag(),f(document,"pointerup",this._deselectMultiDrag),f(document,"mouseup",this._deselectMultiDrag),f(document,"touchend",this._deselectMultiDrag),f(document,"keydown",this._checkKeyDown),f(document,"keyup",this._checkKeyUp)},_deselectMultiDrag:function(t){if(!(void 0!==pe&&pe||ae!==this.sortable||t&&P(t.target,this.options.draggable,this.sortable.el,!1)||t&&0!==t.button))for(;ue.length;){var e=ue[0];k(e,this.options.selectedClass,!1),ue.shift(),z({sortable:this.sortable,rootEl:this.sortable.el,name:"deselect",targetEl:e,originalEvent:t})}},_checkKeyDown:function(t){t.key===this.options.multiDragKey&&(this.multiDragKeyDown=!0)},_checkKeyUp:function(t){t.key===this.options.multiDragKey&&(this.multiDragKeyDown=!1)}},a(t,{pluginName:"multiDrag",utils:{select:function(t){var e=t.parentNode[K];e&&e.options.multiDrag&&!~ue.indexOf(t)&&(ae&&ae!==e&&(ae.multiDrag._deselectMultiDrag(),ae=e),k(t,e.options.selectedClass,!0),ue.push(t))},deselect:function(t){var e=t.parentNode[K],n=ue.indexOf(t);e&&e.options.multiDrag&&~n&&(k(t,e.options.selectedClass,!1),ue.splice(n,1))}},eventProperties:function(){var n=this,o=[],i=[];return ue.forEach(function(t){var e;o.push({multiDragElement:t,index:t.sortableIndex}),e=fe&&t!==le?-1:fe?j(t,":not(."+n.options.selectedClass+")"):j(t),i.push({multiDragElement:t,index:e})}),{items:r(ue),clones:[].concat(de),oldIndicies:o,newIndicies:i}},optionListeners:{multiDragKey:function(t){return"ctrl"===(t=t.toLowerCase())?t="Control":1<t.length&&(t=t.charAt(0).toUpperCase()+t.substr(1)),t}}})}),Ft});/* https://cdn.jsdelivr.net/npm/baklavajs@2.7.0/dist/bundle.js */
"use strict"; var BaklavaJS = (() => {
    var Ls = Object.defineProperty; var _c = Object.getOwnPropertyDescriptor; var yc = Object.getOwnPropertyNames; var Ec = Object.prototype.hasOwnProperty; var Bn = (e, t) => { for (var n in t) Ls(e, n, { get: t[n], enumerable: !0 }) }, bc = (e, t, n, o) => { if (t && typeof t == "object" || typeof t == "function") for (let s of yc(t)) !Ec.call(e, s) && s !== n && Ls(e, s, { get: () => t[s], enumerable: !(o = _c(t, s)) || o.enumerable }); return e }; var Nc = e => bc(Ls({}, "__esModule", { value: !0 }), e); var Qh = {}; Bn(Qh, { Core: () => js, Engine: () => Gs, InterfaceTypes: () => qs, RendererVue: () => yr, createBaklava: () => Zh }); var js = {}; Bn(js, { AbstractNode: () => vn, Connection: () => mn, DummyConnection: () => Jt, DynamicNode: () => ko, Editor: () => Kn, GRAPH_INPUT_NODE_TYPE: () => vt, GRAPH_NODE_TYPE_PREFIX: () => Zt, GRAPH_OUTPUT_NODE_TYPE: () => gt, Graph: () => it, GraphInputNode: () => Vt, GraphOutputNode: () => At, GraphTemplate: () => Qt, Node: () => Mt, NodeInterface: () => ye, createGraphNodeType: () => Bs, defineDynamicNode: () => Tc, defineNode: () => Cc, getGraphNodeTypeString: () => _t }); var De = []; for (let e = 0; e < 256; ++e)De.push((e + 256).toString(16).slice(1)); function Or(e, t = 0) { return (De[e[t + 0]] + De[e[t + 1]] + De[e[t + 2]] + De[e[t + 3]] + "-" + De[e[t + 4]] + De[e[t + 5]] + "-" + De[e[t + 6]] + De[e[t + 7]] + "-" + De[e[t + 8]] + De[e[t + 9]] + "-" + De[e[t + 10]] + De[e[t + 11]] + De[e[t + 12]] + De[e[t + 13]] + De[e[t + 14]] + De[e[t + 15]]).toLowerCase() } var Hs, wc = new Uint8Array(16); function Fs() { if (!Hs) { if (typeof crypto > "u" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"); Hs = crypto.getRandomValues.bind(crypto) } return Hs(wc) } var Oc = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Us = { randomUUID: Oc }; function xc(e, t, n) { if (Us.randomUUID && !t && !e) return Us.randomUUID(); e = e || {}; let o = e.random ?? e.rng?.() ?? Fs(); if (o.length < 16) throw new Error("Random bytes length must be >= 16"); if (o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, t) { if (n = n || 0, n < 0 || n + 16 > t.length) throw new RangeError(`UUID byte range ${n}:${n + 15} is out of buffer bounds`); for (let s = 0; s < 16; ++s)t[n + s] = o[s]; return t } return Or(o) } var Re = xc; var ot = class {
        constructor() { this.listenerMap = new Map, this._listeners = [], this.proxyMap = new Map, this.proxies = [] } get listeners() { return this._listeners.concat(this.proxies.flatMap(t => t())) } subscribe(t, n) {
            this.listenerMap.has(t) && (console.warn(`Already subscribed. Unsubscribing for you.
Please check that you don't accidentally use the same token twice to register two different handlers for the same event/hook.`), this.unsubscribe(t)), this.listenerMap.set(t, n), this._listeners.push(n)
        } unsubscribe(t) { if (this.listenerMap.has(t)) { let n = this.listenerMap.get(t); this.listenerMap.delete(t); let o = this._listeners.indexOf(n); o >= 0 && this._listeners.splice(o, 1) } } registerProxy(t, n) {
            this.proxyMap.has(t) && (console.warn(`Already subscribed. Unsubscribing for you.
Please check that you don't accidentally use the same token twice to register two different proxies for the same event/hook.`), this.unregisterProxy(t)), this.proxyMap.set(t, n), this.proxies.push(n)
        } unregisterProxy(t) { if (!this.proxyMap.has(t)) return; let n = this.proxyMap.get(t); this.proxyMap.delete(t); let o = this.proxies.indexOf(n); o >= 0 && this.proxies.splice(o, 1) }
    }; var te = class extends ot { constructor(t) { super(), this.entity = t } emit(t) { this.listeners.forEach(n => n(t, this.entity)) } }, _e = class extends ot { constructor(t) { super(), this.entity = t } emit(t) { let n = !1, o = () => [n = !0]; for (let s of Array.from(this.listeners.values())) if (s(t, o, this.entity), n) return { prevented: !0 }; return { prevented: !1 } } }; var jn = class extends ot { execute(t, n) { let o = t; for (let s of this.listeners) o = s(o, n); return o } }, Ne = class extends jn { constructor(t) { super(), this.entity = t } execute(t) { return super.execute(t, this.entity) } }, Do = class extends ot { constructor(t) { super(), this.entity = t } execute(t) { let n = []; for (let o of this.listeners) n.push(o(t, this.entity)); return n } }; function st() { let e = Symbol(), t = new Map, n = new Set, o = (l, u) => { u instanceof ot && u.registerProxy(e, () => { var c, d; return (d = (c = t.get(l)) === null || c === void 0 ? void 0 : c.listeners) !== null && d !== void 0 ? d : [] }) }, s = l => { let u = new ot; t.set(l, u), n.forEach(c => o(l, c[l])) }, i = l => { n.add(l); for (let u of t.keys()) o(u, l[u]) }, r = l => { for (let u of t.keys()) l[u] instanceof ot && l[u].unregisterProxy(e); n.delete(l) }, a = () => { n.forEach(l => r(l)), t.clear() }; return new Proxy({}, { get(l, u) { return u === "addTarget" ? i : u === "removeTarget" ? r : u === "destroy" ? a : typeof u != "string" || u.startsWith("_") ? l[u] : (t.has(u) || s(u), t.get(u)) } }) } var mn = class { constructor(t, n) { if (this.destructed = !1, this.events = { destruct: new te(this) }, !t || !n) throw new Error("Cannot initialize connection with null/undefined for 'from' or 'to' values"); this.id = Re(), this.from = t, this.to = n, this.from.connectionCount++, this.to.connectionCount++ } destruct() { this.events.destruct.emit(), this.from.connectionCount--, this.to.connectionCount--, this.destructed = !0 } }, Jt = class { constructor(t, n) { if (!t || !n) throw new Error("Cannot initialize connection with null/undefined for 'from' or 'to' values"); this.id = Re(), this.from = t, this.to = n } }; function Wn(e, t) { return Object.fromEntries(Object.entries(e).map(([n, o]) => [n, t(o)])) } var vn = class { constructor() { this._title = "", this.id = Re(), this.events = { loaded: new te(this), beforeAddInput: new _e(this), addInput: new te(this), beforeRemoveInput: new _e(this), removeInput: new te(this), beforeAddOutput: new _e(this), addOutput: new te(this), beforeRemoveOutput: new _e(this), removeOutput: new te(this), beforeTitleChanged: new _e(this), titleChanged: new te(this), update: new te(this) }, this.hooks = { beforeLoad: new Ne(this), afterSave: new Ne(this) } } get graph() { return this.graphInstance } get title() { return this._title } set title(t) { this.events.beforeTitleChanged.emit(t).prevented || (this._title = t, this.events.titleChanged.emit(t)) } addInput(t, n) { return this.addInterface("input", t, n) } addOutput(t, n) { return this.addInterface("output", t, n) } removeInput(t) { return this.removeInterface("input", t) } removeOutput(t) { return this.removeInterface("output", t) } registerGraph(t) { this.graphInstance = t } load(t) { this.hooks.beforeLoad.execute(t), this.id = t.id, this._title = t.title, Object.entries(t.inputs).forEach(([n, o]) => { this.inputs[n] && (this.inputs[n].load(o), this.inputs[n].nodeId = this.id) }), Object.entries(t.outputs).forEach(([n, o]) => { this.outputs[n] && (this.outputs[n].load(o), this.outputs[n].nodeId = this.id) }), this.events.loaded.emit(this) } save() { let t = Wn(this.inputs, s => s.save()), n = Wn(this.outputs, s => s.save()), o = { type: this.type, id: this.id, title: this.title, inputs: t, outputs: n }; return this.hooks.afterSave.execute(o) } onPlaced() { } onDestroy() { } initializeIo() { Object.entries(this.inputs).forEach(([t, n]) => this.initializeIntf("input", t, n)), Object.entries(this.outputs).forEach(([t, n]) => this.initializeIntf("output", t, n)) } initializeIntf(t, n, o) { o.isInput = t === "input", o.nodeId = this.id, o.events.setValue.subscribe(this, () => this.events.update.emit({ type: t, name: n, intf: o })) } addInterface(t, n, o) { let s = t === "input" ? this.events.beforeAddInput : this.events.beforeAddOutput, i = t === "input" ? this.events.addInput : this.events.addOutput, r = t === "input" ? this.inputs : this.outputs; return s.emit(o).prevented ? !1 : (r[n] = o, this.initializeIntf(t, n, o), i.emit(o), !0) } removeInterface(t, n) { let o = t === "input" ? this.events.beforeRemoveInput : this.events.beforeRemoveOutput, s = t === "input" ? this.events.removeInput : this.events.removeOutput, i = t === "input" ? this.inputs[n] : this.outputs[n]; if (!i || o.emit(i).prevented) return !1; if (i.connectionCount > 0) if (this.graphInstance) this.graphInstance.connections.filter(a => a.from === i || a.to === i).forEach(a => { this.graphInstance.removeConnection(a) }); else throw new Error("Interface is connected, but no graph instance is specified. Unable to delete interface"); return i.events.setValue.unsubscribe(this), t === "input" ? delete this.inputs[n] : delete this.outputs[n], s.emit(i), !0 } }, Mt = class extends vn { load(t) { super.load(t) } save() { return super.save() } }; function Cc(e) { return class extends Mt { constructor() { var t, n; super(), this.type = e.type, this.inputs = {}, this.outputs = {}, this.calculate = e.calculate ? (o, s) => e.calculate.call(this, o, s) : void 0, this._title = (t = e.title) !== null && t !== void 0 ? t : e.type, this.executeFactory("input", e.inputs), this.executeFactory("output", e.outputs), (n = e.onCreate) === null || n === void 0 || n.call(this) } onPlaced() { var t; (t = e.onPlaced) === null || t === void 0 || t.call(this) } onDestroy() { var t; (t = e.onDestroy) === null || t === void 0 || t.call(this) } executeFactory(t, n) { Object.keys(n || {}).forEach(o => { let s = n[o](); t === "input" ? this.addInput(o, s) : this.addOutput(o, s) }) } } } var ko = class extends Mt { }; function Tc(e) { return class extends ko { constructor() { var t, n, o, s; super(), this.type = e.type, this.inputs = {}, this.outputs = {}, this.preventUpdate = !1, this.staticInputKeys = Object.keys((t = e.inputs) !== null && t !== void 0 ? t : {}), this.staticOutputKeys = Object.keys((n = e.outputs) !== null && n !== void 0 ? n : {}), this._title = (o = e.title) !== null && o !== void 0 ? o : e.type, this.executeFactory("input", e.inputs), this.executeFactory("output", e.outputs), e.calculate && (this.calculate = (i, r) => { var a; return (a = e.calculate) === null || a === void 0 ? void 0 : a.call(this, i, r) }), (s = e.onCreate) === null || s === void 0 || s.call(this) } onPlaced() { var t; this.events.update.subscribe(this, n => { n && (n.type === "input" && this.staticInputKeys.includes(n.name) || n.type === "output" && this.staticOutputKeys.includes(n.name)) && this.onUpdate() }), this.onUpdate(), (t = e.onPlaced) === null || t === void 0 || t.call(this) } onDestroy() { var t; (t = e.onDestroy) === null || t === void 0 || t.call(this) } load(t) { this.preventUpdate = !0, this.hooks.beforeLoad.execute(t), this.id = t.id, this.title = t.title; for (let n of this.staticInputKeys) this.inputs[n].load(t.inputs[n]), this.inputs[n].nodeId = this.id; for (let n of this.staticOutputKeys) this.outputs[n].load(t.outputs[n]), this.outputs[n].nodeId = this.id; this.preventUpdate = !1, this.onUpdate(), this.preventUpdate = !0; for (let n of Object.keys(t.inputs)) this.staticInputKeys.includes(n) || (this.inputs[n].load(t.inputs[n]), this.inputs[n].nodeId = this.id); for (let n of Object.keys(t.outputs)) this.staticOutputKeys.includes(n) || (this.outputs[n].load(t.outputs[n]), this.outputs[n].nodeId = this.id); this.preventUpdate = !1, this.events.loaded.emit(this) } onUpdate() { var t, n, o, s; if (this.preventUpdate) return; this.graph && this.graph.activeTransactions++; let i = this.getStaticValues(this.staticInputKeys, this.inputs), r = this.getStaticValues(this.staticOutputKeys, this.outputs), a = e.onUpdate.call(this, i, r); this.updateInterfaces("input", (t = a.inputs) !== null && t !== void 0 ? t : {}, (n = a.forceUpdateInputs) !== null && n !== void 0 ? n : []), this.updateInterfaces("output", (o = a.outputs) !== null && o !== void 0 ? o : {}, (s = a.forceUpdateOutputs) !== null && s !== void 0 ? s : []), this.graph && this.graph.activeTransactions-- } getStaticValues(t, n) { let o = {}; for (let s of t) o[s] = n[s].value; return o } updateInterfaces(t, n, o) { let s = t === "input" ? this.staticInputKeys : this.staticOutputKeys, i = t === "input" ? this.inputs : this.outputs; for (let r of Object.keys(i)) s.includes(r) || n[r] && !o.includes(r) || (t === "input" ? this.removeInput(r) : this.removeOutput(r)); for (let r of Object.keys(n)) { if (i[r]) continue; let a = n[r](); t === "input" ? this.addInput(r, a) : this.addOutput(r, a) } } executeFactory(t, n) { Object.keys(n || {}).forEach(o => { let s = n[o](); t === "input" ? this.addInput(o, s) : this.addOutput(o, s) }) } } } var ye = class { set connectionCount(t) { this._connectionCount = t, this.events.setConnectionCount.emit(t) } get connectionCount() { return this._connectionCount } set value(t) { this.events.beforeSetValue.emit(t).prevented || (this._value = t, this.events.setValue.emit(t)) } get value() { return this._value } constructor(t, n) { this.id = Re(), this.nodeId = "", this.port = !0, this.hidden = !1, this.events = { setConnectionCount: new te(this), beforeSetValue: new _e(this), setValue: new te(this), updated: new te(this) }, this.hooks = { load: new Ne(this), save: new Ne(this) }, this._connectionCount = 0, this.name = t, this._value = n } load(t) { this.id = t.id, this.templateId = t.templateId, this.value = t.value, this.hooks.load.execute(t) } save() { let t = { id: this.id, templateId: this.templateId, value: this.value }; return this.hooks.save.execute(t) } setComponent(t) { return this.component = t, this } setPort(t) { return this.port = t, this } setHidden(t) { return this.hidden = t, this } use(t, ...n) { return t(this, ...n), this } }; var vt = "__baklava_SubgraphInputNode", gt = "__baklava_SubgraphOutputNode", Io = class extends Mt { constructor() { super(), this.graphInterfaceId = Re() } onPlaced() { super.onPlaced(), this.initializeIo() } save() { return { ...super.save(), graphInterfaceId: this.graphInterfaceId } } load(t) { super.load(t), this.graphInterfaceId = t.graphInterfaceId } }, Vt = class extends Io { constructor() { super(...arguments), this.type = vt, this.inputs = { name: new ye("Name", "Input") }, this.outputs = { placeholder: new ye("Value", void 0) } } static isGraphInputNode(t) { return t.type === vt } }, At = class extends Io { constructor() { super(...arguments), this.type = gt, this.inputs = { name: new ye("Name", "Output"), placeholder: new ye("Value", void 0) }, this.outputs = { output: new ye("Output", void 0).setHidden(!0) }, this.calculate = ({ placeholder: t }) => ({ output: t }) } static isGraphOutputNode(t) { return t.type === gt } }; var it = class { get nodes() { return this._nodes } get connections() { return this._connections } get loading() { return this._loading } get destroying() { return this._destroying } get inputs() { return this.nodes.filter(n => n.type === vt).map(n => ({ id: n.graphInterfaceId, name: n.inputs.name.value, nodeId: n.id, nodeInterfaceId: n.outputs.placeholder.id })) } get outputs() { return this.nodes.filter(n => n.type === gt).map(n => ({ id: n.graphInterfaceId, name: n.inputs.name.value, nodeId: n.id, nodeInterfaceId: n.outputs.output.id })) } constructor(t, n) { this.id = Re(), this.activeTransactions = 0, this._nodes = [], this._connections = [], this._loading = !1, this._destroying = !1, this.events = { beforeAddNode: new _e(this), addNode: new te(this), beforeRemoveNode: new _e(this), removeNode: new te(this), beforeAddConnection: new _e(this), addConnection: new te(this), checkConnection: new _e(this), beforeRemoveConnection: new _e(this), removeConnection: new te(this) }, this.hooks = { save: new Ne(this), load: new Ne(this), checkConnection: new Do(this) }, this.nodeEvents = st(), this.nodeHooks = st(), this.connectionEvents = st(), this.editor = t, this.template = n, t.registerGraph(this) } addNode(t) { if (!this.events.beforeAddNode.emit(t).prevented) return this.nodeEvents.addTarget(t.events), this.nodeHooks.addTarget(t.hooks), t.registerGraph(this), this._nodes.push(t), t = this.nodes.find(n => n.id === t.id), t.onPlaced(), this.events.addNode.emit(t), t } removeNode(t) { if (this.nodes.includes(t)) { if (this.events.beforeRemoveNode.emit(t).prevented) return; let n = [...Object.values(t.inputs), ...Object.values(t.outputs)]; this.connections.filter(o => n.includes(o.from) || n.includes(o.to)).forEach(o => this.removeConnection(o)), this._nodes.splice(this.nodes.indexOf(t), 1), this.events.removeNode.emit(t), t.onDestroy(), this.nodeEvents.removeTarget(t.events), this.nodeHooks.removeTarget(t.hooks) } } addConnection(t, n) { let o = this.checkConnection(t, n); if (!o.connectionAllowed || this.events.beforeAddConnection.emit({ from: t, to: n }).prevented) return; for (let i of o.connectionsInDanger) { let r = this.connections.find(a => a.id === i.id); r && this.removeConnection(r) } let s = new mn(o.dummyConnection.from, o.dummyConnection.to); return this.internalAddConnection(s), s } removeConnection(t) { if (this.connections.includes(t)) { if (this.events.beforeRemoveConnection.emit(t).prevented) return; t.destruct(), this._connections.splice(this.connections.indexOf(t), 1), this.events.removeConnection.emit(t), this.connectionEvents.removeTarget(t.events) } } checkConnection(t, n) { if (!t || !n) return { connectionAllowed: !1 }; let o = this.findNodeById(t.nodeId), s = this.findNodeById(n.nodeId); if (o && s && o === s) return { connectionAllowed: !1 }; if (t.isInput && !n.isInput) { let a = t; t = n, n = a } if (t.isInput || !n.isInput) return { connectionAllowed: !1 }; if (this.connections.some(a => a.from === t && a.to === n)) return { connectionAllowed: !1 }; if (this.events.checkConnection.emit({ from: t, to: n }).prevented) return { connectionAllowed: !1 }; let i = this.hooks.checkConnection.execute({ from: t, to: n }); if (i.some(a => !a.connectionAllowed)) return { connectionAllowed: !1 }; let r = Array.from(new Set(i.flatMap(a => a.connectionsInDanger))); return { connectionAllowed: !0, dummyConnection: new Jt(t, n), connectionsInDanger: r } } findNodeInterface(t) { for (let n of this.nodes) { for (let o in n.inputs) { let s = n.inputs[o]; if (s.id === t) return s } for (let o in n.outputs) { let s = n.outputs[o]; if (s.id === t) return s } } } findNodeById(t) { return this.nodes.find(n => n.id === t) } load(t) { try { this._loading = !0; let n = []; for (let o = this.connections.length - 1; o >= 0; o--)this.removeConnection(this.connections[o]); for (let o = this.nodes.length - 1; o >= 0; o--)this.removeNode(this.nodes[o]); this.id = t.id; for (let o of t.nodes) { let s = this.editor.nodeTypes.get(o.type); if (!s) { n.push(`Node type ${o.type} is not registered`); continue } let i = new s.type; this.addNode(i), i.load(o) } for (let o of t.connections) { let s = this.findNodeInterface(o.from), i = this.findNodeInterface(o.to); if (s) if (i) { let r = new mn(s, i); r.id = o.id, this.internalAddConnection(r) } else { n.push(`Could not find interface with id ${o.to}`); continue } else { n.push(`Could not find interface with id ${o.from}`); continue } } return this.hooks.load.execute(t), n } finally { this._loading = !1 } } save() { let t = { id: this.id, nodes: this.nodes.map(n => n.save()), connections: this.connections.map(n => ({ id: n.id, from: n.from.id, to: n.to.id })), inputs: this.inputs, outputs: this.outputs }; return this.hooks.save.execute(t) } destroy() { this._destroying = !0; for (let t of this.nodes) this.removeNode(t); this.editor.unregisterGraph(this) } internalAddConnection(t) { this.connectionEvents.addTarget(t.events), this._connections.push(t), this.events.addConnection.emit(t) } }; var Zt = "__baklava_GraphNode-"; function _t(e) { return Zt + e.id } var Sc = ["component", "connectionCount", "events", "hidden", "hooks", "id", "isInput", "name", "nodeId", "port", "templateId", "value"]; function Bs(e) { return class extends vn { constructor() { super(...arguments), this.type = _t(e), this.inputs = {}, this.outputs = {}, this.template = e, this.calculate = async (n, o) => { var s; if (!this.subgraph) throw new Error(`GraphNode ${this.id}: calculate called without subgraph being initialized`); if (!o.engine || typeof o.engine != "object") throw new Error(`GraphNode ${this.id}: calculate called but no engine provided in context`); let i = o.engine.getInputValues(this.subgraph); for (let l of this.subgraph.inputs) i.set(l.nodeInterfaceId, n[l.id]); let r = await o.engine.runGraph(this.subgraph, i, o.globalValues), a = {}; for (let l of this.subgraph.outputs) a[l.id] = (s = r.get(l.nodeId)) === null || s === void 0 ? void 0 : s.get("output"); return a._calculationResults = r, a } } get title() { return this._title } set title(n) { this.template.name = n } load(n) { if (!this.subgraph) throw new Error("Cannot load a graph node without a graph"); if (!this.template) throw new Error("Unable to load graph node without graph template"); this.subgraph.load(n.graphState), super.load(n) } save() { if (!this.subgraph) throw new Error("Cannot save a graph node without a graph"); return { ...super.save(), graphState: this.subgraph.save() } } onPlaced() { this.template.events.updated.subscribe(this, () => this.initialize()), this.template.events.nameChanged.subscribe(this, n => { this._title = n }), this.initialize() } onDestroy() { var n; this.template.events.updated.unsubscribe(this), this.template.events.nameChanged.unsubscribe(this), (n = this.subgraph) === null || n === void 0 || n.destroy() } initialize() { this.subgraph && this.subgraph.destroy(), this.subgraph = this.template.createGraph(), this._title = this.template.name, this.updateInterfaces(), this.events.update.emit(null) } updateInterfaces() { if (!this.subgraph) throw new Error("Trying to update interfaces without graph instance"); for (let n of this.subgraph.inputs) n.id in this.inputs ? this.inputs[n.id].name = n.name : this.addInput(n.id, this.createProxyInterface(n, !0)); for (let n of Object.keys(this.inputs)) this.subgraph.inputs.some(o => o.id === n) || this.removeInput(n); for (let n of this.subgraph.outputs) n.id in this.outputs ? this.outputs[n.id].name = n.name : this.addOutput(n.id, this.createProxyInterface(n, !1)); for (let n of Object.keys(this.outputs)) this.subgraph.outputs.some(o => o.id === n) || this.removeOutput(n); this.addOutput("_calculationResults", new ye("_calculationResults", void 0).setHidden(!0)) } createProxyInterface(n, o) { let s = new ye(n.name, void 0); return new Proxy(s, { get: (i, r) => { var a, l, u; if (Sc.includes(r) || r in i || typeof r == "string" && r.startsWith("__v_")) return Reflect.get(i, r); let c; if (o) { let h = (a = this.subgraph) === null || a === void 0 ? void 0 : a.nodes.find(v => Vt.isGraphInputNode(v) && v.graphInterfaceId === n.id); c = h?.outputs.placeholder.id } else { let h = (l = this.subgraph) === null || l === void 0 ? void 0 : l.nodes.find(v => At.isGraphOutputNode(v) && v.graphInterfaceId === n.id); c = h?.inputs.placeholder.id } let d = (u = this.subgraph) === null || u === void 0 ? void 0 : u.connections.find(h => { var v; return c === ((v = o ? h.from : h.to) === null || v === void 0 ? void 0 : v.id) }), p = o ? d?.to : d?.from; if (p) return Reflect.get(p, r) } }) } } } var Qt = class e { static fromGraph(t, n) { return new e(t.save(), n) } get name() { return this._name } set name(t) { this._name = t, this.events.nameChanged.emit(t); let n = this.editor.nodeTypes.get(_t(this)); n && (n.title = t) } get inputs() { return this.nodes.filter(n => n.type === vt).map(n => ({ id: n.graphInterfaceId, name: n.inputs.name.value, nodeId: n.id, nodeInterfaceId: n.outputs.placeholder.id })) } get outputs() { return this.nodes.filter(n => n.type === gt).map(n => ({ id: n.graphInterfaceId, name: n.inputs.name.value, nodeId: n.id, nodeInterfaceId: n.outputs.output.id })) } constructor(t, n) { this.id = Re(), this._name = "Subgraph", this.events = { nameChanged: new te(this), updated: new te(this) }, this.hooks = { beforeLoad: new Ne(this), afterSave: new Ne(this) }, this.editor = n, t.id && (this.id = t.id), t.name && (this._name = t.name), this.update(t) } update(t) { this.nodes = t.nodes, this.connections = t.connections, this.events.updated.emit() } save() { return { id: this.id, name: this.name, nodes: this.nodes, connections: this.connections, inputs: this.inputs, outputs: this.outputs } } createGraph(t) { let n = new Map, o = p => { let h = Re(); return n.set(p, h), h }, s = p => { let h = n.get(p); if (!h) throw new Error(`Unable to create graph from template: Could not map old id ${p} to new id`); return h }, i = p => Wn(p, h => ({ id: o(h.id), templateId: h.id, value: h.value })), r = this.nodes.map(p => ({ ...p, id: o(p.id), inputs: i(p.inputs), outputs: i(p.outputs) })), a = this.connections.map(p => ({ id: o(p.id), from: s(p.from), to: s(p.to) })), l = this.inputs.map(p => ({ id: p.id, name: p.name, nodeId: s(p.nodeId), nodeInterfaceId: s(p.nodeInterfaceId) })), u = this.outputs.map(p => ({ id: p.id, name: p.name, nodeId: s(p.nodeId), nodeInterfaceId: s(p.nodeInterfaceId) })), c = { id: Re(), nodes: r, connections: a, inputs: l, outputs: u }; return t || (t = new it(this.editor)), t.load(c).forEach(p => console.warn(p)), t.template = this, t } }; var Kn = class { get nodeTypes() { return this._nodeTypes } get graph() { return this._graph } get graphTemplates() { return this._graphTemplates } get graphs() { return this._graphs } get loading() { return this._loading } constructor() { this.events = { loaded: new te(this), beforeRegisterNodeType: new _e(this), registerNodeType: new te(this), beforeUnregisterNodeType: new _e(this), unregisterNodeType: new te(this), beforeAddGraphTemplate: new _e(this), addGraphTemplate: new te(this), beforeRemoveGraphTemplate: new _e(this), removeGraphTemplate: new te(this), registerGraph: new te(this), unregisterGraph: new te(this) }, this.hooks = { save: new Ne(this), load: new Ne(this) }, this.graphTemplateEvents = st(), this.graphTemplateHooks = st(), this.graphEvents = st(), this.graphHooks = st(), this.nodeEvents = st(), this.nodeHooks = st(), this.connectionEvents = st(), this._graphs = new Set, this._nodeTypes = new Map, this._graph = new it(this), this._graphTemplates = [], this._loading = !1, this.registerNodeType(Vt), this.registerNodeType(At) } registerNodeType(t, n) { var o, s; if (this.events.beforeRegisterNodeType.emit({ type: t, options: n }).prevented) return; let i = new t; this._nodeTypes.set(i.type, { type: t, category: (o = n?.category) !== null && o !== void 0 ? o : "default", title: (s = n?.title) !== null && s !== void 0 ? s : i.title }), this.events.registerNodeType.emit({ type: t, options: n }) } unregisterNodeType(t) { let n = typeof t == "string" ? t : new t().type; if (this.nodeTypes.has(n)) { if (this.events.beforeUnregisterNodeType.emit(n).prevented) return; this._nodeTypes.delete(n), this.events.unregisterNodeType.emit(n) } } addGraphTemplate(t) { if (this.events.beforeAddGraphTemplate.emit(t).prevented) return; this._graphTemplates.push(t), this.graphTemplateEvents.addTarget(t.events), this.graphTemplateHooks.addTarget(t.hooks); let n = Bs(t); this.registerNodeType(n, { category: "Subgraphs", title: t.name }), this.events.addGraphTemplate.emit(t) } removeGraphTemplate(t) { if (this.graphTemplates.includes(t)) { if (this.events.beforeRemoveGraphTemplate.emit(t).prevented) return; let n = _t(t); for (let o of [this.graph, ...this.graphs.values()]) { let s = o.nodes.filter(i => i.type === n); for (let i of s) o.removeNode(i) } this.unregisterNodeType(n), this._graphTemplates.splice(this._graphTemplates.indexOf(t), 1), this.graphTemplateEvents.removeTarget(t.events), this.graphTemplateHooks.removeTarget(t.hooks), this.events.removeGraphTemplate.emit(t) } } registerGraph(t) { this.graphEvents.addTarget(t.events), this.graphHooks.addTarget(t.hooks), this.nodeEvents.addTarget(t.nodeEvents), this.nodeHooks.addTarget(t.nodeHooks), this.connectionEvents.addTarget(t.connectionEvents), this.events.registerGraph.emit(t), this._graphs.add(t) } unregisterGraph(t) { this.graphEvents.removeTarget(t.events), this.graphHooks.removeTarget(t.hooks), this.nodeEvents.removeTarget(t.nodeEvents), this.nodeHooks.removeTarget(t.nodeHooks), this.connectionEvents.removeTarget(t.connectionEvents), this.events.unregisterGraph.emit(t), this._graphs.delete(t) } load(t) { try { for (this._loading = !0, t = this.hooks.load.execute(t); this.graphTemplates.length > 0;)this.removeGraphTemplate(this.graphTemplates[0]); t.graphTemplates.forEach(o => { let s = new Qt(o, this); this.addGraphTemplate(s) }); let n = this._graph.load(t.graph); return this.events.loaded.emit(), n.forEach(o => console.warn(o)), n } finally { this._loading = !1 } } save() { let t = { graph: this.graph.save(), graphTemplates: this.graphTemplates.map(n => n.save()) }; return this.hooks.save.execute(t) } }; var Gs = {}; Bn(Gs, { BaseEngine: () => zn, CycleError: () => Gn, DependencyEngine: () => Ks, EngineStatus: () => Fe, allowMultipleConnections: () => Ic, applyResult: () => Dc, containsCycle: () => Ws, sortTopologically: () => Mo }); function Dc(e, t) { let n = new Map; t.graphs.forEach(o => { o.nodes.forEach(s => n.set(s.id, s)) }), e.forEach((o, s) => { let i = n.get(s); i && o.forEach((r, a) => { let l = i.outputs[a]; l && (l.value = r) }) }) } var Gn = class extends Error { constructor() { super("Cycle detected") } }; function kc(e) { return typeof e == "string" } function Mo(e, t) { let n = new Map, o = new Map, s = new Map, i, r; if (e instanceof it) i = e.nodes, r = e.connections; else { if (!t) throw new Error("Invalid argument value: expected array of connections"); i = e, r = t } i.forEach(u => { Object.values(u.inputs).forEach(c => n.set(c.id, u.id)), Object.values(u.outputs).forEach(c => n.set(c.id, u.id)) }), i.forEach(u => { let c = r.filter(p => p.from && n.get(p.from.id) === u.id), d = new Set(c.map(p => n.get(p.to.id)).filter(kc)); o.set(u.id, d), s.set(u, c) }); let a = i.slice(); r.forEach(u => { let c = a.findIndex(d => n.get(u.to.id) === d.id); c >= 0 && a.splice(c, 1) }); let l = []; for (; a.length > 0;) { let u = a.pop(); l.push(u); let c = o.get(u.id); for (; c.size > 0;) { let d = c.values().next().value; if (c.delete(d), Array.from(o.values()).every(p => !p.has(d))) { let p = i.find(h => h.id === d); a.push(p) } } } if (Array.from(o.values()).some(u => u.size > 0)) throw new Gn; return { calculationOrder: l, connectionsFromNode: s, interfaceIdToNodeId: n } } function Ws(e, t) { try { return Mo(e, t), !1 } catch (n) { if (n instanceof Gn) return !0; throw n } } var Fe; (function (e) { e.Running = "Running", e.Idle = "Idle", e.Paused = "Paused", e.Stopped = "Stopped" })(Fe || (Fe = {})); var zn = class { get status() { return this.isRunning ? Fe.Running : this.internalStatus } constructor(t) { this.editor = t, this.events = { beforeRun: new _e(this), afterRun: new te(this), statusChange: new te(this), beforeNodeCalculation: new te(this), afterNodeCalculation: new te(this) }, this.hooks = { gatherCalculationData: new Ne(this), transferData: new jn }, this.recalculateOrder = !0, this.internalStatus = Fe.Stopped, this.isRunning = !1, this.editor.nodeEvents.update.subscribe(this, (n, o) => { o.graph && !o.graph.loading && o.graph.activeTransactions === 0 && this.internalOnChange(o, n ?? void 0) }), this.editor.graphEvents.addNode.subscribe(this, (n, o) => { this.recalculateOrder = !0, !o.loading && o.activeTransactions === 0 && this.internalOnChange() }), this.editor.graphEvents.removeNode.subscribe(this, (n, o) => { this.recalculateOrder = !0, !o.loading && o.activeTransactions === 0 && this.internalOnChange() }), this.editor.graphEvents.addConnection.subscribe(this, (n, o) => { this.recalculateOrder = !0, !o.loading && o.activeTransactions === 0 && this.internalOnChange() }), this.editor.graphEvents.removeConnection.subscribe(this, (n, o) => { this.recalculateOrder = !0, !o.loading && o.activeTransactions === 0 && this.internalOnChange() }), this.editor.graphHooks.checkConnection.subscribe(this, n => this.checkConnection(n.from, n.to)) } start() { this.internalStatus === Fe.Stopped && (this.internalStatus = Fe.Idle, this.events.statusChange.emit(this.status)) } pause() { this.internalStatus === Fe.Idle && (this.internalStatus = Fe.Paused, this.events.statusChange.emit(this.status)) } resume() { this.internalStatus === Fe.Paused && (this.internalStatus = Fe.Idle, this.events.statusChange.emit(this.status)) } stop() { (this.internalStatus === Fe.Idle || this.internalStatus === Fe.Paused) && (this.internalStatus = Fe.Stopped, this.events.statusChange.emit(this.status)) } async runOnce(t, ...n) { if (this.events.beforeRun.emit(t).prevented) return null; try { this.isRunning = !0, this.events.statusChange.emit(this.status), this.recalculateOrder && this.calculateOrder(); let o = await this.execute(t, ...n); return this.events.afterRun.emit(o), o } finally { this.isRunning = !1, this.events.statusChange.emit(this.status) } } checkConnection(t, n) { if (t.templateId) { let i = this.findInterfaceByTemplateId(this.editor.graph.nodes, t.templateId); if (!i) return { connectionAllowed: !0, connectionsInDanger: [] }; t = i } if (n.templateId) { let i = this.findInterfaceByTemplateId(this.editor.graph.nodes, n.templateId); if (!i) return { connectionAllowed: !0, connectionsInDanger: [] }; n = i } let o = new Jt(t, n), s = this.editor.graph.connections.slice(); return n.allowMultipleConnections || (s = s.filter(i => i.to !== n)), s.push(o), Ws(this.editor.graph.nodes, s) ? { connectionAllowed: !1, connectionsInDanger: [] } : { connectionAllowed: !0, connectionsInDanger: n.allowMultipleConnections ? [] : this.editor.graph.connections.filter(i => i.to === n) } } calculateOrder() { this.recalculateOrder = !0 } async calculateWithoutData(...t) { let n = this.hooks.gatherCalculationData.execute(void 0); return await this.runOnce(n, ...t) } validateNodeCalculationOutput(t, n) { if (typeof n != "object") throw new Error(`Invalid calculation return value from node ${t.id} (type ${t.type})`); Object.keys(t.outputs).forEach(o => { if (!(o in n)) throw new Error(`Calculation return value from node ${t.id} (type ${t.type}) is missing key "${o}"`) }) } internalOnChange(t, n) { this.internalStatus === Fe.Idle && this.onChange(this.recalculateOrder, t, n) } findInterfaceByTemplateId(t, n) { for (let o of t) for (let s of [...Object.values(o.inputs), ...Object.values(o.outputs)]) if (s.templateId === n) return s; return null } }; var Ic = e => { e.allowMultipleConnections = !0 }, Ks = class extends zn {
        constructor(t) { super(t), this.order = new Map } start() { super.start(), this.recalculateOrder = !0, this.calculateWithoutData() } async runGraph(t, n, o) {
            this.order.has(t.id) || this.order.set(t.id, Mo(t)); let { calculationOrder: s, connectionsFromNode: i } = this.order.get(t.id), r = new Map; for (let a of s) {
                let l = {}; Object.entries(a.inputs).forEach(([c, d]) => { l[c] = this.getInterfaceValue(n, d.id) }), this.events.beforeNodeCalculation.emit({ inputValues: l, node: a }); let u; if (a.calculate) u = await a.calculate(l, { globalValues: o, engine: this }); else { u = {}; for (let [c, d] of Object.entries(a.outputs)) u[c] = this.getInterfaceValue(n, d.id) } this.validateNodeCalculationOutput(a, u), this.events.afterNodeCalculation.emit({ outputValues: u, node: a }), r.set(a.id, new Map(Object.entries(u))), i.has(a) && i.get(a).forEach(c => {
                    var d; let p = (d = Object.entries(a.outputs).find(([, v]) => v.id === c.from.id)) === null || d === void 0 ? void 0 : d[0]; if (!p) throw new Error(`Could not find key for interface ${c.from.id}
This is likely a Baklava internal issue. Please report it on GitHub.`); let h = this.hooks.transferData.execute(u[p], c); c.to.allowMultipleConnections ? n.has(c.to.id) ? n.get(c.to.id).push(h) : n.set(c.to.id, [h]) : n.set(c.to.id, h)
                })
            } return r
        } async execute(t) { this.recalculateOrder && (this.order.clear(), this.recalculateOrder = !1); let n = this.getInputValues(this.editor.graph); return await this.runGraph(this.editor.graph, n, t) } getInputValues(t) { let n = new Map; for (let o of t.nodes) Object.values(o.inputs).forEach(s => { s.connectionCount === 0 && n.set(s.id, s.value) }), o.calculate || Object.values(o.outputs).forEach(s => { n.set(s.id, s.value) }); return n } onChange(t) { this.recalculateOrder = t || this.recalculateOrder, this.calculateWithoutData() } getInterfaceValue(t, n) {
            if (!t.has(n)) throw new Error(`Could not find value for interface ${n}
This is likely a Baklava internal issue. Please report it on GitHub.`); return t.get(n)
        }
    }; var qs = {}; Bn(qs, { BaklavaInterfaceTypes: () => Ys, NodeInterfaceType: () => zs, getType: () => Ac, setType: () => Mc, setTypeForMultipleConnections: () => Vc }); var zs = class { constructor(t) { this.name = t, this.conversions = [] } addConversion(t, n = o => o) { return this.conversions.push({ targetType: t.name, transformationFunction: n }), this } }; function Mc(e, t) { e.type = t.name } function Vc(e, t) { e.type = t.name } function Ac(e) { return e.type } var Ys = class { constructor(t, n) { this.types = new Map, this.editor = t, this.editor.graphEvents.checkConnection.subscribe(this, ({ from: o, to: s }, i) => { let r = o.type, a = s.type; if (!(!r || !a) && !this.canConvert(r, a)) return i() }), n?.engine && n.engine.hooks.transferData.subscribe(this, (o, s) => { let i = s.from.type, r = s.to.type; return !i || !r ? o : this.convert(i, r, o) }), n?.viewPlugin && n.viewPlugin.hooks.renderInterface.subscribe(this, ({ intf: o, el: s }) => (o.type && s.setAttribute("data-interface-type", o.type), { intf: o, el: s })) } addTypes(...t) { return t.forEach(n => { this.types.set(n.name, n) }), this } getConversion(t, n) { var o, s; return (s = (o = this.types.get(t)) === null || o === void 0 ? void 0 : o.conversions.find(i => i.targetType === n)) !== null && s !== void 0 ? s : null } canConvert(t, n) { return t === n || this.types.has(t) && this.types.get(t).conversions.some(o => o.targetType === n) } convert(t, n, o) { if (t === n) return o; { let s = this.getConversion(t, n); if (s) return s.transformationFunction(o); throw Error(`Can not convert from "${t}" to "${n}"`) } } }; var yr = {}; Bn(yr, { BaklavaEditor: () => hr, ButtonInterface: () => Qi, ButtonInterfaceComponent: () => Jl, CheckboxInterface: () => er, CheckboxInterfaceComponent: () => Zl, Commands: () => rh, Components: () => Jh, DEFAULT_TOOLBAR_COMMANDS: () => pc, DEFAULT_TOOLBAR_SUBGRAPH_COMMANDS: () => mc, EditorComponent: () => hr, IntegerInterface: () => tr, IntegerInterfaceComponent: () => Ql, NumberInterface: () => nr, NumberInterfaceComponent: () => ec, SelectInterface: () => or, SelectInterfaceComponent: () => tc, SliderInterface: () => sr, SliderInterfaceComponent: () => nc, TOOLBAR_COMMANDS: () => fc, TOOLBAR_SUBGRAPH_COMMANDS: () => hc, TemporaryConnectionState: () => tt, TextInputInterface: () => To, TextInputInterfaceComponent: () => oc, TextInterface: () => ir, TextareaInputInterface: () => rr, TextareaInputInterfaceComponent: () => sc, displayInSidebar: () => eh, getDomElementOfNode: () => Wl, getDomElements: () => fn, getNodePosition: () => qd, getPortCoordinates: () => xo, isInputElement: () => lr, providePlugin: () => Al, provideTemporaryConnection: () => Pl, setNodePosition: () => Xd, useBaklava: () => _r, useCommandHandler: () => Xl, useDragMove: () => cr, useGraph: () => nt, useNodeCategories: () => ur, useTemporaryConnection: () => Ll, useTransform: () => dr, useViewModel: () => Ye }); function gn(e) { let t = Object.create(null); for (let n of e.split(",")) t[n] = 1; return n => n in t } var ce = {}, en = [], Ue = () => { }, Cr = () => !1, _n = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), Yn = e => e.startsWith("onUpdate:"), ge = Object.assign, qn = (e, t) => { let n = e.indexOf(t); n > -1 && e.splice(n, 1) }, Rc = Object.prototype.hasOwnProperty, re = (e, t) => Rc.call(e, t), W = Array.isArray, tn = e => Ao(e) === "[object Map]", Vo = e => Ao(e) === "[object Set]"; var q = e => typeof e == "function", ve = e => typeof e == "string", rt = e => typeof e == "symbol", de = e => e !== null && typeof e == "object", Js = e => (de(e) || q(e)) && q(e.then) && q(e.catch), Tr = Object.prototype.toString, Ao = e => Tr.call(e), Zs = e => Ao(e).slice(8, -1), Ro = e => Ao(e) === "[object Object]", $o = e => ve(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, yn = gn(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"); var Po = e => { let t = Object.create(null); return n => t[n] || (t[n] = e(n)) }, $c = /-(\w)/g, $e = Po(e => e.replace($c, (t, n) => n ? n.toUpperCase() : "")), Pc = /\B([A-Z])/g, yt = Po(e => e.replace(Pc, "-$1").toLowerCase()), nn = Po(e => e.charAt(0).toUpperCase() + e.slice(1)), Xn = Po(e => e ? `on${nn(e)}` : ""), Et = (e, t) => !Object.is(e, t), En = (e, ...t) => { for (let n = 0; n < e.length; n++)e[n](...t) }, bn = (e, t, n, o = !1) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: o, value: n }) }, Jn = e => { let t = parseFloat(e); return isNaN(t) ? e : t }, Qs = e => { let t = ve(e) ? Number(e) : NaN; return isNaN(t) ? e : t }, xr, Ft = () => xr || (xr = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function Ke(e) { if (W(e)) { let t = {}; for (let n = 0; n < e.length; n++) { let o = e[n], s = ve(o) ? Uc(o) : Ke(o); if (s) for (let i in s) t[i] = s[i] } return t } else if (ve(e) || de(e)) return e } var Lc = /;(?![^(]*\))/g, Hc = /:([^]+)/, Fc = /\/\*[^]*?\*\//g; function Uc(e) { let t = {}; return e.replace(Fc, "").split(Lc).forEach(n => { if (n) { let o = n.split(Hc); o.length > 1 && (t[o[0].trim()] = o[1].trim()) } }), t } function we(e) { let t = ""; if (ve(e)) t = e; else if (W(e)) for (let n = 0; n < e.length; n++) { let o = we(e[n]); o && (t += o + " ") } else if (de(e)) for (let n in e) e[n] && (t += n + " "); return t.trim() } var Sr = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Dr = gn(Sr), Bc = gn(Sr + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"); function Lo(e) { return !!e || e === "" } var kr = e => !!(e && e.__v_isRef === !0), Ee = e => ve(e) ? e : e == null ? "" : W(e) || de(e) && (e.toString === Tr || !q(e.toString)) ? kr(e) ? Ee(e.value) : JSON.stringify(e, Ir, 2) : String(e), Ir = (e, t) => kr(t) ? Ir(e, t.value) : tn(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((n, [o, s], i) => (n[Xs(o, i) + " =>"] = s, n), {}) } : Vo(t) ? { [`Set(${t.size})`]: [...t.values()].map(n => Xs(n)) } : rt(t) ? Xs(t) : de(t) && !W(t) && !Ro(t) ? String(t) : t, Xs = (e, t = "") => { var n; return rt(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e }; function jc(e, ...t) { console.warn(`[Vue warn] ${e}`, ...t) } var Pe, to = class { constructor(t = !1) { this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Pe, !t && Pe && (this.index = (Pe.scopes || (Pe.scopes = [])).push(this) - 1) } get active() { return this._active } pause() { if (this._active) { this._isPaused = !0; let t, n; if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].pause(); for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].pause() } } resume() { if (this._active && this._isPaused) { this._isPaused = !1; let t, n; if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].resume(); for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].resume() } } run(t) { if (this._active) { let n = Pe; try { return Pe = this, t() } finally { Pe = n } } } on() { ++this._on === 1 && (this.prevScope = Pe, Pe = this) } off() { this._on > 0 && --this._on === 0 && (Pe = this.prevScope, this.prevScope = void 0) } stop(t) { if (this._active) { this._active = !1; let n, o; for (n = 0, o = this.effects.length; n < o; n++)this.effects[n].stop(); for (this.effects.length = 0, n = 0, o = this.cleanups.length; n < o; n++)this.cleanups[n](); if (this.cleanups.length = 0, this.scopes) { for (n = 0, o = this.scopes.length; n < o; n++)this.scopes[n].stop(!0); this.scopes.length = 0 } if (!this.detached && this.parent && !t) { let s = this.parent.scopes.pop(); s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index) } this.parent = void 0 } } }; function zo() { return Pe } function fi(e, t = !1) { Pe && Pe.cleanups.push(e) } var pe; var ei = new WeakSet, wn = class { constructor(t) { this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Pe && Pe.active && Pe.effects.push(this) } pause() { this.flags |= 64 } resume() { this.flags & 64 && (this.flags &= -65, ei.has(this) && (ei.delete(this), this.trigger())) } notify() { this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Rr(this) } run() { if (!(this.flags & 1)) return this.fn(); this.flags |= 2, Mr(this), $r(this); let t = pe, n = ft; pe = this, ft = !0; try { return this.fn() } finally { Pr(this), pe = t, ft = n, this.flags &= -3 } } stop() { if (this.flags & 1) { for (let t = this.deps; t; t = t.nextDep)mi(t); this.deps = this.depsTail = void 0, Mr(this), this.onStop && this.onStop(), this.flags &= -2 } } trigger() { this.flags & 64 ? ei.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty() } runIfDirty() { oi(this) && this.run() } get dirty() { return oi(this) } }, Ar = 0, Qn, eo; function Rr(e, t = !1) { if (e.flags |= 8, t) { e.next = eo, eo = e; return } e.next = Qn, Qn = e } function pi() { Ar++ } function hi() { if (--Ar > 0) return; if (eo) { let t = eo; for (eo = void 0; t;) { let n = t.next; t.next = void 0, t.flags &= -9, t = n } } let e; for (; Qn;) { let t = Qn; for (Qn = void 0; t;) { let n = t.next; if (t.next = void 0, t.flags &= -9, t.flags & 1) try { t.trigger() } catch (o) { e || (e = o) } t = n } } if (e) throw e } function $r(e) { for (let t = e.deps; t; t = t.nextDep)t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t } function Pr(e) { let t, n = e.depsTail, o = n; for (; o;) { let s = o.prevDep; o.version === -1 ? (o === n && (n = s), mi(o), Wc(o)) : t = o, o.dep.activeLink = o.prevActiveLink, o.prevActiveLink = void 0, o = s } e.deps = t, e.depsTail = n } function oi(e) { for (let t = e.deps; t; t = t.nextDep)if (t.dep.version !== t.version || t.dep.computed && (Lr(t.dep.computed) || t.dep.version !== t.version)) return !0; return !!e._dirty } function Lr(e) { if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === no) || (e.globalVersion = no, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !oi(e)))) return; e.flags |= 2; let t = e.dep, n = pe, o = ft; pe = e, ft = !0; try { $r(e); let s = e.fn(e._value); (t.version === 0 || Et(s, e._value)) && (e.flags |= 128, e._value = s, t.version++) } catch (s) { throw t.version++, s } finally { pe = n, ft = o, Pr(e), e.flags &= -3 } } function mi(e, t = !1) { let { dep: n, prevSub: o, nextSub: s } = e; if (o && (o.nextSub = s, e.prevSub = void 0), s && (s.prevSub = o, e.nextSub = void 0), n.subs === e && (n.subs = o, !o && n.computed)) { n.computed.flags &= -5; for (let i = n.computed.deps; i; i = i.nextDep)mi(i, !0) } !t && !--n.sc && n.map && n.map.delete(n.key) } function Wc(e) { let { prevDep: t, nextDep: n } = e; t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0) } var ft = !0, Hr = []; function Ot() { Hr.push(ft), ft = !1 } function xt() { let e = Hr.pop(); ft = e === void 0 ? !0 : e } function Mr(e) { let { cleanup: t } = e; if (e.cleanup = void 0, t) { let n = pe; pe = void 0; try { t() } finally { pe = n } } } var no = 0, si = class { constructor(t, n) { this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0 } }, On = class { constructor(t) { this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0 } track(t) { if (!pe || !ft || pe === this.computed) return; let n = this.activeLink; if (n === void 0 || n.sub !== pe) n = this.activeLink = new si(pe, this), pe.deps ? (n.prevDep = pe.depsTail, pe.depsTail.nextDep = n, pe.depsTail = n) : pe.deps = pe.depsTail = n, Fr(n); else if (n.version === -1 && (n.version = this.version, n.nextDep)) { let o = n.nextDep; o.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = o), n.prevDep = pe.depsTail, n.nextDep = void 0, pe.depsTail.nextDep = n, pe.depsTail = n, pe.deps === n && (pe.deps = o) } return n } trigger(t) { this.version++, no++, this.notify(t) } notify(t) { pi(); try { for (let n = this.subs; n; n = n.prevSub)n.sub.notify() && n.sub.dep.notify() } finally { hi() } } }; function Fr(e) { if (e.dep.sc++, e.sub.flags & 4) { let t = e.dep.computed; if (t && !e.dep.subs) { t.flags |= 20; for (let o = t.deps; o; o = o.nextDep)Fr(o) } let n = e.dep.subs; n !== e && (e.prevSub = n, n && (n.nextSub = e)), e.dep.subs = e } } var Bo = new WeakMap, sn = Symbol(""), ii = Symbol(""), oo = Symbol(""); function ke(e, t, n) { if (ft && pe) { let o = Bo.get(e); o || Bo.set(e, o = new Map); let s = o.get(n); s || (o.set(n, s = new On), s.map = o, s.key = n), s.track() } } function bt(e, t, n, o, s, i) { let r = Bo.get(e); if (!r) { no++; return } let a = l => { l && l.trigger() }; if (pi(), t === "clear") r.forEach(a); else { let l = W(e), u = l && $o(n); if (l && n === "length") { let c = Number(o); r.forEach((d, p) => { (p === "length" || p === oo || !rt(p) && p >= c) && a(d) }) } else switch ((n !== void 0 || r.has(void 0)) && a(r.get(n)), u && a(r.get(oo)), t) { case "add": l ? u && a(r.get("length")) : (a(r.get(sn)), tn(e) && a(r.get(ii))); break; case "delete": l || (a(r.get(sn)), tn(e) && a(r.get(ii))); break; case "set": tn(e) && a(r.get(sn)); break } } hi() } function Kc(e, t) { let n = Bo.get(e); return n && n.get(t) } function Nn(e) { let t = ne(e); return t === e ? t : (ke(t, "iterate", oo), Ge(e) ? t : t.map(Ce)) } function io(e) { return ke(e = ne(e), "iterate", oo), e } var Gc = { __proto__: null, [Symbol.iterator]() { return ti(this, Symbol.iterator, Ce) }, concat(...e) { return Nn(this).concat(...e.map(t => W(t) ? Nn(t) : t)) }, entries() { return ti(this, "entries", e => (e[1] = Ce(e[1]), e)) }, every(e, t) { return Rt(this, "every", e, t, void 0, arguments) }, filter(e, t) { return Rt(this, "filter", e, t, n => n.map(Ce), arguments) }, find(e, t) { return Rt(this, "find", e, t, Ce, arguments) }, findIndex(e, t) { return Rt(this, "findIndex", e, t, void 0, arguments) }, findLast(e, t) { return Rt(this, "findLast", e, t, Ce, arguments) }, findLastIndex(e, t) { return Rt(this, "findLastIndex", e, t, void 0, arguments) }, forEach(e, t) { return Rt(this, "forEach", e, t, void 0, arguments) }, includes(...e) { return ni(this, "includes", e) }, indexOf(...e) { return ni(this, "indexOf", e) }, join(e) { return Nn(this).join(e) }, lastIndexOf(...e) { return ni(this, "lastIndexOf", e) }, map(e, t) { return Rt(this, "map", e, t, void 0, arguments) }, pop() { return Zn(this, "pop") }, push(...e) { return Zn(this, "push", e) }, reduce(e, ...t) { return Vr(this, "reduce", e, t) }, reduceRight(e, ...t) { return Vr(this, "reduceRight", e, t) }, shift() { return Zn(this, "shift") }, some(e, t) { return Rt(this, "some", e, t, void 0, arguments) }, splice(...e) { return Zn(this, "splice", e) }, toReversed() { return Nn(this).toReversed() }, toSorted(e) { return Nn(this).toSorted(e) }, toSpliced(...e) { return Nn(this).toSpliced(...e) }, unshift(...e) { return Zn(this, "unshift", e) }, values() { return ti(this, "values", Ce) } }; function ti(e, t, n) { let o = io(e), s = o[t](); return o !== e && !Ge(e) && (s._next = s.next, s.next = () => { let i = s._next(); return i.value && (i.value = n(i.value)), i }), s } var zc = Array.prototype; function Rt(e, t, n, o, s, i) { let r = io(e), a = r !== e && !Ge(e), l = r[t]; if (l !== zc[t]) { let d = l.apply(e, i); return a ? Ce(d) : d } let u = n; r !== e && (a ? u = function (d, p) { return n.call(this, Ce(d), p, e) } : n.length > 2 && (u = function (d, p) { return n.call(this, d, p, e) })); let c = l.call(r, u, o); return a && s ? s(c) : c } function Vr(e, t, n, o) { let s = io(e), i = n; return s !== e && (Ge(e) ? n.length > 3 && (i = function (r, a, l) { return n.call(this, r, a, l, e) }) : i = function (r, a, l) { return n.call(this, r, Ce(a), l, e) }), s[t](i, ...o) } function ni(e, t, n) { let o = ne(e); ke(o, "iterate", oo); let s = o[t](...n); return (s === -1 || s === !1) && ro(n[0]) ? (n[0] = ne(n[0]), o[t](...n)) : s } function Zn(e, t, n = []) { Ot(), pi(); let o = ne(e)[t].apply(e, n); return hi(), xt(), o } var Yc = gn("__proto__,__v_isRef,__isVue"), Ur = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(rt)); function qc(e) { rt(e) || (e = String(e)); let t = ne(this); return ke(t, "has", e), t.hasOwnProperty(e) } var jo = class { constructor(t = !1, n = !1) { this._isReadonly = t, this._isShallow = n } get(t, n, o) { if (n === "__v_skip") return t.__v_skip; let s = this._isReadonly, i = this._isShallow; if (n === "__v_isReactive") return !s; if (n === "__v_isReadonly") return s; if (n === "__v_isShallow") return i; if (n === "__v_raw") return o === (s ? i ? Kr : Wr : i ? jr : Br).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(o) ? t : void 0; let r = W(t); if (!s) { let l; if (r && (l = Gc[n])) return l; if (n === "hasOwnProperty") return qc } let a = Reflect.get(t, n, be(t) ? t : o); return (rt(n) ? Ur.has(n) : Yc(n)) || (s || ke(t, "get", n), i) ? a : be(a) ? r && $o(n) ? a : a.value : de(a) ? s ? gi(a) : Le(a) : a } }, Wo = class extends jo { constructor(t = !1) { super(!1, t) } set(t, n, o, s) { let i = t[n]; if (!this._isShallow) { let l = wt(i); if (!Ge(o) && !wt(o) && (i = ne(i), o = ne(o)), !W(t) && be(i) && !be(o)) return l ? !1 : (i.value = o, !0) } let r = W(t) && $o(n) ? Number(n) < t.length : re(t, n), a = Reflect.set(t, n, o, be(t) ? t : s); return t === ne(s) && (r ? Et(o, i) && bt(t, "set", n, o, i) : bt(t, "add", n, o)), a } deleteProperty(t, n) { let o = re(t, n), s = t[n], i = Reflect.deleteProperty(t, n); return i && o && bt(t, "delete", n, void 0, s), i } has(t, n) { let o = Reflect.has(t, n); return (!rt(n) || !Ur.has(n)) && ke(t, "has", n), o } ownKeys(t) { return ke(t, "iterate", W(t) ? "length" : sn), Reflect.ownKeys(t) } }, Ko = class extends jo { constructor(t = !1) { super(!0, t) } set(t, n) { return !0 } deleteProperty(t, n) { return !0 } }, Xc = new Wo, Jc = new Ko, Zc = new Wo(!0), Qc = new Ko(!0), ri = e => e, Ho = e => Reflect.getPrototypeOf(e); function eu(e, t, n) { return function (...o) { let s = this.__v_raw, i = ne(s), r = tn(i), a = e === "entries" || e === Symbol.iterator && r, l = e === "keys" && r, u = s[e](...o), c = n ? ri : t ? so : Ce; return !t && ke(i, "iterate", l ? ii : sn), { next() { let { value: d, done: p } = u.next(); return p ? { value: d, done: p } : { value: a ? [c(d[0]), c(d[1])] : c(d), done: p } }, [Symbol.iterator]() { return this } } } } function Fo(e) { return function (...t) { return e === "delete" ? !1 : e === "clear" ? void 0 : this } } function tu(e, t) { let n = { get(s) { let i = this.__v_raw, r = ne(i), a = ne(s); e || (Et(s, a) && ke(r, "get", s), ke(r, "get", a)); let { has: l } = Ho(r), u = t ? ri : e ? so : Ce; if (l.call(r, s)) return u(i.get(s)); if (l.call(r, a)) return u(i.get(a)); i !== r && i.get(s) }, get size() { let s = this.__v_raw; return !e && ke(ne(s), "iterate", sn), Reflect.get(s, "size", s) }, has(s) { let i = this.__v_raw, r = ne(i), a = ne(s); return e || (Et(s, a) && ke(r, "has", s), ke(r, "has", a)), s === a ? i.has(s) : i.has(s) || i.has(a) }, forEach(s, i) { let r = this, a = r.__v_raw, l = ne(a), u = t ? ri : e ? so : Ce; return !e && ke(l, "iterate", sn), a.forEach((c, d) => s.call(i, u(c), u(d), r)) } }; return ge(n, e ? { add: Fo("add"), set: Fo("set"), delete: Fo("delete"), clear: Fo("clear") } : { add(s) { !t && !Ge(s) && !wt(s) && (s = ne(s)); let i = ne(this); return Ho(i).has.call(i, s) || (i.add(s), bt(i, "add", s, s)), this }, set(s, i) { !t && !Ge(i) && !wt(i) && (i = ne(i)); let r = ne(this), { has: a, get: l } = Ho(r), u = a.call(r, s); u || (s = ne(s), u = a.call(r, s)); let c = l.call(r, s); return r.set(s, i), u ? Et(i, c) && bt(r, "set", s, i, c) : bt(r, "add", s, i), this }, delete(s) { let i = ne(this), { has: r, get: a } = Ho(i), l = r.call(i, s); l || (s = ne(s), l = r.call(i, s)); let u = a ? a.call(i, s) : void 0, c = i.delete(s); return l && bt(i, "delete", s, void 0, u), c }, clear() { let s = ne(this), i = s.size !== 0, r = void 0, a = s.clear(); return i && bt(s, "clear", void 0, void 0, r), a } }), ["keys", "values", "entries", Symbol.iterator].forEach(s => { n[s] = eu(s, e, t) }), n } function Yo(e, t) { let n = tu(e, t); return (o, s, i) => s === "__v_isReactive" ? !e : s === "__v_isReadonly" ? e : s === "__v_raw" ? o : Reflect.get(re(n, s) && s in o ? n : o, s, i) } var nu = { get: Yo(!1, !1) }, ou = { get: Yo(!1, !0) }, su = { get: Yo(!0, !1) }, iu = { get: Yo(!0, !0) }; var Br = new WeakMap, jr = new WeakMap, Wr = new WeakMap, Kr = new WeakMap; function ru(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function au(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : ru(Zs(e)) } function Le(e) { return wt(e) ? e : qo(e, !1, Xc, nu, Br) } function vi(e) { return qo(e, !1, Zc, ou, jr) } function gi(e) { return qo(e, !0, Jc, su, Wr) } function _i(e) { return qo(e, !0, Qc, iu, Kr) } function qo(e, t, n, o, s) { if (!de(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; let i = au(e); if (i === 0) return e; let r = s.get(e); if (r) return r; let a = new Proxy(e, i === 2 ? o : n); return s.set(e, a), a } function Ut(e) { return wt(e) ? Ut(e.__v_raw) : !!(e && e.__v_isReactive) } function wt(e) { return !!(e && e.__v_isReadonly) } function Ge(e) { return !!(e && e.__v_isShallow) } function ro(e) { return e ? !!e.__v_raw : !1 } function ne(e) { let t = e && e.__v_raw; return t ? ne(t) : e } function Ze(e) { return !re(e, "__v_skip") && Object.isExtensible(e) && bn(e, "__v_skip", !0), e } var Ce = e => de(e) ? Le(e) : e, so = e => de(e) ? gi(e) : e; function be(e) { return e ? e.__v_isRef === !0 : !1 } function U(e) { return Gr(e, !1) } function Xo(e) { return Gr(e, !0) } function Gr(e, t) { return be(e) ? e : new ai(e, t) } var ai = class { constructor(t, n) { this.dep = new On, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? t : ne(t), this._value = n ? t : Ce(t), this.__v_isShallow = n } get value() { return this.dep.track(), this._value } set value(t) { let n = this._rawValue, o = this.__v_isShallow || Ge(t) || wt(t); t = o ? t : ne(t), Et(t, n) && (this._rawValue = t, this._value = o ? t : Ce(t), this.dep.trigger()) } }; function Q(e) { return be(e) ? e.value : e } function Ct(e) { return q(e) ? e() : Q(e) } var lu = { get: (e, t, n) => t === "__v_raw" ? e : Q(Reflect.get(e, t, n)), set: (e, t, n, o) => { let s = e[t]; return be(s) && !be(n) ? (s.value = n, !0) : Reflect.set(e, t, n, o) } }; function Jo(e) { return Ut(e) ? e : new Proxy(e, lu) } var li = class { constructor(t) { this.__v_isRef = !0, this._value = void 0; let n = this.dep = new On, { get: o, set: s } = t(n.track.bind(n), n.trigger.bind(n)); this._get = o, this._set = s } get value() { return this._value = this._get() } set value(t) { this._set(t) } }; function Zo(e) { return new li(e) } function yi(e) { let t = W(e) ? new Array(e.length) : {}; for (let n in e) t[n] = zr(e, n); return t } var ci = class { constructor(t, n, o) { this._object = t, this._key = n, this._defaultValue = o, this.__v_isRef = !0, this._value = void 0 } get value() { let t = this._object[this._key]; return this._value = t === void 0 ? this._defaultValue : t } set value(t) { this._object[this._key] = t } get dep() { return Kc(ne(this._object), this._key) } }, ui = class { constructor(t) { this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0 } get value() { return this._value = this._getter() } }; function $t(e, t, n) { return be(e) ? e : q(e) ? new ui(e) : de(e) && arguments.length > 1 ? zr(e, t, n) : U(e) } function zr(e, t, n) { let o = e[t]; return be(o) ? o : new ci(e, t, n) } var di = class { constructor(t, n, o) { this.fn = t, this.setter = n, this._value = void 0, this.dep = new On(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = no - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = o } notify() { if (this.flags |= 16, !(this.flags & 8) && pe !== this) return Rr(this, !0), !0 } get value() { let t = this.dep.track(); return Lr(this), t && (t.version = this.dep.version), this._value } set value(t) { this.setter && this.setter(t) } }; function Yr(e, t, n = !1) { let o, s; return q(e) ? o = e : (o = e.get, s = e.set), new di(o, s, n) } var Uo = {}, Go = new WeakMap, on; function qr(e, t = !1, n = on) { if (n) { let o = Go.get(n); o || Go.set(n, o = []), o.push(e) } } function Xr(e, t, n = ce) { let { immediate: o, deep: s, once: i, scheduler: r, augmentJob: a, call: l } = n, u = C => { (n.onWarn || jc)("Invalid watch source: ", C, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.") }, c = C => s ? C : Ge(C) || s === !1 || s === 0 ? Nt(C, 1) : Nt(C), d, p, h, v, b = !1, y = !1; if (be(e) ? (p = () => e.value, b = Ge(e)) : Ut(e) ? (p = () => c(e), b = !0) : W(e) ? (y = !0, b = e.some(C => Ut(C) || Ge(C)), p = () => e.map(C => { if (be(C)) return C.value; if (Ut(C)) return c(C); if (q(C)) return l ? l(C, 2) : C() })) : q(e) ? t ? p = l ? () => l(e, 2) : e : p = () => { if (h) { Ot(); try { h() } finally { xt() } } let C = on; on = d; try { return l ? l(e, 3, [v]) : e(v) } finally { on = C } } : p = Ue, t && s) { let C = p, D = s === !0 ? 1 / 0 : s; p = () => Nt(C(), D) } let E = zo(), N = () => { d.stop(), E && E.active && qn(E.effects, d) }; if (i && t) { let C = t; t = (...D) => { C(...D), N() } } let k = y ? new Array(e.length).fill(Uo) : Uo, G = C => { if (!(!(d.flags & 1) || !d.dirty && !C)) if (t) { let D = d.run(); if (s || b || (y ? D.some((z, P) => Et(z, k[P])) : Et(D, k))) { h && h(); let z = on; on = d; try { let P = [D, k === Uo ? void 0 : y && k[0] === Uo ? [] : k, v]; k = D, l ? l(t, 3, P) : t(...P) } finally { on = z } } } else d.run() }; return a && a(G), d = new wn(p), d.scheduler = r ? () => r(G, !1) : G, v = C => qr(C, !1, d), h = d.onStop = () => { let C = Go.get(d); if (C) { if (l) l(C, 4); else for (let D of C) D(); Go.delete(d) } }, t ? o ? G(!0) : k = d.run() : r ? r(G.bind(null, !0), !0) : d.run(), N.pause = d.pause.bind(d), N.resume = d.resume.bind(d), N.stop = N, N } function Nt(e, t = 1 / 0, n) { if (t <= 0 || !de(e) || e.__v_skip || (n = n || new Set, n.has(e))) return e; if (n.add(e), t--, be(e)) Nt(e.value, t, n); else if (W(e)) for (let o = 0; o < e.length; o++)Nt(e[o], t, n); else if (Vo(e) || tn(e)) e.forEach(o => { Nt(o, t, n) }); else if (Ro(e)) { for (let o in e) Nt(e[o], t, n); for (let o of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, o) && Nt(e[o], t, n) } return e } function vo(e, t, n, o) { try { return o ? e(...o) : e() } catch (s) { rs(s, t, n) } } function lt(e, t, n, o) { if (q(e)) { let s = vo(e, t, n, o); return s && Js(s) && s.catch(i => { rs(i, t, n) }), s } if (W(e)) { let s = []; for (let i = 0; i < e.length; i++)s.push(lt(e[i], t, n, o)); return s } } function rs(e, t, n, o = !0) { let s = t ? t.vnode : null, { errorHandler: i, throwUnhandledErrorInProduction: r } = t && t.appContext.config || ce; if (t) { let a = t.parent, l = t.proxy, u = `https://vuejs.org/error-reference/#runtime-${n}`; for (; a;) { let c = a.ec; if (c) { for (let d = 0; d < c.length; d++)if (c[d](e, l, u) === !1) return } a = a.parent } if (i) { Ot(), vo(i, null, 10, [e, l, u]), xt(); return } } cu(e, n, s, o, r) } function cu(e, t, n, o = !0, s = !1) { if (s) throw e; console.error(e) } var je = [], St = -1, Cn = [], Bt = null, xn = 0, pa = Promise.resolve(), ts = null; function In(e) { let t = ts || pa; return e ? t.then(this ? e.bind(this) : e) : t } function uu(e) { let t = St + 1, n = je.length; for (; t < n;) { let o = t + n >>> 1, s = je[o], i = fo(s); i < e || i === e && s.flags & 2 ? t = o + 1 : n = o } return t } function ki(e) { if (!(e.flags & 1)) { let t = fo(e), n = je[je.length - 1]; !n || !(e.flags & 2) && t >= fo(n) ? je.push(e) : je.splice(uu(t), 0, e), e.flags |= 1, ha() } } function ha() { ts || (ts = pa.then(ga)) } function ma(e) { W(e) ? Cn.push(...e) : Bt && e.id === -1 ? Bt.splice(xn + 1, 0, e) : e.flags & 1 || (Cn.push(e), e.flags |= 1), ha() } function Jr(e, t, n = St + 1) { for (; n < je.length; n++) { let o = je[n]; if (o && o.flags & 2) { if (e && o.id !== e.uid) continue; je.splice(n, 1), n--, o.flags & 4 && (o.flags &= -2), o(), o.flags & 4 || (o.flags &= -2) } } } function va(e) { if (Cn.length) { let t = [...new Set(Cn)].sort((n, o) => fo(n) - fo(o)); if (Cn.length = 0, Bt) { Bt.push(...t); return } for (Bt = t, xn = 0; xn < Bt.length; xn++) { let n = Bt[xn]; n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2 } Bt = null, xn = 0 } } var fo = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id; function ga(e) { let t = Ue; try { for (St = 0; St < je.length; St++) { let n = je[St]; n && !(n.flags & 8) && (n.flags & 4 && (n.flags &= -2), vo(n, n.i, n.i ? 15 : 14), n.flags & 4 || (n.flags &= -2)) } } finally { for (; St < je.length; St++) { let n = je[St]; n && (n.flags &= -2) } St = -1, je.length = 0, va(e), ts = null, (je.length || Cn.length) && ga(e) } } var kt, ao = [], Oi = !1; function as(e, ...t) { kt ? kt.emit(e, ...t) : Oi || ao.push({ event: e, args: t }) } function _a(e, t) { var n, o; kt = e, kt ? (kt.enabled = !0, ao.forEach(({ event: s, args: i }) => kt.emit(s, ...i)), ao = []) : typeof window < "u" && window.HTMLElement && !((o = (n = window.navigator) == null ? void 0 : n.userAgent) != null && o.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(i => { _a(i, t) }), setTimeout(() => { kt || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Oi = !0, ao = []) }, 3e3)) : (Oi = !0, ao = []) } function du(e, t) { as("app:init", e, t, { Fragment: ae, Text: go, Comment: Ie, Static: Dn }) } function fu(e) { as("app:unmount", e) } var pu = Ii("component:added"), ya = Ii("component:updated"), hu = Ii("component:removed"), mu = e => { kt && typeof kt.cleanupBuffer == "function" && !kt.cleanupBuffer(e) && hu(e) }; function Ii(e) { return t => { as(e, t.appContext.app, t.uid, t.parent ? t.parent.uid : void 0, t) } } function vu(e, t, n) { as("component:emit", e.appContext.app, e, t, n) } var Te = null, Ea = null; function ns(e) { let t = Te; return Te = e, Ea = e && e.type.__scopeId || null, t } function Mn(e, t = Te, n) { if (!t || e._n) return e; let o = (...s) => { o._d && aa(-1); let i = ns(t), r; try { r = e(...s) } finally { ns(i), o._d && aa(1) } return __VUE_PROD_DEVTOOLS__ && ya(t), r }; return o._n = !0, o._c = !0, o._d = !0, o } function Pt(e, t) { if (Te === null) return e; let n = hs(Te), o = e.dirs || (e.dirs = []); for (let s = 0; s < t.length; s++) { let [i, r, a, l = ce] = t[s]; i && (q(i) && (i = { mounted: i, updated: i }), i.deep && Nt(r), o.push({ dir: i, instance: n, value: r, oldValue: void 0, arg: a, modifiers: l })) } return e } function rn(e, t, n, o) { let s = e.dirs, i = t && t.dirs; for (let r = 0; r < s.length; r++) { let a = s[r]; i && (a.oldValue = i[r].value); let l = a.dir[o]; l && (Ot(), lt(l, n, 8, [e.el, a, e, t]), xt()) } } var gu = Symbol("_vte"), ba = e => e.__isTeleport; var jt = Symbol("_leaveCb"), Qo = Symbol("_enterCb"); function Mi() { let e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map }; return zt(() => { e.isMounted = !0 }), An(() => { e.isUnmounting = !0 }), e } var at = [Function, Array], Vi = { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: at, onEnter: at, onAfterEnter: at, onEnterCancelled: at, onBeforeLeave: at, onLeave: at, onAfterLeave: at, onLeaveCancelled: at, onBeforeAppear: at, onAppear: at, onAfterAppear: at, onAppearCancelled: at }, Na = e => { let t = e.subTree; return t.component ? Na(t.component) : t }, _u = { name: "BaseTransition", props: Vi, setup(e, { slots: t }) { let n = Ui(), o = Mi(); return () => { let s = t.default && ls(t.default(), !0); if (!s || !s.length) return; let i = wa(s), r = ne(e), { mode: a } = r; if (o.isLeaving) return Ei(i); let l = Zr(i); if (!l) return Ei(i); let u = kn(l, r, o, n, d => u = d); l.type !== Ie && Kt(l, u); let c = n.subTree && Zr(n.subTree); if (c && c.type !== Ie && !ln(l, c) && Na(n).type !== Ie) { let d = kn(c, r, o, n); if (Kt(c, d), a === "out-in" && l.type !== Ie) return o.isLeaving = !0, d.afterLeave = () => { o.isLeaving = !1, n.job.flags & 8 || n.update(), delete d.afterLeave, c = void 0 }, Ei(i); a === "in-out" && l.type !== Ie ? d.delayLeave = (p, h, v) => { let b = xa(o, c); b[String(c.key)] = c, p[jt] = () => { h(), p[jt] = void 0, delete u.delayedLeave, c = void 0 }, u.delayedLeave = () => { v(), delete u.delayedLeave, c = void 0 } } : c = void 0 } else c && (c = void 0); return i } } }; function wa(e) { let t = e[0]; if (e.length > 1) { let n = !1; for (let o of e) if (o.type !== Ie) { t = o, n = !0; break } } return t } var Oa = _u; function xa(e, t) { let { leavingVNodes: n } = e, o = n.get(t.type); return o || (o = Object.create(null), n.set(t.type, o)), o } function kn(e, t, n, o, s) { let { appear: i, mode: r, persisted: a = !1, onBeforeEnter: l, onEnter: u, onAfterEnter: c, onEnterCancelled: d, onBeforeLeave: p, onLeave: h, onAfterLeave: v, onLeaveCancelled: b, onBeforeAppear: y, onAppear: E, onAfterAppear: N, onAppearCancelled: k } = t, G = String(e.key), C = xa(n, e), D = (_, M) => { _ && lt(_, o, 9, M) }, z = (_, M) => { let Y = M[1]; D(_, M), W(_) ? _.every(L => L.length <= 1) && Y() : _.length <= 1 && Y() }, P = { mode: r, persisted: a, beforeEnter(_) { let M = l; if (!n.isMounted) if (i) M = y || l; else return; _[jt] && _[jt](!0); let Y = C[G]; Y && ln(e, Y) && Y.el[jt] && Y.el[jt](), D(M, [_]) }, enter(_) { let M = u, Y = c, L = d; if (!n.isMounted) if (i) M = E || u, Y = N || c, L = k || d; else return; let le = !1, A = _[Qo] = Z => { le || (le = !0, Z ? D(L, [_]) : D(Y, [_]), P.delayedLeave && P.delayedLeave(), _[Qo] = void 0) }; M ? z(M, [_, A]) : A() }, leave(_, M) { let Y = String(e.key); if (_[Qo] && _[Qo](!0), n.isUnmounting) return M(); D(p, [_]); let L = !1, le = _[jt] = A => { L || (L = !0, M(), A ? D(b, [_]) : D(v, [_]), _[jt] = void 0, C[Y] === e && delete C[Y]) }; C[Y] = e, h ? z(h, [_, le]) : le() }, clone(_) { let M = kn(_, t, n, o, s); return s && s(M), M } }; return P } function Ei(e) { if (cs(e)) return e = Gt(e), e.children = null, e } function Zr(e) { if (!cs(e)) return ba(e.type) && e.children ? wa(e.children) : e; if (e.component) return e.component.subTree; let { shapeFlag: t, children: n } = e; if (n) { if (t & 16) return n[0]; if (t & 32 && q(n.default)) return n.default() } } function Kt(e, t) { e.shapeFlag & 6 && e.component ? (e.transition = t, Kt(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t } function ls(e, t = !1, n) { let o = [], s = 0; for (let i = 0; i < e.length; i++) { let r = e[i], a = n == null ? r.key : String(n) + String(r.key != null ? r.key : i); r.type === ae ? (r.patchFlag & 128 && s++, o = o.concat(ls(r.children, t, a))) : (t || r.type !== Ie) && o.push(a != null ? Gt(r, { key: a }) : r) } if (s > 1) for (let i = 0; i < o.length; i++)o[i].patchFlag = -2; return o } function me(e, t) { return q(e) ? ge({ name: e.name }, t, { setup: e }) : e } function Ca(e) { e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0] } function os(e, t, n, o, s = !1) { if (W(e)) { e.forEach((v, b) => os(v, t && (W(t) ? t[b] : t), n, o, s)); return } if (Tn(o) && !s) { o.shapeFlag & 512 && o.type.__asyncResolved && o.component.subTree.component && os(e, t, n, o.component.subTree); return } let i = o.shapeFlag & 4 ? hs(o.component) : o.el, r = s ? null : i, { i: a, r: l } = e, u = t && t.r, c = a.refs === ce ? a.refs = {} : a.refs, d = a.setupState, p = ne(d), h = d === ce ? () => !1 : v => re(p, v); if (u != null && u !== l && (ve(u) ? (c[u] = null, h(u) && (d[u] = null)) : be(u) && (u.value = null)), q(l)) vo(l, a, 12, [r, c]); else { let v = ve(l), b = be(l); if (v || b) { let y = () => { if (e.f) { let E = v ? h(l) ? d[l] : c[l] : l.value; s ? W(E) && qn(E, i) : W(E) ? E.includes(i) || E.push(i) : v ? (c[l] = [i], h(l) && (d[l] = c[l])) : (l.value = [i], e.k && (c[e.k] = l.value)) } else v ? (c[l] = r, h(l) && (d[l] = r)) : b && (l.value = r, e.k && (c[e.k] = r)) }; r ? (y.id = -1, Qe(y, n)) : y() } } } var cg = Ft().requestIdleCallback || (e => setTimeout(e, 1)), ug = Ft().cancelIdleCallback || (e => clearTimeout(e)); var Tn = e => !!e.type.__asyncLoader; var cs = e => e.type.__isKeepAlive; function yu(e, t) { Ta(e, "a", t) } function Eu(e, t) { Ta(e, "da", t) } function Ta(e, t, n = Me) { let o = e.__wdc || (e.__wdc = () => { let s = n; for (; s;) { if (s.isDeactivated) return; s = s.parent } return e() }); if (us(t, o, n), n) { let s = n.parent; for (; s && s.parent;)cs(s.parent.vnode) && bu(o, t, n, s), s = s.parent } } function bu(e, t, n, o) { let s = us(t, e, o, !0); Ai(() => { qn(o[t], s) }, n) } function us(e, t, n = Me, o = !1) { if (n) { let s = n[e] || (n[e] = []), i = t.__weh || (t.__weh = (...r) => { Ot(); let a = yo(n), l = lt(t, n, e, r); return a(), xt(), l }); return o ? s.unshift(i) : s.push(i), i } } var Lt = e => (t, n = Me) => { (!mo || e === "sp") && us(e, (...o) => t(...o), n) }, Nu = Lt("bm"), zt = Lt("m"), Sa = Lt("bu"), Vn = Lt("u"), An = Lt("bum"), Ai = Lt("um"), wu = Lt("sp"), Ou = Lt("rtg"), xu = Lt("rtc"); function Cu(e, t = Me) { us("ec", e, t) } var Ri = "components"; function Yt(e, t) { return ka(Ri, e, !0, t) || e } var Da = Symbol.for("v-ndc"); function ds(e) { return ve(e) ? ka(Ri, e, !1) || e : e || Da } function ka(e, t, n = !0, o = !1) { let s = Te || Me; if (s) { let i = s.type; if (e === Ri) { let a = fd(i, !1); if (a && (a === t || a === $e(t) || a === nn($e(t)))) return i } let r = Qr(s[e] || i[e], t) || Qr(s.appContext[e], t); return !r && o ? i : r } } function Qr(e, t) { return e && (e[t] || e[$e(t)] || e[nn($e(t))]) } function ct(e, t, n, o) { let s, i = n && n[o], r = W(e); if (r || ve(e)) { let a = r && Ut(e), l = !1, u = !1; a && (l = !Ge(e), u = wt(e), e = io(e)), s = new Array(e.length); for (let c = 0, d = e.length; c < d; c++)s[c] = t(l ? u ? so(Ce(e[c])) : Ce(e[c]) : e[c], c, void 0, i && i[c]) } else if (typeof e == "number") { s = new Array(e); for (let a = 0; a < e; a++)s[a] = t(a + 1, a, void 0, i && i[a]) } else if (de(e)) if (e[Symbol.iterator]) s = Array.from(e, (a, l) => t(a, l, void 0, i && i[l])); else { let a = Object.keys(e); s = new Array(a.length); for (let l = 0, u = a.length; l < u; l++) { let c = a[l]; s[l] = t(e[c], c, l, i && i[l]) } } else s = []; return n && (n[o] = s), s } function We(e, t, n = {}, o, s) { if (Te.ce || Te.parent && Tn(Te.parent) && Te.parent.ce) return t !== "default" && (n.name = t), S(), Oe(ae, null, [oe("slot", n, o && o())], 64); let i = e[t]; i && i._c && (i._d = !1), S(); let r = i && Ia(i(n)), a = n.key || r && r.key, l = Oe(ae, { key: (a && !rt(a) ? a : `_${t}`) + (!r && o ? "_fb" : "") }, r || (o ? o() : []), r && e._ === 1 ? 64 : -2); return !s && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]), i && i._c && (i._d = !0), l } function Ia(e) { return e.some(t => ho(t) ? !(t.type === Ie || t.type === ae && !Ia(t.children)) : !0) ? e : null } var xi = e => e ? Ja(e) ? hs(e) : xi(e.parent) : null, co = ge(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => xi(e.parent), $root: e => xi(e.root), $host: e => e.ce, $emit: e => e.emit, $options: e => __VUE_OPTIONS_API__ ? $i(e) : e.type, $forceUpdate: e => e.f || (e.f = () => { ki(e.update) }), $nextTick: e => e.n || (e.n = In.bind(e.proxy)), $watch: e => __VUE_OPTIONS_API__ ? zu.bind(e) : Ue }); var bi = (e, t) => e !== ce && !e.__isScriptSetup && re(e, t), Tu = { get({ _: e }, t) { if (t === "__v_skip") return !0; let { ctx: n, setupState: o, data: s, props: i, accessCache: r, type: a, appContext: l } = e, u; if (t[0] !== "$") { let h = r[t]; if (h !== void 0) switch (h) { case 1: return o[t]; case 2: return s[t]; case 4: return n[t]; case 3: return i[t] } else { if (bi(o, t)) return r[t] = 1, o[t]; if (s !== ce && re(s, t)) return r[t] = 2, s[t]; if ((u = e.propsOptions[0]) && re(u, t)) return r[t] = 3, i[t]; if (n !== ce && re(n, t)) return r[t] = 4, n[t]; (!__VUE_OPTIONS_API__ || Ci) && (r[t] = 0) } } let c = co[t], d, p; if (c) return t === "$attrs" && ke(e.attrs, "get", ""), c(e); if ((d = a.__cssModules) && (d = d[t])) return d; if (n !== ce && re(n, t)) return r[t] = 4, n[t]; if (p = l.config.globalProperties, re(p, t)) return p[t] }, set({ _: e }, t, n) { let { data: o, setupState: s, ctx: i } = e; return bi(s, t) ? (s[t] = n, !0) : o !== ce && re(o, t) ? (o[t] = n, !0) : re(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (i[t] = n, !0) }, has({ _: { data: e, setupState: t, accessCache: n, ctx: o, appContext: s, propsOptions: i } }, r) { let a; return !!n[r] || e !== ce && re(e, r) || bi(t, r) || (a = i[0]) && re(a, r) || re(o, r) || re(co, r) || re(s.config.globalProperties, r) }, defineProperty(e, t, n) { return n.get != null ? e._.accessCache[t] = 0 : re(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n) } }; function ea(e) { return W(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e } var Ci = !0; function Su(e) { let t = $i(e), n = e.proxy, o = e.ctx; Ci = !1, t.beforeCreate && ta(t.beforeCreate, e, "bc"); let { data: s, computed: i, methods: r, watch: a, provide: l, inject: u, created: c, beforeMount: d, mounted: p, beforeUpdate: h, updated: v, activated: b, deactivated: y, beforeDestroy: E, beforeUnmount: N, destroyed: k, unmounted: G, render: C, renderTracked: D, renderTriggered: z, errorCaptured: P, serverPrefetch: _, expose: M, inheritAttrs: Y, components: L, directives: le, filters: A } = t; if (u && Du(u, o, null), r) for (let se in r) { let ee = r[se]; q(ee) && (o[se] = ee.bind(n)) } if (s) { let se = s.call(n, n); de(se) && (e.data = Le(se)) } if (Ci = !0, i) for (let se in i) { let ee = i[se], xe = q(ee) ? ee.bind(n, n) : q(ee.get) ? ee.get.bind(n, n) : Ue, pn = !q(ee) && q(ee.set) ? ee.set.bind(n) : Ue, pt = j({ get: xe, set: pn }); Object.defineProperty(o, se, { enumerable: !0, configurable: !0, get: () => pt.value, set: ht => pt.value = ht }) } if (a) for (let se in a) Ma(a[se], o, n, se); if (l) { let se = q(l) ? l.call(n) : l; Reflect.ownKeys(se).forEach(ee => { fs(ee, se[ee]) }) } c && ta(c, e, "c"); function J(se, ee) { W(ee) ? ee.forEach(xe => se(xe.bind(n))) : ee && se(ee.bind(n)) } if (J(Nu, d), J(zt, p), J(Sa, h), J(Vn, v), J(yu, b), J(Eu, y), J(Cu, P), J(xu, D), J(Ou, z), J(An, N), J(Ai, G), J(wu, _), W(M)) if (M.length) { let se = e.exposed || (e.exposed = {}); M.forEach(ee => { Object.defineProperty(se, ee, { get: () => n[ee], set: xe => n[ee] = xe }) }) } else e.exposed || (e.exposed = {}); C && e.render === Ue && (e.render = C), Y != null && (e.inheritAttrs = Y), L && (e.components = L), le && (e.directives = le), _ && Ca(e) } function Du(e, t, n = Ue) { W(e) && (e = Ti(e)); for (let o in e) { let s = e[o], i; de(s) ? "default" in s ? i = cn(s.from || o, s.default, !0) : i = cn(s.from || o) : i = cn(s), be(i) ? Object.defineProperty(t, o, { enumerable: !0, configurable: !0, get: () => i.value, set: r => i.value = r }) : t[o] = i } } function ta(e, t, n) { lt(W(e) ? e.map(o => o.bind(t.proxy)) : e.bind(t.proxy), t, n) } function Ma(e, t, n, o) { let s = o.includes(".") ? Ga(n, o) : () => n[o]; if (ve(e)) { let i = t[e]; q(i) && ze(s, i) } else if (q(e)) ze(s, e.bind(n)); else if (de(e)) if (W(e)) e.forEach(i => Ma(i, t, n, o)); else { let i = q(e.handler) ? e.handler.bind(n) : t[e.handler]; q(i) && ze(s, i, e) } } function $i(e) { let t = e.type, { mixins: n, extends: o } = t, { mixins: s, optionsCache: i, config: { optionMergeStrategies: r } } = e.appContext, a = i.get(t), l; return a ? l = a : !s.length && !n && !o ? l = t : (l = {}, s.length && s.forEach(u => ss(l, u, r, !0)), ss(l, t, r)), de(t) && i.set(t, l), l } function ss(e, t, n, o = !1) { let { mixins: s, extends: i } = t; i && ss(e, i, n, !0), s && s.forEach(r => ss(e, r, n, !0)); for (let r in t) if (!(o && r === "expose")) { let a = ku[r] || n && n[r]; e[r] = a ? a(e[r], t[r]) : t[r] } return e } var ku = { data: na, props: oa, emits: oa, methods: lo, computed: lo, beforeCreate: Be, created: Be, beforeMount: Be, mounted: Be, beforeUpdate: Be, updated: Be, beforeDestroy: Be, beforeUnmount: Be, destroyed: Be, unmounted: Be, activated: Be, deactivated: Be, errorCaptured: Be, serverPrefetch: Be, components: lo, directives: lo, watch: Mu, provide: na, inject: Iu }; function na(e, t) { return t ? e ? function () { return ge(q(e) ? e.call(this, this) : e, q(t) ? t.call(this, this) : t) } : t : e } function Iu(e, t) { return lo(Ti(e), Ti(t)) } function Ti(e) { if (W(e)) { let t = {}; for (let n = 0; n < e.length; n++)t[e[n]] = e[n]; return t } return e } function Be(e, t) { return e ? [...new Set([].concat(e, t))] : t } function lo(e, t) { return e ? ge(Object.create(null), e, t) : t } function oa(e, t) { return e ? W(e) && W(t) ? [...new Set([...e, ...t])] : ge(Object.create(null), ea(e), ea(t ?? {})) : t } function Mu(e, t) { if (!e) return t; if (!t) return e; let n = ge(Object.create(null), e); for (let o in t) n[o] = Be(e[o], t[o]); return n } function Va() { return { app: null, config: { isNativeTag: Cr, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } var Vu = 0; function Au(e, t) { return function (o, s = null) { q(o) || (o = ge({}, o)), s != null && !de(s) && (s = null); let i = Va(), r = new WeakSet, a = [], l = !1, u = i.app = { _uid: Vu++, _component: o, _props: s, _container: null, _context: i, _instance: null, version: fa, get config() { return i.config }, set config(c) { }, use(c, ...d) { return r.has(c) || (c && q(c.install) ? (r.add(c), c.install(u, ...d)) : q(c) && (r.add(c), c(u, ...d))), u }, mixin(c) { return __VUE_OPTIONS_API__ && (i.mixins.includes(c) || i.mixins.push(c)), u }, component(c, d) { return d ? (i.components[c] = d, u) : i.components[c] }, directive(c, d) { return d ? (i.directives[c] = d, u) : i.directives[c] }, mount(c, d, p) { if (!l) { let h = u._ceVNode || oe(o, s); return h.appContext = i, p === !0 ? p = "svg" : p === !1 && (p = void 0), d && t ? t(h, c) : e(h, c, p), l = !0, u._container = c, c.__vue_app__ = u, __VUE_PROD_DEVTOOLS__ && (u._instance = h.component, du(u, fa)), hs(h.component) } }, onUnmount(c) { a.push(c) }, unmount() { l && (lt(a, u._instance, 16), e(null, u._container), __VUE_PROD_DEVTOOLS__ && (u._instance = null, fu(u)), delete u._container.__vue_app__) }, provide(c, d) { return i.provides[c] = d, u }, runWithContext(c) { let d = Sn; Sn = u; try { return c() } finally { Sn = d } } }; return u } } var Sn = null; function fs(e, t) { if (Me) { let n = Me.provides, o = Me.parent && Me.parent.provides; o === n && (n = Me.provides = Object.create(o)), n[e] = t } } function cn(e, t, n = !1) { let o = Me || Te; if (o || Sn) { let s = Sn ? Sn._context.provides : o ? o.parent == null || o.ce ? o.vnode.appContext && o.vnode.appContext.provides : o.parent.provides : void 0; if (s && e in s) return s[e]; if (arguments.length > 1) return n && q(t) ? t.call(o && o.proxy) : t } } var Aa = {}, Ra = () => Object.create(Aa), $a = e => Object.getPrototypeOf(e) === Aa; function Ru(e, t, n, o = !1) { let s = {}, i = Ra(); e.propsDefaults = Object.create(null), Pa(e, t, s, i); for (let r in e.propsOptions[0]) r in s || (s[r] = void 0); n ? e.props = o ? s : vi(s) : e.type.props ? e.props = s : e.props = i, e.attrs = i } function $u(e, t, n, o) { let { props: s, attrs: i, vnode: { patchFlag: r } } = e, a = ne(s), [l] = e.propsOptions, u = !1; if ((o || r > 0) && !(r & 16)) { if (r & 8) { let c = e.vnode.dynamicProps; for (let d = 0; d < c.length; d++) { let p = c[d]; if (ps(e.emitsOptions, p)) continue; let h = t[p]; if (l) if (re(i, p)) h !== i[p] && (i[p] = h, u = !0); else { let v = $e(p); s[v] = Si(l, a, v, h, e, !1) } else h !== i[p] && (i[p] = h, u = !0) } } } else { Pa(e, t, s, i) && (u = !0); let c; for (let d in a) (!t || !re(t, d) && ((c = yt(d)) === d || !re(t, c))) && (l ? n && (n[d] !== void 0 || n[c] !== void 0) && (s[d] = Si(l, a, d, void 0, e, !0)) : delete s[d]); if (i !== a) for (let d in i) (!t || !re(t, d)) && (delete i[d], u = !0) } u && bt(e.attrs, "set", "") } function Pa(e, t, n, o) { let [s, i] = e.propsOptions, r = !1, a; if (t) for (let l in t) { if (yn(l)) continue; let u = t[l], c; s && re(s, c = $e(l)) ? !i || !i.includes(c) ? n[c] = u : (a || (a = {}))[c] = u : ps(e.emitsOptions, l) || (!(l in o) || u !== o[l]) && (o[l] = u, r = !0) } if (i) { let l = ne(n), u = a || ce; for (let c = 0; c < i.length; c++) { let d = i[c]; n[d] = Si(s, l, d, u[d], e, !re(u, d)) } } return r } function Si(e, t, n, o, s, i) { let r = e[n]; if (r != null) { let a = re(r, "default"); if (a && o === void 0) { let l = r.default; if (r.type !== Function && !r.skipFactory && q(l)) { let { propsDefaults: u } = s; if (n in u) o = u[n]; else { let c = yo(s); o = u[n] = l.call(null, t), c() } } else o = l; s.ce && s.ce._setProp(n, o) } r[0] && (i && !a ? o = !1 : r[1] && (o === "" || o === yt(n)) && (o = !0)) } return o } var Pu = new WeakMap; function La(e, t, n = !1) { let o = __VUE_OPTIONS_API__ && n ? Pu : t.propsCache, s = o.get(e); if (s) return s; let i = e.props, r = {}, a = [], l = !1; if (__VUE_OPTIONS_API__ && !q(e)) { let c = d => { l = !0; let [p, h] = La(d, t, !0); ge(r, p), h && a.push(...h) }; !n && t.mixins.length && t.mixins.forEach(c), e.extends && c(e.extends), e.mixins && e.mixins.forEach(c) } if (!i && !l) return de(e) && o.set(e, en), en; if (W(i)) for (let c = 0; c < i.length; c++) { let d = $e(i[c]); sa(d) && (r[d] = ce) } else if (i) for (let c in i) { let d = $e(c); if (sa(d)) { let p = i[c], h = r[d] = W(p) || q(p) ? { type: p } : ge({}, p), v = h.type, b = !1, y = !0; if (W(v)) for (let E = 0; E < v.length; ++E) { let N = v[E], k = q(N) && N.name; if (k === "Boolean") { b = !0; break } else k === "String" && (y = !1) } else b = q(v) && v.name === "Boolean"; h[0] = b, h[1] = y, (b || re(h, "default")) && a.push(d) } } let u = [r, a]; return de(e) && o.set(e, u), u } function sa(e) { return e[0] !== "$" && !yn(e) } var Pi = e => e[0] === "_" || e === "$stable", Li = e => W(e) ? e.map(Dt) : [Dt(e)], Lu = (e, t, n) => { if (t._n) return t; let o = Mn((...s) => Li(t(...s)), n); return o._c = !1, o }, Ha = (e, t, n) => { let o = e._ctx; for (let s in e) { if (Pi(s)) continue; let i = e[s]; if (q(i)) t[s] = Lu(s, i, o); else if (i != null) { let r = Li(i); t[s] = () => r } } }, Fa = (e, t) => { let n = Li(t); e.slots.default = () => n }, Ua = (e, t, n) => { for (let o in t) (n || !Pi(o)) && (e[o] = t[o]) }, Hu = (e, t, n) => { let o = e.slots = Ra(); if (e.vnode.shapeFlag & 32) { let s = t._; s ? (Ua(o, t, n), n && bn(o, "_", s, !0)) : Ha(t, o) } else t && Fa(e, t) }, Fu = (e, t, n) => { let { vnode: o, slots: s } = e, i = !0, r = ce; if (o.shapeFlag & 32) { let a = t._; a ? n && a === 1 ? i = !1 : Ua(s, t, n) : (i = !t.$stable, Ha(t, s)), r = t } else t && (Fa(e, t), r = { default: 1 }); if (i) for (let a in s) !Pi(a) && r[a] == null && delete s[a] }; function Uu() { let e = []; typeof __VUE_OPTIONS_API__ != "boolean" && (Ft().__VUE_OPTIONS_API__ = !0), typeof __VUE_PROD_DEVTOOLS__ != "boolean" && (Ft().__VUE_PROD_DEVTOOLS__ = !1), typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ != "boolean" && (Ft().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = !1) } var Qe = ed; function Ba(e) { return Bu(e) } function Bu(e, t) { Uu(); let n = Ft(); n.__VUE__ = !0, __VUE_PROD_DEVTOOLS__ && _a(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n); let { insert: o, remove: s, patchProp: i, createElement: r, createText: a, createComment: l, setText: u, setElementText: c, parentNode: d, nextSibling: p, setScopeId: h = Ue, insertStaticContent: v } = e, b = (f, m, g, O = null, w = null, x = null, R = void 0, V = null, I = !!m.dynamicChildren) => { if (f === m) return; f && !ln(f, m) && (O = So(f), ut(f, w, x, !0), f = null), m.patchFlag === -2 && (I = !1, m.dynamicChildren = null); let { type: T, ref: K, shapeFlag: $ } = m; switch (T) { case go: y(f, m, g, O); break; case Ie: E(f, m, g, O); break; case Dn: f == null && N(m, g, O, R); break; case ae: le(f, m, g, O, w, x, R, V, I); break; default: $ & 1 ? D(f, m, g, O, w, x, R, V, I) : $ & 6 ? A(f, m, g, O, w, x, R, V, I) : ($ & 64 || $ & 128) && T.process(f, m, g, O, w, x, R, V, I, hn) }K != null && w && os(K, f && f.ref, x, m || f, !m) }, y = (f, m, g, O) => { if (f == null) o(m.el = a(m.children), g, O); else { let w = m.el = f.el; m.children !== f.children && u(w, m.children) } }, E = (f, m, g, O) => { f == null ? o(m.el = l(m.children || ""), g, O) : m.el = f.el }, N = (f, m, g, O) => { [f.el, f.anchor] = v(f.children, m, g, O, f.el, f.anchor) }, k = (f, m, g, O) => { if (m.children !== f.children) { let w = p(f.anchor); C(f), [m.el, m.anchor] = v(m.children, g, w, O) } else m.el = f.el, m.anchor = f.anchor }, G = ({ el: f, anchor: m }, g, O) => { let w; for (; f && f !== m;)w = p(f), o(f, g, O), f = w; o(m, g, O) }, C = ({ el: f, anchor: m }) => { let g; for (; f && f !== m;)g = p(f), s(f), f = g; s(m) }, D = (f, m, g, O, w, x, R, V, I) => { m.type === "svg" ? R = "svg" : m.type === "math" && (R = "mathml"), f == null ? z(m, g, O, w, x, R, V, I) : M(f, m, w, x, R, V, I) }, z = (f, m, g, O, w, x, R, V) => { let I, T, { props: K, shapeFlag: $, transition: B, dirs: X } = f; if (I = f.el = r(f.type, x, K && K.is, K), $ & 8 ? c(I, f.children) : $ & 16 && _(f.children, I, null, O, w, Ni(f, x), R, V), X && rn(f, null, O, "created"), P(I, f, f.scopeId, R, O), K) { for (let fe in K) fe !== "value" && !yn(fe) && i(I, fe, null, K[fe], x, O); "value" in K && i(I, "value", null, K.value, x), (T = K.onVnodeBeforeMount) && Tt(T, O, f) } __VUE_PROD_DEVTOOLS__ && (bn(I, "__vnode", f, !0), bn(I, "__vueParentComponent", O, !0)), X && rn(f, null, O, "beforeMount"); let ie = ju(w, B); ie && B.beforeEnter(I), o(I, m, g), ((T = K && K.onVnodeMounted) || ie || X) && Qe(() => { T && Tt(T, O, f), ie && B.enter(I), X && rn(f, null, O, "mounted") }, w) }, P = (f, m, g, O, w) => { if (g && h(f, g), O) for (let x = 0; x < O.length; x++)h(f, O[x]); if (w) { let x = w.subTree; if (m === x || Ya(x.type) && (x.ssContent === m || x.ssFallback === m)) { let R = w.vnode; P(f, R, R.scopeId, R.slotScopeIds, w.parent) } } }, _ = (f, m, g, O, w, x, R, V, I = 0) => { for (let T = I; T < f.length; T++) { let K = f[T] = V ? Wt(f[T]) : Dt(f[T]); b(null, K, m, g, O, w, x, R, V) } }, M = (f, m, g, O, w, x, R) => { let V = m.el = f.el; __VUE_PROD_DEVTOOLS__ && (V.__vnode = m); let { patchFlag: I, dynamicChildren: T, dirs: K } = m; I |= f.patchFlag & 16; let $ = f.props || ce, B = m.props || ce, X; if (g && an(g, !1), (X = B.onVnodeBeforeUpdate) && Tt(X, g, m, f), K && rn(m, f, g, "beforeUpdate"), g && an(g, !0), ($.innerHTML && B.innerHTML == null || $.textContent && B.textContent == null) && c(V, ""), T ? Y(f.dynamicChildren, T, V, g, O, Ni(m, w), x) : R || xe(f, m, V, null, g, O, Ni(m, w), x, !1), I > 0) { if (I & 16) L(V, $, B, g, w); else if (I & 2 && $.class !== B.class && i(V, "class", null, B.class, w), I & 4 && i(V, "style", $.style, B.style, w), I & 8) { let ie = m.dynamicProps; for (let fe = 0; fe < ie.length; fe++) { let ue = ie[fe], qe = $[ue], Ae = B[ue]; (Ae !== qe || ue === "value") && i(V, ue, qe, Ae, w, g) } } I & 1 && f.children !== m.children && c(V, m.children) } else !R && T == null && L(V, $, B, g, w); ((X = B.onVnodeUpdated) || K) && Qe(() => { X && Tt(X, g, m, f), K && rn(m, f, g, "updated") }, O) }, Y = (f, m, g, O, w, x, R) => { for (let V = 0; V < m.length; V++) { let I = f[V], T = m[V], K = I.el && (I.type === ae || !ln(I, T) || I.shapeFlag & 198) ? d(I.el) : g; b(I, T, K, null, O, w, x, R, !0) } }, L = (f, m, g, O, w) => { if (m !== g) { if (m !== ce) for (let x in m) !yn(x) && !(x in g) && i(f, x, m[x], null, w, O); for (let x in g) { if (yn(x)) continue; let R = g[x], V = m[x]; R !== V && x !== "value" && i(f, x, V, R, w, O) } "value" in g && i(f, "value", m.value, g.value, w) } }, le = (f, m, g, O, w, x, R, V, I) => { let T = m.el = f ? f.el : a(""), K = m.anchor = f ? f.anchor : a(""), { patchFlag: $, dynamicChildren: B, slotScopeIds: X } = m; X && (V = V ? V.concat(X) : X), f == null ? (o(T, g, O), o(K, g, O), _(m.children || [], g, K, w, x, R, V, I)) : $ > 0 && $ & 64 && B && f.dynamicChildren ? (Y(f.dynamicChildren, B, g, w, x, R, V), (m.key != null || w && m === w.subTree) && ja(f, m, !0)) : xe(f, m, g, K, w, x, R, V, I) }, A = (f, m, g, O, w, x, R, V, I) => { m.slotScopeIds = V, f == null ? m.shapeFlag & 512 ? w.ctx.activate(m, g, O, R, I) : Z(m, g, O, w, x, R, I) : J(f, m, I) }, Z = (f, m, g, O, w, x, R) => { let V = f.component = ad(f, O, w); if (cs(f) && (V.ctx.renderer = hn), ld(V, !1, R), V.asyncDep) { if (w && w.registerDep(V, se, R), !f.el) { let I = V.subTree = oe(Ie); E(null, I, m, g) } } else se(V, f, m, g, w, x, R) }, J = (f, m, g) => { let O = m.component = f.component; if (Zu(f, m, g)) if (O.asyncDep && !O.asyncResolved) { ee(O, m, g); return } else O.next = m, O.update(); else m.el = f.el, O.vnode = m }, se = (f, m, g, O, w, x, R) => { let V = () => { if (f.isMounted) { let { next: $, bu: B, u: X, parent: ie, vnode: fe } = f; { let Xe = Wa(f); if (Xe) { $ && ($.el = fe.el, ee(f, $, R)), Xe.asyncDep.then(() => { f.isUnmounted || V() }); return } } let ue = $, qe; an(f, !1), $ ? ($.el = fe.el, ee(f, $, R)) : $ = fe, B && En(B), (qe = $.props && $.props.onVnodeBeforeUpdate) && Tt(qe, ie, $, fe), an(f, !0); let Ae = wi(f), dt = f.subTree; f.subTree = Ae, b(dt, Ae, d(dt.el), So(dt), f, w, x), $.el = Ae.el, ue === null && Qu(f, Ae.el), X && Qe(X, w), (qe = $.props && $.props.onVnodeUpdated) && Qe(() => Tt(qe, ie, $, fe), w), __VUE_PROD_DEVTOOLS__ && ya(f) } else { let $, { el: B, props: X } = m, { bm: ie, m: fe, parent: ue, root: qe, type: Ae } = f, dt = Tn(m); if (an(f, !1), ie && En(ie), !dt && ($ = X && X.onVnodeBeforeMount) && Tt($, ue, m), an(f, !0), B && Ps) { let Xe = () => { f.subTree = wi(f), Ps(B, f.subTree, f, w, null) }; dt && Ae.__asyncHydrate ? Ae.__asyncHydrate(B, f, Xe) : Xe() } else { qe.ce && qe.ce._injectChildStyle(Ae); let Xe = f.subTree = wi(f); b(null, Xe, g, O, f, w, x), m.el = Xe.el } if (fe && Qe(fe, w), !dt && ($ = X && X.onVnodeMounted)) { let Xe = m; Qe(() => Tt($, ue, Xe), w) } (m.shapeFlag & 256 || ue && Tn(ue.vnode) && ue.vnode.shapeFlag & 256) && f.a && Qe(f.a, w), f.isMounted = !0, __VUE_PROD_DEVTOOLS__ && pu(f), m = g = O = null } }; f.scope.on(); let I = f.effect = new wn(V); f.scope.off(); let T = f.update = I.run.bind(I), K = f.job = I.runIfDirty.bind(I); K.i = f, K.id = f.uid, I.scheduler = () => ki(K), an(f, !0), T() }, ee = (f, m, g) => { m.component = f; let O = f.vnode.props; f.vnode = m, f.next = null, $u(f, m.props, O, g), Fu(f, m.children, g), Ot(), Jr(f), xt() }, xe = (f, m, g, O, w, x, R, V, I = !1) => { let T = f && f.children, K = f ? f.shapeFlag : 0, $ = m.children, { patchFlag: B, shapeFlag: X } = m; if (B > 0) { if (B & 128) { pt(T, $, g, O, w, x, R, V, I); return } else if (B & 256) { pn(T, $, g, O, w, x, R, V, I); return } } X & 8 ? (K & 16 && Fn(T, w, x), $ !== T && c(g, $)) : K & 16 ? X & 16 ? pt(T, $, g, O, w, x, R, V, I) : Fn(T, w, x, !0) : (K & 8 && c(g, ""), X & 16 && _($, g, O, w, x, R, V, I)) }, pn = (f, m, g, O, w, x, R, V, I) => { f = f || en, m = m || en; let T = f.length, K = m.length, $ = Math.min(T, K), B; for (B = 0; B < $; B++) { let X = m[B] = I ? Wt(m[B]) : Dt(m[B]); b(f[B], X, g, null, w, x, R, V, I) } T > K ? Fn(f, w, x, !0, !1, $) : _(m, g, O, w, x, R, V, I, $) }, pt = (f, m, g, O, w, x, R, V, I) => { let T = 0, K = m.length, $ = f.length - 1, B = K - 1; for (; T <= $ && T <= B;) { let X = f[T], ie = m[T] = I ? Wt(m[T]) : Dt(m[T]); if (ln(X, ie)) b(X, ie, g, null, w, x, R, V, I); else break; T++ } for (; T <= $ && T <= B;) { let X = f[$], ie = m[B] = I ? Wt(m[B]) : Dt(m[B]); if (ln(X, ie)) b(X, ie, g, null, w, x, R, V, I); else break; $--, B-- } if (T > $) { if (T <= B) { let X = B + 1, ie = X < K ? m[X].el : O; for (; T <= B;)b(null, m[T] = I ? Wt(m[T]) : Dt(m[T]), g, ie, w, x, R, V, I), T++ } } else if (T > B) for (; T <= $;)ut(f[T], w, x, !0), T++; else { let X = T, ie = T, fe = new Map; for (T = ie; T <= B; T++) { let Je = m[T] = I ? Wt(m[T]) : Dt(m[T]); Je.key != null && fe.set(Je.key, T) } let ue, qe = 0, Ae = B - ie + 1, dt = !1, Xe = 0, Un = new Array(Ae); for (T = 0; T < Ae; T++)Un[T] = 0; for (T = X; T <= $; T++) { let Je = f[T]; if (qe >= Ae) { ut(Je, w, x, !0); continue } let mt; if (Je.key != null) mt = fe.get(Je.key); else for (ue = ie; ue <= B; ue++)if (Un[ue - ie] === 0 && ln(Je, m[ue])) { mt = ue; break } mt === void 0 ? ut(Je, w, x, !0) : (Un[mt - ie] = T + 1, mt >= Xe ? Xe = mt : dt = !0, b(Je, m[mt], g, null, w, x, R, V, I), qe++) } let Nr = dt ? Wu(Un) : en; for (ue = Nr.length - 1, T = Ae - 1; T >= 0; T--) { let Je = ie + T, mt = m[Je], wr = Je + 1 < K ? m[Je + 1].el : O; Un[T] === 0 ? b(null, mt, g, wr, w, x, R, V, I) : dt && (ue < 0 || T !== Nr[ue] ? ht(mt, g, wr, 2) : ue--) } } }, ht = (f, m, g, O, w = null) => { let { el: x, type: R, transition: V, children: I, shapeFlag: T } = f; if (T & 6) { ht(f.component.subTree, m, g, O); return } if (T & 128) { f.suspense.move(m, g, O); return } if (T & 64) { R.move(f, m, g, hn); return } if (R === ae) { o(x, m, g); for (let $ = 0; $ < I.length; $++)ht(I[$], m, g, O); o(f.anchor, m, g); return } if (R === Dn) { G(f, m, g); return } if (O !== 2 && T & 1 && V) if (O === 0) V.beforeEnter(x), o(x, m, g), Qe(() => V.enter(x), w); else { let { leave: $, delayLeave: B, afterLeave: X } = V, ie = () => { f.ctx.isUnmounted ? s(x) : o(x, m, g) }, fe = () => { $(x, () => { ie(), X && X() }) }; B ? B(x, ie, fe) : fe() } else o(x, m, g) }, ut = (f, m, g, O = !1, w = !1) => { let { type: x, props: R, ref: V, children: I, dynamicChildren: T, shapeFlag: K, patchFlag: $, dirs: B, cacheIndex: X } = f; if ($ === -2 && (w = !1), V != null && (Ot(), os(V, null, g, f, !0), xt()), X != null && (m.renderCache[X] = void 0), K & 256) { m.ctx.deactivate(f); return } let ie = K & 1 && B, fe = !Tn(f), ue; if (fe && (ue = R && R.onVnodeBeforeUnmount) && Tt(ue, m, f), K & 6) gc(f.component, g, O); else { if (K & 128) { f.suspense.unmount(g, O); return } ie && rn(f, null, m, "beforeUnmount"), K & 64 ? f.type.remove(f, m, g, hn, O) : T && !T.hasOnce && (x !== ae || $ > 0 && $ & 64) ? Fn(T, m, g, !1, !0) : (x === ae && $ & 384 || !w && K & 16) && Fn(I, m, g), O && Er(f) } (fe && (ue = R && R.onVnodeUnmounted) || ie) && Qe(() => { ue && Tt(ue, m, f), ie && rn(f, null, m, "unmounted") }, g) }, Er = f => { let { type: m, el: g, anchor: O, transition: w } = f; if (m === ae) { vc(g, O); return } if (m === Dn) { C(f); return } let x = () => { s(g), w && !w.persisted && w.afterLeave && w.afterLeave() }; if (f.shapeFlag & 1 && w && !w.persisted) { let { leave: R, delayLeave: V } = w, I = () => R(g, x); V ? V(f.el, x, I) : I() } else x() }, vc = (f, m) => { let g; for (; f !== m;)g = p(f), s(f), f = g; s(m) }, gc = (f, m, g) => { let { bum: O, scope: w, job: x, subTree: R, um: V, m: I, a: T, parent: K, slots: { __: $ } } = f; ia(I), ia(T), O && En(O), K && W($) && $.forEach(B => { K.renderCache[B] = void 0 }), w.stop(), x && (x.flags |= 8, ut(R, f, m, g)), V && Qe(V, m), Qe(() => { f.isUnmounted = !0 }, m), m && m.pendingBranch && !m.isUnmounted && f.asyncDep && !f.asyncResolved && f.suspenseId === m.pendingId && (m.deps--, m.deps === 0 && m.resolve()), __VUE_PROD_DEVTOOLS__ && mu(f) }, Fn = (f, m, g, O = !1, w = !1, x = 0) => { for (let R = x; R < f.length; R++)ut(f[R], m, g, O, w) }, So = f => { if (f.shapeFlag & 6) return So(f.component.subTree); if (f.shapeFlag & 128) return f.suspense.next(); let m = p(f.anchor || f.el), g = m && m[gu]; return g ? p(g) : m }, Rs = !1, br = (f, m, g) => { f == null ? m._vnode && ut(m._vnode, null, null, !0) : b(m._vnode || null, f, m, null, null, null, g), m._vnode = f, Rs || (Rs = !0, Jr(), va(), Rs = !1) }, hn = { p: b, um: ut, m: ht, r: Er, mt: Z, mc: _, pc: xe, pbc: Y, n: So, o: e }, $s, Ps; return t && ([$s, Ps] = t(hn)), { render: br, hydrate: $s, createApp: Au(br, $s) } } function Ni({ type: e, props: t }, n) { return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n } function an({ effect: e, job: t }, n) { n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5) } function ju(e, t) { return (!e || e && !e.pendingBranch) && t && !t.persisted } function ja(e, t, n = !1) { let o = e.children, s = t.children; if (W(o) && W(s)) for (let i = 0; i < o.length; i++) { let r = o[i], a = s[i]; a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = s[i] = Wt(s[i]), a.el = r.el), !n && a.patchFlag !== -2 && ja(r, a)), a.type === go && (a.el = r.el), a.type === Ie && !a.el && (a.el = r.el) } } function Wu(e) { let t = e.slice(), n = [0], o, s, i, r, a, l = e.length; for (o = 0; o < l; o++) { let u = e[o]; if (u !== 0) { if (s = n[n.length - 1], e[s] < u) { t[o] = s, n.push(o); continue } for (i = 0, r = n.length - 1; i < r;)a = i + r >> 1, e[n[a]] < u ? i = a + 1 : r = a; u < e[n[i]] && (i > 0 && (t[o] = n[i - 1]), n[i] = o) } } for (i = n.length, r = n[i - 1]; i-- > 0;)n[i] = r, r = t[r]; return n } function Wa(e) { let t = e.subTree.component; if (t) return t.asyncDep && !t.asyncResolved ? t : Wa(t) } function ia(e) { if (e) for (let t = 0; t < e.length; t++)e[t].flags |= 8 } var Ku = Symbol.for("v-scx"), Gu = () => { { let e = cn(Ku); return e } }; function ze(e, t, n) { return Ka(e, t, n) } function Ka(e, t, n = ce) { let { immediate: o, deep: s, flush: i, once: r } = n, a = ge({}, n), l = t && o || !t && i !== "post", u; if (mo) { if (i === "sync") { let h = Gu(); u = h.__watcherHandles || (h.__watcherHandles = []) } else if (!l) { let h = () => { }; return h.stop = Ue, h.resume = Ue, h.pause = Ue, h } } let c = Me; a.call = (h, v, b) => lt(h, c, v, b); let d = !1; i === "post" ? a.scheduler = h => { Qe(h, c && c.suspense) } : i !== "sync" && (d = !0, a.scheduler = (h, v) => { v ? h() : ki(h) }), a.augmentJob = h => { t && (h.flags |= 4), d && (h.flags |= 2, c && (h.id = c.uid, h.i = c)) }; let p = Xr(e, t, a); return mo && (u ? u.push(p) : l && p()), p } function zu(e, t, n) { let o = this.proxy, s = ve(e) ? e.includes(".") ? Ga(o, e) : () => o[e] : e.bind(o, o), i; q(t) ? i = t : (i = t.handler, n = t); let r = yo(this), a = Ka(s, i.bind(o), n); return r(), a } function Ga(e, t) { let n = t.split("."); return () => { let o = e; for (let s = 0; s < n.length && o; s++)o = o[n[s]]; return o } } var Yu = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${$e(t)}Modifiers`] || e[`${yt(t)}Modifiers`]; function qu(e, t, ...n) { if (e.isUnmounted) return; let o = e.vnode.props || ce, s = n, i = t.startsWith("update:"), r = i && Yu(o, t.slice(7)); r && (r.trim && (s = n.map(c => ve(c) ? c.trim() : c)), r.number && (s = n.map(Jn))), __VUE_PROD_DEVTOOLS__ && vu(e, t, s); let a, l = o[a = Xn(t)] || o[a = Xn($e(t))]; !l && i && (l = o[a = Xn(yt(t))]), l && lt(l, e, 6, s); let u = o[a + "Once"]; if (u) { if (!e.emitted) e.emitted = {}; else if (e.emitted[a]) return; e.emitted[a] = !0, lt(u, e, 6, s) } } function za(e, t, n = !1) { let o = t.emitsCache, s = o.get(e); if (s !== void 0) return s; let i = e.emits, r = {}, a = !1; if (__VUE_OPTIONS_API__ && !q(e)) { let l = u => { let c = za(u, t, !0); c && (a = !0, ge(r, c)) }; !n && t.mixins.length && t.mixins.forEach(l), e.extends && l(e.extends), e.mixins && e.mixins.forEach(l) } return !i && !a ? (de(e) && o.set(e, null), null) : (W(i) ? i.forEach(l => r[l] = null) : ge(r, i), de(e) && o.set(e, r), r) } function ps(e, t) { return !e || !_n(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), re(e, t[0].toLowerCase() + t.slice(1)) || re(e, yt(t)) || re(e, t)) } function wi(e) { let { type: t, vnode: n, proxy: o, withProxy: s, propsOptions: [i], slots: r, attrs: a, emit: l, render: u, renderCache: c, props: d, data: p, setupState: h, ctx: v, inheritAttrs: b } = e, y = ns(e), E, N; try { if (n.shapeFlag & 4) { let C = s || o, D = C; E = Dt(u.call(D, C, c, d, h, p, v)), N = a } else { let C = t; E = Dt(C.length > 1 ? C(d, { attrs: a, slots: r, emit: l }) : C(d, null)), N = t.props ? a : Xu(a) } } catch (C) { uo.length = 0, rs(C, e, 1), E = oe(Ie) } let k = E, G; if (N && b !== !1) { let C = Object.keys(N), { shapeFlag: D } = k; C.length && D & 7 && (i && C.some(Yn) && (N = Ju(N, i)), k = Gt(k, N, !1, !0)) } return n.dirs && (k = Gt(k, null, !1, !0), k.dirs = k.dirs ? k.dirs.concat(n.dirs) : n.dirs), n.transition && Kt(k, n.transition), E = k, ns(y), E } var Xu = e => { let t; for (let n in e) (n === "class" || n === "style" || _n(n)) && ((t || (t = {}))[n] = e[n]); return t }, Ju = (e, t) => { let n = {}; for (let o in e) (!Yn(o) || !(o.slice(9) in t)) && (n[o] = e[o]); return n }; function Zu(e, t, n) { let { props: o, children: s, component: i } = e, { props: r, children: a, patchFlag: l } = t, u = i.emitsOptions; if (t.dirs || t.transition) return !0; if (n && l >= 0) { if (l & 1024) return !0; if (l & 16) return o ? ra(o, r, u) : !!r; if (l & 8) { let c = t.dynamicProps; for (let d = 0; d < c.length; d++) { let p = c[d]; if (r[p] !== o[p] && !ps(u, p)) return !0 } } } else return (s || a) && (!a || !a.$stable) ? !0 : o === r ? !1 : o ? r ? ra(o, r, u) : !0 : !!r; return !1 } function ra(e, t, n) { let o = Object.keys(t); if (o.length !== Object.keys(e).length) return !0; for (let s = 0; s < o.length; s++) { let i = o[s]; if (t[i] !== e[i] && !ps(n, i)) return !0 } return !1 } function Qu({ vnode: e, parent: t }, n) { for (; t;) { let o = t.subTree; if (o.suspense && o.suspense.activeBranch === e && (o.el = e.el), o === e) (e = t.vnode).el = n, t = t.parent; else break } } var Ya = e => e.__isSuspense; function ed(e, t) { t && t.pendingBranch ? W(e) ? t.effects.push(...e) : t.effects.push(e) : ma(e) } var ae = Symbol.for("v-fgt"), go = Symbol.for("v-txt"), Ie = Symbol.for("v-cmt"), Dn = Symbol.for("v-stc"), uo = [], et = null; function S(e = !1) { uo.push(et = e ? null : []) } function td() { uo.pop(), et = uo[uo.length - 1] || null } var po = 1; function aa(e, t = !1) { po += e, e < 0 && et && t && (et.hasOnce = !0) } function qa(e) { return e.dynamicChildren = po > 0 ? et || en : null, td(), po > 0 && et && et.push(e), e } function H(e, t, n, o, s, i) { return qa(F(e, t, n, o, s, i, !0)) } function Oe(e, t, n, o, s) { return qa(oe(e, t, n, o, s, !0)) } function ho(e) { return e ? e.__v_isVNode === !0 : !1 } function ln(e, t) { return e.type === t.type && e.key === t.key } var Xa = ({ key: e }) => e ?? null, es = ({ ref: e, ref_key: t, ref_for: n }) => (typeof e == "number" && (e = "" + e), e != null ? ve(e) || be(e) || q(e) ? { i: Te, r: e, k: t, f: !!n } : e : null); function F(e, t = null, n = null, o = 0, s = null, i = e === ae ? 0 : 1, r = !1, a = !1) { let l = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && Xa(t), ref: t && es(t), scopeId: Ea, slotScopeIds: null, children: n, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: i, patchFlag: o, dynamicProps: s, dynamicChildren: null, appContext: null, ctx: Te }; return a ? (Fi(l, n), i & 128 && e.normalize(l)) : n && (l.shapeFlag |= ve(n) ? 8 : 16), po > 0 && !r && et && (l.patchFlag > 0 || i & 6) && l.patchFlag !== 32 && et.push(l), l } var oe = nd; function nd(e, t = null, n = null, o = 0, s = null, i = !1) { if ((!e || e === Da) && (e = Ie), ho(e)) { let a = Gt(e, t, !0); return n && Fi(a, n), po > 0 && !i && et && (a.shapeFlag & 6 ? et[et.indexOf(e)] = a : et.push(a)), a.patchFlag = -2, a } if (pd(e) && (e = e.__vccOpts), t) { t = od(t); let { class: a, style: l } = t; a && !ve(a) && (t.class = we(a)), de(l) && (ro(l) && !W(l) && (l = ge({}, l)), t.style = Ke(l)) } let r = ve(e) ? 1 : Ya(e) ? 128 : ba(e) ? 64 : de(e) ? 4 : q(e) ? 2 : 0; return F(e, t, n, o, s, r, i, !0) } function od(e) { return e ? ro(e) || $a(e) ? ge({}, e) : e : null } function Gt(e, t, n = !1, o = !1) { let { props: s, ref: i, patchFlag: r, children: a, transition: l } = e, u = t ? sd(s || {}, t) : s, c = { __v_isVNode: !0, __v_skip: !0, type: e.type, props: u, key: u && Xa(u), ref: t && t.ref ? n && i ? W(i) ? i.concat(es(t)) : [i, es(t)] : es(t) : i, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: a, target: e.target, targetStart: e.targetStart, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== ae ? r === -1 ? 16 : r | 16 : r, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: l, component: e.component, suspense: e.suspense, ssContent: e.ssContent && Gt(e.ssContent), ssFallback: e.ssFallback && Gt(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce }; return l && o && Kt(c, l.clone(c)), c } function Hi(e = " ", t = 0) { return oe(go, null, e, t) } function _o(e, t) { let n = oe(Dn, null, e); return n.staticCount = t, n } function Se(e = "", t = !1) { return t ? (S(), Oe(Ie, null, e)) : oe(Ie, null, e) } function Dt(e) { return e == null || typeof e == "boolean" ? oe(Ie) : W(e) ? oe(ae, null, e.slice()) : ho(e) ? Wt(e) : oe(go, null, String(e)) } function Wt(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : Gt(e) } function Fi(e, t) { let n = 0, { shapeFlag: o } = e; if (t == null) t = null; else if (W(t)) n = 16; else if (typeof t == "object") if (o & 65) { let s = t.default; s && (s._c && (s._d = !1), Fi(e, s()), s._c && (s._d = !0)); return } else { n = 32; let s = t._; !s && !$a(t) ? t._ctx = Te : s === 3 && Te && (Te.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else q(t) ? (t = { default: t, _ctx: Te }, n = 32) : (t = String(t), o & 64 ? (n = 16, t = [Hi(t)]) : n = 8); e.children = t, e.shapeFlag |= n } function sd(...e) { let t = {}; for (let n = 0; n < e.length; n++) { let o = e[n]; for (let s in o) if (s === "class") t.class !== o.class && (t.class = we([t.class, o.class])); else if (s === "style") t.style = Ke([t.style, o.style]); else if (_n(s)) { let i = t[s], r = o[s]; r && i !== r && !(W(i) && i.includes(r)) && (t[s] = i ? [].concat(i, r) : r) } else s !== "" && (t[s] = o[s]) } return t } function Tt(e, t, n, o = null) { lt(e, t, 7, [n, o]) } var id = Va(), rd = 0; function ad(e, t, n) { let o = e.type, s = (t ? t.appContext : e.appContext) || id, i = { uid: rd++, vnode: e, type: o, parent: t, appContext: s, root: null, next: null, subTree: null, effect: null, update: null, job: null, scope: new to(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(s.provides), ids: t ? t.ids : ["", 0, 0], accessCache: null, renderCache: [], components: null, directives: null, propsOptions: La(o, s), emitsOptions: za(o, s), emit: null, emitted: null, propsDefaults: ce, inheritAttrs: o.inheritAttrs, ctx: ce, data: ce, props: ce, attrs: ce, slots: ce, refs: ce, setupState: ce, setupContext: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return i.ctx = { _: i }, i.root = t ? t.root : i, i.emit = qu.bind(null, i), e.ce && e.ce(i), i } var Me = null, Ui = () => Me || Te, is, Di; { let e = Ft(), t = (n, o) => { let s; return (s = e[n]) || (s = e[n] = []), s.push(o), i => { s.length > 1 ? s.forEach(r => r(i)) : s[0](i) } }; is = t("__VUE_INSTANCE_SETTERS__", n => Me = n), Di = t("__VUE_SSR_SETTERS__", n => mo = n) } var yo = e => { let t = Me; return is(e), e.scope.on(), () => { e.scope.off(), is(t) } }, la = () => { Me && Me.scope.off(), is(null) }; function Ja(e) { return e.vnode.shapeFlag & 4 } var mo = !1; function ld(e, t = !1, n = !1) { t && Di(t); let { props: o, children: s } = e.vnode, i = Ja(e); Ru(e, o, i, t), Hu(e, s, n || t); let r = i ? cd(e, t) : void 0; return t && Di(!1), r } function cd(e, t) { var n; let o = e.type; e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, Tu); let { setup: s } = o; if (s) { Ot(); let i = e.setupContext = s.length > 1 ? dd(e) : null, r = yo(e), a = vo(s, e, 0, [e.props, i]), l = Js(a); if (xt(), r(), (l || e.sp) && !Tn(e) && Ca(e), l) { if (a.then(la, la), t) return a.then(u => { ca(e, u, t) }).catch(u => { rs(u, e, 0) }); e.asyncDep = a } else ca(e, a, t) } else Za(e, t) } function ca(e, t, n) { q(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : de(t) && (__VUE_PROD_DEVTOOLS__ && (e.devtoolsRawSetupState = t), e.setupState = Jo(t)), Za(e, n) } var ua, da; function Za(e, t, n) { let o = e.type; if (!e.render) { if (!t && ua && !o.render) { let s = o.template || __VUE_OPTIONS_API__ && $i(e).template; if (s) { let { isCustomElement: i, compilerOptions: r } = e.appContext.config, { delimiters: a, compilerOptions: l } = o, u = ge(ge({ isCustomElement: i, delimiters: a }, r), l); o.render = ua(s, u) } } e.render = o.render || Ue, da && da(e) } if (__VUE_OPTIONS_API__) { let s = yo(e); Ot(); try { Su(e) } finally { xt(), s() } } } var ud = { get(e, t) { return ke(e, "get", ""), e[t] } }; function dd(e) { let t = n => { e.exposed = n || {} }; return { attrs: new Proxy(e.attrs, ud), slots: e.slots, emit: e.emit, expose: t } } function hs(e) { return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Jo(Ze(e.exposed)), { get(t, n) { if (n in t) return t[n]; if (n in co) return co[n](e) }, has(t, n) { return n in t || n in co } })) : e.proxy } function fd(e, t = !0) { return q(e) ? e.displayName || e.name : e.name || t && e.__name } function pd(e) { return q(e) && "__vccOpts" in e } var j = (e, t) => Yr(e, t, mo); function ms(e, t, n) { let o = arguments.length; return o === 2 ? de(t) && !W(t) ? ho(t) ? oe(e, null, [t]) : oe(e, t) : oe(e, null, t) : (o > 3 ? n = Array.prototype.slice.call(arguments, 2) : o === 3 && ho(n) && (n = [n]), oe(e, t, n)) } var fa = "3.5.16"; var Gi, Qa = typeof window < "u" && window.trustedTypes; if (Qa) try { Gi = Qa.createPolicy("vue", { createHTML: e => e }) } catch { } var _l = Gi ? e => Gi.createHTML(e) : e => e, hd = "http://www.w3.org/2000/svg", md = "http://www.w3.org/1998/Math/MathML", Ht = typeof document < "u" ? document : null, el = Ht && Ht.createElement("template"), vd = { insert: (e, t, n) => { t.insertBefore(e, n || null) }, remove: e => { let t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, n, o) => { let s = t === "svg" ? Ht.createElementNS(hd, e) : t === "mathml" ? Ht.createElementNS(md, e) : n ? Ht.createElement(e, { is: n }) : Ht.createElement(e); return e === "select" && o && o.multiple != null && s.setAttribute("multiple", o.multiple), s }, createText: e => Ht.createTextNode(e), createComment: e => Ht.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => Ht.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, n, o, s, i) { let r = n ? n.previousSibling : t.lastChild; if (s && (s === i || s.nextSibling)) for (; t.insertBefore(s.cloneNode(!0), n), !(s === i || !(s = s.nextSibling));); else { el.innerHTML = _l(o === "svg" ? `<svg>${e}</svg>` : o === "mathml" ? `<math>${e}</math>` : e); let a = el.content; if (o === "svg" || o === "mathml") { let l = a.firstChild; for (; l.firstChild;)a.appendChild(l.firstChild); a.removeChild(l) } t.insertBefore(a, n) } return [r ? r.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild] } }, qt = "transition", Eo = "animation", $n = Symbol("_vtc"), yl = { name: String, type: String, css: { type: Boolean, default: !0 }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }, El = ge({}, Vi, yl), gd = e => (e.displayName = "Transition", e.props = El, e), ys = gd((e, { slots: t }) => ms(Oa, bl(e), t)), un = (e, t = []) => { W(e) ? e.forEach(n => n(...t)) : e && e(...t) }, tl = e => e ? W(e) ? e.some(t => t.length > 1) : e.length > 1 : !1; function bl(e) { let t = {}; for (let L in e) L in yl || (t[L] = e[L]); if (e.css === !1) return t; let { name: n = "v", type: o, duration: s, enterFromClass: i = `${n}-enter-from`, enterActiveClass: r = `${n}-enter-active`, enterToClass: a = `${n}-enter-to`, appearFromClass: l = i, appearActiveClass: u = r, appearToClass: c = a, leaveFromClass: d = `${n}-leave-from`, leaveActiveClass: p = `${n}-leave-active`, leaveToClass: h = `${n}-leave-to` } = e, v = _d(s), b = v && v[0], y = v && v[1], { onBeforeEnter: E, onEnter: N, onEnterCancelled: k, onLeave: G, onLeaveCancelled: C, onBeforeAppear: D = E, onAppear: z = N, onAppearCancelled: P = k } = t, _ = (L, le, A, Z) => { L._enterCancelled = Z, Xt(L, le ? c : a), Xt(L, le ? u : r), A && A() }, M = (L, le) => { L._isLeaving = !1, Xt(L, d), Xt(L, h), Xt(L, p), le && le() }, Y = L => (le, A) => { let Z = L ? z : N, J = () => _(le, L, A); un(Z, [le, J]), nl(() => { Xt(le, L ? l : i), It(le, L ? c : a), tl(Z) || ol(le, o, b, J) }) }; return ge(t, { onBeforeEnter(L) { un(E, [L]), It(L, i), It(L, r) }, onBeforeAppear(L) { un(D, [L]), It(L, l), It(L, u) }, onEnter: Y(!1), onAppear: Y(!0), onLeave(L, le) { L._isLeaving = !0; let A = () => M(L, le); It(L, d), L._enterCancelled ? (It(L, p), zi()) : (zi(), It(L, p)), nl(() => { L._isLeaving && (Xt(L, d), It(L, h), tl(G) || ol(L, o, y, A)) }), un(G, [L, A]) }, onEnterCancelled(L) { _(L, !1, void 0, !0), un(k, [L]) }, onAppearCancelled(L) { _(L, !0, void 0, !0), un(P, [L]) }, onLeaveCancelled(L) { M(L), un(C, [L]) } }) } function _d(e) { if (e == null) return null; if (de(e)) return [Bi(e.enter), Bi(e.leave)]; { let t = Bi(e); return [t, t] } } function Bi(e) { return Qs(e) } function It(e, t) { t.split(/\s+/).forEach(n => n && e.classList.add(n)), (e[$n] || (e[$n] = new Set)).add(t) } function Xt(e, t) { t.split(/\s+/).forEach(o => o && e.classList.remove(o)); let n = e[$n]; n && (n.delete(t), n.size || (e[$n] = void 0)) } function nl(e) { requestAnimationFrame(() => { requestAnimationFrame(e) }) } var yd = 0; function ol(e, t, n, o) { let s = e._endId = ++yd, i = () => { s === e._endId && o() }; if (n != null) return setTimeout(i, n); let { type: r, timeout: a, propCount: l } = Nl(e, t); if (!r) return o(); let u = r + "end", c = 0, d = () => { e.removeEventListener(u, p), i() }, p = h => { h.target === e && ++c >= l && d() }; setTimeout(() => { c < l && d() }, a + 1), e.addEventListener(u, p) } function Nl(e, t) { let n = window.getComputedStyle(e), o = v => (n[v] || "").split(", "), s = o(`${qt}Delay`), i = o(`${qt}Duration`), r = sl(s, i), a = o(`${Eo}Delay`), l = o(`${Eo}Duration`), u = sl(a, l), c = null, d = 0, p = 0; t === qt ? r > 0 && (c = qt, d = r, p = i.length) : t === Eo ? u > 0 && (c = Eo, d = u, p = l.length) : (d = Math.max(r, u), c = d > 0 ? r > u ? qt : Eo : null, p = c ? c === qt ? i.length : l.length : 0); let h = c === qt && /\b(transform|all)(,|$)/.test(o(`${qt}Property`).toString()); return { type: c, timeout: d, propCount: p, hasTransform: h } } function sl(e, t) { for (; e.length < t.length;)e = e.concat(e); return Math.max(...t.map((n, o) => il(n) + il(e[o]))) } function il(e) { return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3 } function zi() { return document.body.offsetHeight } function Ed(e, t, n) { let o = e[$n]; o && (t = (t ? [t, ...o] : [...o]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t } var gs = Symbol("_vod"), wl = Symbol("_vsh"), Yi = { beforeMount(e, { value: t }, { transition: n }) { e[gs] = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : bo(e, t) }, mounted(e, { value: t }, { transition: n }) { n && t && n.enter(e) }, updated(e, { value: t, oldValue: n }, { transition: o }) { !t != !n && (o ? t ? (o.beforeEnter(e), bo(e, !0), o.enter(e)) : o.leave(e, () => { bo(e, !1) }) : bo(e, t)) }, beforeUnmount(e, { value: t }) { bo(e, t) } }; function bo(e, t) { e.style.display = t ? e[gs] : "none", e[wl] = !t } var bd = Symbol(""); var Nd = /(^|;)\s*display\s*:/; function wd(e, t, n) { let o = e.style, s = ve(n), i = !1; if (n && !s) { if (t) if (ve(t)) for (let r of t.split(";")) { let a = r.slice(0, r.indexOf(":")).trim(); n[a] == null && vs(o, a, "") } else for (let r in t) n[r] == null && vs(o, r, ""); for (let r in n) r === "display" && (i = !0), vs(o, r, n[r]) } else if (s) { if (t !== n) { let r = o[bd]; r && (n += ";" + r), o.cssText = n, i = Nd.test(n) } } else t && e.removeAttribute("style"); gs in e && (e[gs] = i ? o.display : "", e[wl] && (o.display = "none")) } var rl = /\s*!important$/; function vs(e, t, n) { if (W(n)) n.forEach(o => vs(e, t, o)); else if (n == null && (n = ""), t.startsWith("--")) e.setProperty(t, n); else { let o = Od(e, t); rl.test(n) ? e.setProperty(yt(o), n.replace(rl, ""), "important") : e[o] = n } } var al = ["Webkit", "Moz", "ms"], ji = {}; function Od(e, t) { let n = ji[t]; if (n) return n; let o = $e(t); if (o !== "filter" && o in e) return ji[t] = o; o = nn(o); for (let s = 0; s < al.length; s++) { let i = al[s] + o; if (i in e) return ji[t] = i } return t } var ll = "http://www.w3.org/1999/xlink"; function cl(e, t, n, o, s, i = Dr(t)) { o && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(ll, t.slice(6, t.length)) : e.setAttributeNS(ll, t, n) : n == null || i && !Lo(n) ? e.removeAttribute(t) : e.setAttribute(t, i ? "" : rt(n) ? String(n) : n) } function ul(e, t, n, o, s) { if (t === "innerHTML" || t === "textContent") { n != null && (e[t] = t === "innerHTML" ? _l(n) : n); return } let i = e.tagName; if (t === "value" && i !== "PROGRESS" && !i.includes("-")) { let a = i === "OPTION" ? e.getAttribute("value") || "" : e.value, l = n == null ? e.type === "checkbox" ? "on" : "" : String(n); (a !== l || !("_value" in e)) && (e.value = l), n == null && e.removeAttribute(t), e._value = n; return } let r = !1; if (n === "" || n == null) { let a = typeof e[t]; a === "boolean" ? n = Lo(n) : n == null && a === "string" ? (n = "", r = !0) : a === "number" && (n = 0, r = !0) } try { e[t] = n } catch { } r && e.removeAttribute(s || t) } function Rn(e, t, n, o) { e.addEventListener(t, n, o) } function xd(e, t, n, o) { e.removeEventListener(t, n, o) } var dl = Symbol("_vei"); function Cd(e, t, n, o, s = null) { let i = e[dl] || (e[dl] = {}), r = i[t]; if (o && r) r.value = o; else { let [a, l] = Td(t); if (o) { let u = i[t] = kd(o, s); Rn(e, a, u, l) } else r && (xd(e, a, r, l), i[t] = void 0) } } var fl = /(?:Once|Passive|Capture)$/; function Td(e) { let t; if (fl.test(e)) { t = {}; let o; for (; o = e.match(fl);)e = e.slice(0, e.length - o[0].length), t[o[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : yt(e.slice(2)), t] } var Wi = 0, Sd = Promise.resolve(), Dd = () => Wi || (Sd.then(() => Wi = 0), Wi = Date.now()); function kd(e, t) { let n = o => { if (!o._vts) o._vts = Date.now(); else if (o._vts <= n.attached) return; lt(Id(o, n.value), t, 5, [o]) }; return n.value = e, n.attached = Dd(), n } function Id(e, t) { if (W(t)) { let n = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { n.call(e), e._stopped = !0 }, t.map(o => s => !s._stopped && o && o(s)) } else return t } var pl = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, Md = (e, t, n, o, s, i) => { let r = s === "svg"; t === "class" ? Ed(e, o, r) : t === "style" ? wd(e, n, o) : _n(t) ? Yn(t) || Cd(e, t, n, o, i) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : Vd(e, t, o, r)) ? (ul(e, t, o), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && cl(e, t, o, r, i, t !== "value")) : e._isVueCE && (/[A-Z]/.test(t) || !ve(o)) ? ul(e, $e(t), o, i, t) : (t === "true-value" ? e._trueValue = o : t === "false-value" && (e._falseValue = o), cl(e, t, o, r)) }; function Vd(e, t, n, o) { if (o) return !!(t === "innerHTML" || t === "textContent" || t in e && pl(t) && q(n)); if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1; if (t === "width" || t === "height") { let s = e.tagName; if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE") return !1 } return pl(t) && ve(n) ? !1 : t in e } var Ol = new WeakMap, xl = new WeakMap, _s = Symbol("_moveCb"), hl = Symbol("_enterCb"), Ad = e => (delete e.props.mode, e), Rd = Ad({ name: "TransitionGroup", props: ge({}, El, { tag: String, moveClass: String }), setup(e, { slots: t }) { let n = Ui(), o = Mi(), s, i; return Vn(() => { if (!s.length) return; let r = e.moveClass || `${e.name || "v"}-move`; if (!Hd(s[0].el, n.vnode.el, r)) { s = []; return } s.forEach($d), s.forEach(Pd); let a = s.filter(Ld); zi(), a.forEach(l => { let u = l.el, c = u.style; It(u, r), c.transform = c.webkitTransform = c.transitionDuration = ""; let d = u[_s] = p => { p && p.target !== u || (!p || /transform$/.test(p.propertyName)) && (u.removeEventListener("transitionend", d), u[_s] = null, Xt(u, r)) }; u.addEventListener("transitionend", d) }), s = [] }), () => { let r = ne(e), a = bl(r), l = r.tag || ae; if (s = [], i) for (let u = 0; u < i.length; u++) { let c = i[u]; c.el && c.el instanceof Element && (s.push(c), Kt(c, kn(c, a, o, n)), Ol.set(c, c.el.getBoundingClientRect())) } i = t.default ? ls(t.default()) : []; for (let u = 0; u < i.length; u++) { let c = i[u]; c.key != null && Kt(c, kn(c, a, o, n)) } return oe(l, null, i) } } }), Cl = Rd; function $d(e) { let t = e.el; t[_s] && t[_s](), t[hl] && t[hl]() } function Pd(e) { xl.set(e, e.el.getBoundingClientRect()) } function Ld(e) { let t = Ol.get(e), n = xl.get(e), o = t.left - n.left, s = t.top - n.top; if (o || s) { let i = e.el.style; return i.transform = i.webkitTransform = `translate(${o}px,${s}px)`, i.transitionDuration = "0s", e } } function Hd(e, t, n) { let o = e.cloneNode(), s = e[$n]; s && s.forEach(a => { a.split(/\s+/).forEach(l => l && o.classList.remove(l)) }), n.split(/\s+/).forEach(a => a && o.classList.add(a)), o.style.display = "none"; let i = t.nodeType === 1 ? t : t.parentNode; i.appendChild(o); let { hasTransform: r } = Nl(o); return i.removeChild(o), r } var ml = e => { let t = e.props["onUpdate:modelValue"] || !1; return W(t) ? n => En(t, n) : t }; function Fd(e) { e.target.composing = !0 } function vl(e) { let t = e.target; t.composing && (t.composing = !1, t.dispatchEvent(new Event("input"))) } var Ki = Symbol("_assign"), dn = { created(e, { modifiers: { lazy: t, trim: n, number: o } }, s) { e[Ki] = ml(s); let i = o || s.props && s.props.type === "number"; Rn(e, t ? "change" : "input", r => { if (r.target.composing) return; let a = e.value; n && (a = a.trim()), i && (a = Jn(a)), e[Ki](a) }), n && Rn(e, "change", () => { e.value = e.value.trim() }), t || (Rn(e, "compositionstart", Fd), Rn(e, "compositionend", vl), Rn(e, "change", vl)) }, mounted(e, { value: t }) { e.value = t ?? "" }, beforeUpdate(e, { value: t, oldValue: n, modifiers: { lazy: o, trim: s, number: i } }, r) { if (e[Ki] = ml(r), e.composing) return; let a = (i || e.type === "number") && !/^0\d/.test(e.value) ? Jn(e.value) : e.value, l = t ?? ""; a !== l && (document.activeElement === e && e.type !== "range" && (o && t === n || s && e.value.trim() === l) || (e.value = l)) } }; var Ud = ["ctrl", "shift", "alt", "meta"], Bd = { stop: e => e.stopPropagation(), prevent: e => e.preventDefault(), self: e => e.target !== e.currentTarget, ctrl: e => !e.ctrlKey, shift: e => !e.shiftKey, alt: e => !e.altKey, meta: e => !e.metaKey, left: e => "button" in e && e.button !== 0, middle: e => "button" in e && e.button !== 1, right: e => "button" in e && e.button !== 2, exact: (e, t) => Ud.some(n => e[`${n}Key`] && !t.includes(n)) }, He = (e, t) => { let n = e._withMods || (e._withMods = {}), o = t.join("."); return n[o] || (n[o] = (s, ...i) => { for (let r = 0; r < t.length; r++) { let a = Bd[t[r]]; if (a && a(s, t)) return } return e(s, ...i) }) }, jd = { esc: "escape", space: " ", up: "arrow-up", left: "arrow-left", right: "arrow-right", down: "arrow-down", delete: "backspace" }, Pn = (e, t) => { let n = e._withKeys || (e._withKeys = {}), o = t.join("."); return n[o] || (n[o] = s => { if (!("key" in s)) return; let i = yt(s.key); if (t.some(r => r === i || jd[r] === i)) return e(s) }) }, Wd = ge({ patchProp: Md }, vd), gl; function Kd() { return gl || (gl = Ba(Wd)) } var Tl = (...e) => { let t = Kd().createApp(...e), { mount: n } = t; return t.mount = o => { let s = zd(o); if (!s) return; let i = t._component; !q(i) && !i.render && !i.template && (i.template = s.innerHTML), s.nodeType === 1 && (s.textContent = ""); let r = n(s, !1, Gd(s)); return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), r }, t }; function Gd(e) { if (e instanceof SVGElement) return "svg"; if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml" } function zd(e) { return ve(e) ? document.querySelector(e) : e } var Yd = ["INPUT", "TEXTAREA", "SELECT"]; function lr(e) { return Yd.includes(e.tagName) } function qd(e) { return e.position } function Xd(e, t, n) { e.position.x = t, e.position.y = n } var Ji = null; function Al(e) { Ji = e } function Ye() { if (!Ji) throw new Error("providePlugin() must be called before usePlugin()"); return { viewModel: Ji } } function nt() { let { viewModel: e } = Ye(); return { graph: $t(e.value, "displayedGraph"), switchGraph: e.value.switchGraph } } function cr(e) { let { graph: t } = nt(), n = U(null), o = U(null); return { dragging: j(() => !!n.value), onPointerDown: l => { n.value = { x: l.pageX, y: l.pageY }, o.value = { x: e.value.x, y: e.value.y } }, onPointerMove: l => { if (n.value) { let u = l.pageX - n.value.x, c = l.pageY - n.value.y; e.value.x = o.value.x + u / t.value.scaling, e.value.y = o.value.y + c / t.value.scaling } }, onPointerUp: () => { n.value = null, o.value = null } } } function Rl(e, t, n) { if (!t.template) return !1; if (_t(t.template) === n) return !0; let o = e.graphTemplates.find(i => _t(i) === n); return o ? o.nodes.filter(i => i.type.startsWith(Zt)).some(i => Rl(e, t, i.type)) : !1 } function ur(e) { return j(() => { let t = Array.from(e.value.editor.nodeTypes.entries()), n = new Set(t.map(([, s]) => s.category)), o = []; for (let s of n.values()) { let i = t.filter(([, r]) => r.category === s); e.value.displayedGraph.template ? i = i.filter(([r]) => !Rl(e.value.editor, e.value.displayedGraph, r)) : i = i.filter(([r]) => ![vt, gt].includes(r)), i.length > 0 && o.push({ name: s, nodeTypes: Object.fromEntries(i) }) } return o.sort((s, i) => s.name === "default" ? -1 : i.name === "default" || s.name > i.name ? 1 : -1), o }) } function dr() { let { graph: e } = nt(); return { transform: (n, o) => { let s = n / e.value.scaling - e.value.panning.x, i = o / e.value.scaling - e.value.panning.y; return [s, i] } } } function Jd() { let { graph: e } = nt(), t = [], n = -1, o = { x: 0, y: 0 }, s = j(() => e.value.panning), i = cr(s), r = j(() => ({ "transform-origin": "0 0", transform: `scale(${e.value.scaling}) translate(${e.value.panning.x}px, ${e.value.panning.y}px)` })), a = (h, v, b) => { let y = [h / e.value.scaling - e.value.panning.x, v / e.value.scaling - e.value.panning.y], E = [h / b - e.value.panning.x, v / b - e.value.panning.y], N = [E[0] - y[0], E[1] - y[1]]; e.value.panning.x += N[0], e.value.panning.y += N[1], e.value.scaling = b }, l = h => { h.preventDefault(); let v = h.deltaY; h.deltaMode === 1 && (v *= 32); let b = e.value.scaling * (1 - v / 3e3); a(h.offsetX, h.offsetY, b) }, u = () => ({ ax: t[0].clientX, ay: t[0].clientY, bx: t[1].clientX, by: t[1].clientY }); return { styles: r, ...i, onPointerDown: h => { if (t.push(h), i.onPointerDown(h), t.length === 2) { let { ax: v, ay: b, bx: y, by: E } = u(); o = { x: v + (y - v) / 2, y: b + (E - b) / 2 } } }, onPointerMove: h => { for (let v = 0; v < t.length; v++)if (h.pointerId == t[v].pointerId) { t[v] = h; break } if (t.length == 2) { let { ax: v, ay: b, bx: y, by: E } = u(), N = v - y, k = b - E, G = Math.sqrt(N * N + k * k); if (n > 0) { let C = e.value.scaling * (1 + (G - n) / 500); a(o.x, o.y, C) } n = G } else i.onPointerMove(h) }, onPointerUp: h => { t = t.filter(v => v.pointerId !== h.pointerId), n = -1, i.onPointerUp() }, onMouseWheel: l } } var tt = (e => (e[e.NONE = 0] = "NONE", e[e.ALLOWED = 1] = "ALLOWED", e[e.FORBIDDEN = 2] = "FORBIDDEN", e))(tt || {}), $l = Symbol(); function Pl() { let { graph: e } = nt(), t = U(null), n = U(null), o = a => { t.value && (t.value.mx = a.offsetX / e.value.scaling - e.value.panning.x, t.value.my = a.offsetY / e.value.scaling - e.value.panning.y) }, s = () => { if (n.value) { if (t.value) return; let a = e.value.connections.find(l => l.to === n.value); n.value.isInput && a ? (t.value = { status: tt.NONE, from: a.from }, e.value.removeConnection(a)) : t.value = { status: tt.NONE, from: n.value }, t.value.mx = void 0, t.value.my = void 0 } }, i = () => { if (t.value && n.value) { if (t.value.from === n.value) return; e.value.addConnection(t.value.from, t.value.to) } t.value = null }, r = a => { if (n.value = a ?? null, a && t.value) { t.value.to = a; let l = e.value.checkConnection(t.value.from, t.value.to); if (t.value.status = l.connectionAllowed ? tt.ALLOWED : tt.FORBIDDEN, l.connectionAllowed) { let u = l.connectionsInDanger.map(c => c.id); e.value.connections.forEach(c => { u.includes(c.id) && (c.isInDanger = !0) }) } } else !a && t.value && (t.value.to = void 0, t.value.status = tt.NONE, e.value.connections.forEach(l => { l.isInDanger = !1 })) }; return fs($l, { temporaryConnection: t, hoveredOver: r }), { temporaryConnection: t, onMouseMove: o, onMouseDown: s, onMouseUp: i, hoveredOver: r } } function Ll() { let e = cn($l); if (!e) throw new Error("useTemporaryConnection must be used within a BaklavaEditor"); return e } function Zd(e) { let t = U(!1), n = U(0), o = U(0), s = ur(e), { transform: i } = dr(), r = j(() => { let c = [], d = {}; for (let h of s.value) { let v = Object.entries(h.nodeTypes).map(([b, y]) => ({ label: y.title, value: "addNode:" + b })); h.name === "default" ? c = v : d[h.name] = v } let p = [...Object.entries(d).map(([h, v]) => ({ label: h, submenu: v }))]; return p.length > 0 && c.length > 0 && p.push({ isDivider: !0 }), p.push(...c), p }), a = j(() => e.value.settings.contextMenu.additionalItems.length === 0 ? r.value : [{ label: "Add node", submenu: r.value }, ...e.value.settings.contextMenu.additionalItems.map(c => "isDivider" in c || "submenu" in c ? c : { label: c.label, value: "command:" + c.command, disabled: !e.value.commandHandler.canExecuteCommand(c.command) })]); function l(c) { let d = c.target; if (!(d instanceof Element) || lr(d)) return; c.preventDefault(), t.value = !0; let p = d.getBoundingClientRect(), v = d.closest(".baklava-editor").getBoundingClientRect(); n.value = p.x + c.offsetX - v.x, o.value = p.y + c.offsetY - v.y } function u(c) { if (c.startsWith("addNode:")) { let d = c.substring(8), p = e.value.editor.nodeTypes.get(d); if (!p) return; let h = Le(new p.type); e.value.displayedGraph.addNode(h); let [v, b] = i(n.value, o.value); h.position.x = v, h.position.y = b } else if (c.startsWith("command:")) { let d = c.substring(8); e.value.commandHandler.canExecuteCommand(d) && e.value.commandHandler.executeCommand(d) } } return { show: t, x: n, y: o, items: a, open: l, onClick: u } } var wo = "START_SELECTION_BOX"; function Qd(e) { let { viewModel: t } = Ye(), { graph: n } = nt(), o = j(() => n.value.nodes), s = U(!1), i = U(!1), r = U([0, 0]), a = U([0, 0]); ze(t, () => { t.value.commandHandler.hasCommand(wo) || (t.value.commandHandler.registerCommand(wo, { canExecute: () => !0, execute() { s.value = !0 } }), t.value.commandHandler.registerHotkey(["b"], wo)) }, { immediate: !0 }); function l(E) { return [E.clientX - e.value.getBoundingClientRect().left, E.clientY - e.value.getBoundingClientRect().top] } function u(E) { return s.value ? (i.value = !0, s.value = !1, r.value = l(E), a.value = l(E), document.addEventListener("pointermove", c), document.addEventListener("pointerup", d), !0) : !1 } function c(E) { r.value = l(E) } function d(E) { document.removeEventListener("pointermove", c), document.removeEventListener("pointerup", d), r.value = l(E), i.value = !1; let N = p(); for (let k of N) t.value.displayedGraph.selectedNodes.push(k) } function p() { let E = h(), k = document.querySelector(".baklava-editor").getBoundingClientRect(); return o.value.filter(G => { let C = v(G, k); return b(E, C) }) } function h() { return { left: Math.min(r.value[0], a.value[0]), top: Math.min(r.value[1], a.value[1]), right: Math.max(r.value[0], a.value[0]), bottom: Math.max(r.value[1], a.value[1]) } } function v(E, N) { let k = document.getElementById(E.id), G = k ? k.getBoundingClientRect() : { x: 0, y: 0, width: 0, height: 0 }, C = G.x - N.left, D = G.y - N.top; return { left: C, top: D, right: C + G.width, bottom: D + G.height } } function b(E, N) { return E.left < N.right && E.right > N.left && E.top < N.bottom && E.bottom > N.top } function y() { return { width: Math.abs(a.value[0] - r.value[0]) + "px", height: Math.abs(a.value[1] - r.value[1]) + "px", left: (a.value[0] > r.value[0] ? r.value[0] : a.value[0]) + "px", top: (a.value[1] > r.value[1] ? r.value[1] : a.value[1]) + "px" } } return Le({ startSelection: s, isSelecting: i, start: r, end: a, onPointerDown: u, getStyles: y }) } var ef = me({ setup() { let { viewModel: e } = Ye(), { graph: t } = nt(); return { styles: j(() => { let o = e.value.settings.background, s = t.value.panning.x * t.value.scaling, i = t.value.panning.y * t.value.scaling, r = t.value.scaling * o.gridSize, a = r / o.gridDivision, l = `${r}px ${r}px, ${r}px ${r}px`, u = t.value.scaling > o.subGridVisibleThreshold ? `, ${a}px ${a}px, ${a}px ${a}px` : ""; return { backgroundPosition: `left ${s}px top ${i}px`, backgroundSize: `${l} ${u}` } }) } } }), he = (e, t) => { let n = e.__vccOpts || e; for (let [o, s] of t) n[o] = s; return n }; function tf(e, t, n, o, s, i) { return S(), H("div", { class: "background", style: Ke(e.styles) }, null, 4) } var nf = he(ef, [["render", tf]]); function of(e) { return zo() ? (fi(e), !0) : !1 } var Hl = typeof window < "u" && typeof document < "u"; typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope; var sf = Object.prototype.toString, rf = e => sf.call(e) === "[object Object]", Ln = () => { }, af = lf(); function lf() { var e, t; return Hl && ((e = window?.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window?.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent)) } function cf(e, t, n = !1) { return t.reduce((o, s) => (s in e && (!n || e[s] !== void 0) && (o[s] = e[s]), o), {}) } function qi(e) { return Array.isArray(e) ? e : [e] } function uf(e, t = {}) { if (!be(e)) return yi(e); let n = Array.isArray(e.value) ? Array.from({ length: e.value.length }) : {}; for (let o in e.value) n[o] = Zo(() => ({ get() { return e.value[o] }, set(s) { var i; if ((i = Ct(t.replaceRef)) != null ? i : !0) if (Array.isArray(e.value)) { let a = [...e.value]; a[o] = s, e.value = a } else { let a = { ...e.value, [o]: s }; Object.setPrototypeOf(a, Object.getPrototypeOf(e.value)), e.value = a } else e.value[o] = s } })); return n } function df(e, t, n) { return ze(e, t, { ...n, immediate: !0 }) } var fr = Hl ? window : void 0; function No(e) { var t; let n = Ct(e); return (t = n?.$el) != null ? t : n } function Oo(...e) { let t = [], n = () => { t.forEach(a => a()), t.length = 0 }, o = (a, l, u, c) => (a.addEventListener(l, u, c), () => a.removeEventListener(l, u, c)), s = j(() => { let a = qi(Ct(e[0])).filter(l => l != null); return a.every(l => typeof l != "string") ? a : void 0 }), i = df(() => { var a, l; return [(l = (a = s.value) == null ? void 0 : a.map(u => No(u))) != null ? l : [fr].filter(u => u != null), qi(Ct(s.value ? e[1] : e[0])), qi(Q(s.value ? e[2] : e[1])), Ct(s.value ? e[3] : e[2])] }, ([a, l, u, c]) => { if (n(), !a?.length || !l?.length || !u?.length) return; let d = rf(c) ? { ...c } : c; t.push(...a.flatMap(p => l.flatMap(h => u.map(v => o(p, h, v, d))))) }, { flush: "post" }), r = () => { i(), n() }; return of(n), r } var Sl = !1; function Fl(e, t, n = {}) { let { window: o = fr, ignore: s = [], capture: i = !0, detectIframe: r = !1, controls: a = !1 } = n; if (!o) return a ? { stop: Ln, cancel: Ln, trigger: Ln } : Ln; if (af && !Sl) { Sl = !0; let y = { passive: !0 }; Array.from(o.document.body.children).forEach(E => E.addEventListener("click", Ln, y)), o.document.documentElement.addEventListener("click", Ln, y) } let l = !0, u = y => Ct(s).some(E => { if (typeof E == "string") return Array.from(o.document.querySelectorAll(E)).some(N => N === y.target || y.composedPath().includes(N)); { let N = No(E); return N && (y.target === N || y.composedPath().includes(N)) } }); function c(y) { let E = Ct(y); return E && E.$.subTree.shapeFlag === 16 } function d(y, E) { let N = Ct(y), k = N.$.subTree && N.$.subTree.children; return k == null || !Array.isArray(k) ? !1 : k.some(G => G.el === E.target || E.composedPath().includes(G.el)) } let p = y => { let E = No(e); if (y.target != null && !(!(E instanceof Element) && c(e) && d(e, y)) && !(!E || E === y.target || y.composedPath().includes(E))) { if ("detail" in y && y.detail === 0 && (l = !u(y)), !l) { l = !0; return } t(y) } }, h = !1, v = [Oo(o, "click", y => { h || (h = !0, setTimeout(() => { h = !1 }, 0), p(y)) }, { passive: !0, capture: i }), Oo(o, "pointerdown", y => { let E = No(e); l = !u(y) && !!(E && !y.composedPath().includes(E)) }, { passive: !0 }), r && Oo(o, "blur", y => { setTimeout(() => { var E; let N = No(e); ((E = o.document.activeElement) == null ? void 0 : E.tagName) === "IFRAME" && !N?.contains(o.document.activeElement) && t(y) }, 0) }, { passive: !0 })].filter(Boolean), b = () => v.forEach(y => y()); return a ? { stop: b, cancel: () => { l = !1 }, trigger: y => { l = !0, p(y), l = !1 } } : b } var Ul = { x: 0, y: 0, pointerId: 0, pressure: 0, tiltX: 0, tiltY: 0, width: 0, height: 0, twist: 0, pointerType: null }, ff = Object.keys(Ul); function pf(e = {}) { let { target: t = fr } = e, n = Xo(!1), o = U(e.initialValue || {}); Object.assign(o.value, Ul, o.value); let s = i => { n.value = !0, !(e.pointerTypes && !e.pointerTypes.includes(i.pointerType)) && (o.value = cf(i, ff, !1)) }; if (t) { let i = { passive: !0 }; Oo(t, ["pointerdown", "pointermove", "pointerup"], s, i), Oo(t, "pointerleave", () => n.value = !1, i) } return { ...uf(o), isInside: n } } var hf = ["onMouseenter", "onMouseleave", "onClick"], mf = { class: "flex-fill" }, vf = { key: 0, class: "__submenu-icon", style: { "line-height": "1em" } }, Ms = me({ __name: "ContextMenu", props: { modelValue: { type: Boolean }, items: {}, x: { default: 0 }, y: { default: 0 }, isNested: { type: Boolean, default: !1 }, isFlipped: { default: () => ({ x: !1, y: !1 }) }, flippable: { type: Boolean, default: !1 } }, emits: ["update:modelValue", "click"], setup(e, { emit: t }) { let n = e, o = t, s = null, i = U(null), r = U(-1), a = U(0), l = U({ x: !1, y: !1 }), u = j(() => n.flippable && (l.value.x || n.isFlipped.x)), c = j(() => n.flippable && (l.value.y || n.isFlipped.y)), d = j(() => { let N = {}; return n.isNested || (N.top = (c.value ? n.y - a.value : n.y) + "px", N.left = n.x + "px"), N }), p = j(() => ({ "--flipped-x": u.value, "--flipped-y": c.value, "--nested": n.isNested })), h = j(() => n.items.map(N => ({ ...N, hover: !1 }))); ze([() => n.y, () => n.items], () => { var N, k, G, C; a.value = n.items.length * 30; let D = ((k = (N = i.value) == null ? void 0 : N.parentElement) == null ? void 0 : k.offsetWidth) ?? 0, z = ((C = (G = i.value) == null ? void 0 : G.parentElement) == null ? void 0 : C.offsetHeight) ?? 0; l.value.x = !n.isNested && n.x > D * .75, l.value.y = !n.isNested && n.y + a.value > z - 20 }), Fl(i, () => { n.modelValue && o("update:modelValue", !1) }); let v = N => { !N.submenu && N.value && (o("click", N.value), o("update:modelValue", !1)) }, b = N => { o("click", N), r.value = -1, n.isNested || o("update:modelValue", !1) }, y = (N, k) => { n.items[k].submenu && (r.value = k, s !== null && (clearTimeout(s), s = null)) }, E = (N, k) => { n.items[k].submenu && (s = window.setTimeout(() => { r.value = -1, s = null }, 200)) }; return (N, k) => { let G = Yt("ContextMenu", !0); return S(), Oe(ys, { name: "slide-fade" }, { default: Mn(() => [Pt(F("div", { ref_key: "el", ref: i, class: we(["baklava-context-menu", p.value]), style: Ke(d.value) }, [(S(!0), H(ae, null, ct(h.value, (C, D) => (S(), H(ae, null, [C.isDivider ? (S(), H("div", { key: `d-${D}`, class: "divider" })) : (S(), H("div", { key: `i-${D}`, class: we(["item", { submenu: !!C.submenu, "--disabled": !!C.disabled }]), onMouseenter: z => y(z, D), onMouseleave: z => E(z, D), onClick: He(z => v(C), ["stop", "prevent"]) }, [F("div", mf, Ee(C.label), 1), C.submenu ? (S(), H("div", vf, k[0] || (k[0] = [F("svg", { width: "13", height: "13", viewBox: "-60 120 250 250" }, [F("path", { d: "M160.875 279.5625 L70.875 369.5625 L70.875 189.5625 L160.875 279.5625 Z", stroke: "none", fill: "white" })], -1)]))) : Se("", !0), C.submenu ? (S(), Oe(G, { key: 1, "model-value": r.value === D, items: C.submenu, "is-nested": !0, "is-flipped": { x: u.value, y: c.value }, flippable: N.flippable, onClick: b }, null, 8, ["model-value", "items", "is-flipped", "flippable"])) : Se("", !0)], 42, hf))], 64))), 256))], 6), [[Yi, N.modelValue]])]), _: 1 }) } } }), gf = {}, _f = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "16", height: "16", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function yf(e, t) { return S(), H("svg", _f, t[0] || (t[0] = [F("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, null, -1), F("circle", { cx: "12", cy: "12", r: "1" }, null, -1), F("circle", { cx: "12", cy: "19", r: "1" }, null, -1), F("circle", { cx: "12", cy: "5", r: "1" }, null, -1)])) } var Bl = he(gf, [["render", yf]]), Ef = ["id"], bf = { key: 0, class: "__tooltip" }, Nf = { key: 2, class: "align-middle" }, Zi = me({ __name: "NodeInterface", props: { node: {}, intf: {} }, setup(e) { let t = (y, E = 100) => { let N = typeof y?.toString == "function" ? String(y) : ""; return N.length > E ? N.slice(0, E) + "..." : N }, n = e, { viewModel: o } = Ye(), { hoveredOver: s, temporaryConnection: i } = Ll(), r = U(null), a = j(() => n.intf.connectionCount > 0), l = U(!1), u = j(() => o.value.settings.displayValueOnHover && l.value), c = j(() => ({ "--input": n.intf.isInput, "--output": !n.intf.isInput, "--connected": a.value })), d = j(() => n.intf.component && (!n.intf.isInput || !n.intf.port || n.intf.connectionCount === 0)), p = () => { l.value = !0, s(n.intf) }, h = () => { l.value = !1, s(void 0) }, v = () => { r.value && o.value.hooks.renderInterface.execute({ intf: n.intf, el: r.value }) }, b = () => { let y = o.value.displayedGraph.sidebar; y.nodeId = n.node.id, y.optionName = n.intf.name, y.visible = !0 }; return zt(v), Vn(v), (y, E) => { var N; return S(), H("div", { id: y.intf.id, ref_key: "el", ref: r, class: we(["baklava-node-interface", c.value]) }, [y.intf.port ? (S(), H("div", { key: 0, class: we(["__port", { "--selected": ((N = Q(i)) == null ? void 0 : N.from) === y.intf }]), onPointerover: p, onPointerout: h }, [We(y.$slots, "portTooltip", { showTooltip: u.value }, () => [u.value === !0 ? (S(), H("span", bf, Ee(t(y.intf.value)), 1)) : Se("", !0)])], 34)) : Se("", !0), d.value ? (S(), Oe(ds(y.intf.component), { key: 1, modelValue: y.intf.value, "onUpdate:modelValue": E[0] || (E[0] = k => y.intf.value = k), node: y.node, intf: y.intf, onOpenSidebar: b }, null, 40, ["modelValue", "node", "intf"])) : (S(), H("span", Nf, Ee(y.intf.name), 1))], 10, Ef) } } }), wf = ["id", "data-node-type"], Of = { class: "__title-label" }, xf = { class: "__menu" }, Cf = { class: "__outputs" }, Tf = { class: "__inputs" }, jl = me({ __name: "Node", props: { node: {}, selected: { type: Boolean, default: !1 }, dragging: { type: Boolean } }, emits: ["select", "start-drag"], setup(e, { emit: t }) { let n = e, o = t, { viewModel: s } = Ye(), { graph: i, switchGraph: r } = nt(), a = U(null), l = U(!1), u = U(""), c = U(null), d = U(!1), p = 0, h = 0, v = U(!1), b = j(() => { let A = [{ value: "rename", label: "Rename" }, { value: "delete", label: "Delete" }]; return n.node.type.startsWith(Zt) && A.push({ value: "editSubgraph", label: "Edit Subgraph" }), A }), y = j(() => ({ "--selected": n.selected, "--dragging": n.dragging, "--two-column": !!n.node.twoColumn })), E = j(() => ({ "--reverse-y": n.node.reverseY ?? s.value.settings.nodes.reverseY })), N = j(() => { var A, Z; return { top: `${((A = n.node.position) == null ? void 0 : A.y) ?? 0}px`, left: `${((Z = n.node.position) == null ? void 0 : Z.x) ?? 0}px`, "--width": `${n.node.width ?? s.value.settings.nodes.defaultWidth}px` } }), k = j(() => Object.values(n.node.inputs).filter(A => !A.hidden)), G = j(() => Object.values(n.node.outputs).filter(A => !A.hidden)), C = () => { o("select") }, D = A => { n.selected || C(), o("start-drag", A) }, z = () => { v.value = !0 }, P = async A => { var Z; switch (A) { case "delete": i.value.removeNode(n.node); break; case "rename": u.value = n.node.title, l.value = !0, await In(), (Z = c.value) == null || Z.focus(); break; case "editSubgraph": r(n.node.template); break } }, _ = () => { n.node.title = u.value, l.value = !1 }, M = () => { a.value && s.value.hooks.renderNode.execute({ node: n.node, el: a.value }) }, Y = A => { d.value = !0, p = n.node.width, h = A.clientX, A.preventDefault() }, L = A => { if (!d.value) return; let Z = A.clientX - h, J = p + Z / i.value.scaling, se = s.value.settings.nodes.minWidth, ee = s.value.settings.nodes.maxWidth; n.node.width = Math.max(se, Math.min(ee, J)) }, le = () => { d.value = !1 }; return zt(() => { M(), window.addEventListener("mousemove", L), window.addEventListener("mouseup", le) }), Vn(M), An(() => { window.removeEventListener("mousemove", L), window.removeEventListener("mouseup", le) }), (A, Z) => (S(), H("div", { id: A.node.id, ref_key: "el", ref: a, class: we(["baklava-node", y.value]), style: Ke(N.value), "data-node-type": A.node.type, onPointerdown: C }, [Q(s).settings.nodes.resizable ? (S(), H("div", { key: 0, class: "__resize-handle", onMousedown: Y }, null, 32)) : Se("", !0), We(A.$slots, "title", {}, () => [F("div", { class: "__title", onPointerdown: He(D, ["self", "stop"]), onContextmenu: He(z, ["prevent"]) }, [l.value ? Pt((S(), H("input", { key: 1, ref_key: "renameInputEl", ref: c, "onUpdate:modelValue": Z[1] || (Z[1] = J => u.value = J), type: "text", class: "baklava-input", placeholder: "Node Name", onBlur: _, onKeydown: Pn(_, ["enter"]) }, null, 544)), [[dn, u.value]]) : (S(), H(ae, { key: 0 }, [F("div", Of, Ee(A.node.title), 1), F("div", xf, [oe(Bl, { class: "--clickable", onClick: z }), oe(Q(Ms), { modelValue: v.value, "onUpdate:modelValue": Z[0] || (Z[0] = J => v.value = J), x: 0, y: 0, items: b.value, onClick: P }, null, 8, ["modelValue", "items"])])], 64))], 32)]), We(A.$slots, "content", {}, () => [F("div", { class: we(["__content", E.value]), onKeydown: Z[2] || (Z[2] = Pn(He(() => { }, ["stop"]), ["delete"])) }, [F("div", Cf, [(S(!0), H(ae, null, ct(G.value, J => We(A.$slots, "nodeInterface", { key: J.id, type: "output", node: A.node, intf: J }, () => [oe(Zi, { node: A.node, intf: J }, null, 8, ["node", "intf"])])), 128))]), F("div", Tf, [(S(!0), H(ae, null, ct(k.value, J => We(A.$slots, "nodeInterface", { key: J.id, type: "input", node: A.node, intf: J }, () => [oe(Zi, { node: A.node, intf: J }, null, 8, ["node", "intf"])])), 128))])], 34)])], 46, wf)) } }), Sf = me({ props: { x1: { type: Number, required: !0 }, y1: { type: Number, required: !0 }, x2: { type: Number, required: !0 }, y2: { type: Number, required: !0 }, state: { type: Number, default: tt.NONE }, isTemporary: { type: Boolean, default: !1 } }, setup(e) { let { viewModel: t } = Ye(), { graph: n } = nt(), o = (r, a) => { let l = (r + n.value.panning.x) * n.value.scaling, u = (a + n.value.panning.y) * n.value.scaling; return [l, u] }, s = j(() => { let [r, a] = o(e.x1, e.y1), [l, u] = o(e.x2, e.y2); if (t.value.settings.useStraightConnections) return `M ${r} ${a} L ${l} ${u}`; { let c = .3 * Math.abs(r - l); return `M ${r} ${a} C ${r + c} ${a}, ${l - c} ${u}, ${l} ${u}` } }), i = j(() => ({ "--temporary": e.isTemporary, "--allowed": e.state === tt.ALLOWED, "--forbidden": e.state === tt.FORBIDDEN })); return { d: s, classes: i } } }), Df = ["d"]; function kf(e, t, n, o, s, i) { return S(), H("path", { class: we(["baklava-connection", e.classes]), d: e.d }, null, 10, Df) } var pr = he(Sf, [["render", kf]]); function Wl(e) { return document.getElementById(e.id) } function fn(e) { let t = document.getElementById(e.id), n = t?.getElementsByClassName("__port"); return { node: t?.closest(".baklava-node") ?? null, interface: t, port: n && n.length > 0 ? n[0] : null } } var If = me({ components: { "connection-view": pr }, props: { connection: { type: Object, required: !0 } }, setup(e) { let { graph: t } = nt(), n, o = U({ x1: 0, y1: 0, x2: 0, y2: 0 }), s = j(() => e.connection.isInDanger ? tt.FORBIDDEN : tt.NONE), i = j(() => { var u; return (u = t.value.findNodeById(e.connection.from.nodeId)) == null ? void 0 : u.position }), r = j(() => { var u; return (u = t.value.findNodeById(e.connection.to.nodeId)) == null ? void 0 : u.position }), a = u => u.node && u.interface && u.port ? [u.node.offsetLeft + u.interface.offsetLeft + u.port.offsetLeft + u.port.clientWidth / 2, u.node.offsetTop + u.interface.offsetTop + u.port.offsetTop + u.port.clientHeight / 2] : [0, 0], l = () => { let u = fn(e.connection.from), c = fn(e.connection.to); u.node && c.node && (n || (n = new ResizeObserver(() => { l() }), n.observe(u.node), n.observe(c.node))); let [d, p] = a(u), [h, v] = a(c); o.value = { x1: d, y1: p, x2: h, y2: v } }; return zt(async () => { await In(), l() }), An(() => { n && n.disconnect() }), ze([i, r], () => l(), { deep: !0 }), { d: o, state: s } } }); function Mf(e, t, n, o, s, i) { let r = Yt("connection-view"); return S(), Oe(r, { x1: e.d.x1, y1: e.d.y1, x2: e.d.x2, y2: e.d.y2, state: e.state }, null, 8, ["x1", "y1", "x2", "y2", "state"]) } var Kl = he(If, [["render", Mf]]); function xo(e) { return e.node && e.interface && e.port ? [e.node.offsetLeft + e.interface.offsetLeft + e.port.offsetLeft + e.port.clientWidth / 2, e.node.offsetTop + e.interface.offsetTop + e.port.offsetTop + e.port.clientHeight / 2] : [0, 0] } var Vf = me({ components: { "connection-view": pr }, props: { connection: { type: Object, required: !0 } }, setup(e) { let t = j(() => e.connection ? e.connection.status : tt.NONE); return { d: j(() => { if (!e.connection) return { input: [0, 0], output: [0, 0] }; let o = xo(fn(e.connection.from)), s = e.connection.to ? xo(fn(e.connection.to)) : [e.connection.mx || o[0], e.connection.my || o[1]]; return e.connection.from.isInput ? { input: s, output: o } : { input: o, output: s } }), status: t } } }); function Af(e, t, n, o, s, i) { let r = Yt("connection-view"); return S(), Oe(r, { x1: e.d.input[0], y1: e.d.input[1], x2: e.d.output[0], y2: e.d.output[1], state: e.status, "is-temporary": "" }, null, 8, ["x1", "y1", "x2", "y2", "state"]) } var Gl = he(Vf, [["render", Af]]), Rf = me({ setup() { let { viewModel: e } = Ye(), { graph: t } = nt(), n = U(null), o = $t(e.value.settings.sidebar, "width"), s = j(() => e.value.settings.sidebar.resizable), i = 0, r = 0, a = j(() => { let h = t.value.sidebar.nodeId; return t.value.nodes.find(v => v.id === h) }), l = j(() => ({ width: `${o.value}px` })), u = j(() => a.value ? [...Object.values(a.value.inputs), ...Object.values(a.value.outputs)].filter(v => v.displayInSidebar && v.component) : []), c = () => { t.value.sidebar.visible = !1 }, d = h => { i = o.value, r = h.clientX, window.addEventListener("mousemove", p), window.addEventListener("mouseup", () => { window.removeEventListener("mousemove", p) }, { once: !0 }) }, p = h => { var v, b; let y = ((b = (v = n.value) == null ? void 0 : v.parentElement) == null ? void 0 : b.getBoundingClientRect().width) ?? 500, E = h.clientX - r, N = i - E; N < 300 ? N = 300 : N > .9 * y && (N = .9 * y), o.value = N }; return { el: n, graph: t, resizable: s, node: a, styles: l, displayedInterfaces: u, startResize: d, close: c } } }), $f = { class: "__header" }, Pf = { class: "__node-name" }; function Lf(e, t, n, o, s, i) { return S(), H("div", { ref: "el", class: we(["baklava-sidebar", { "--open": e.graph.sidebar.visible }]), style: Ke(e.styles) }, [e.resizable ? (S(), H("div", { key: 0, class: "__resizer", onMousedown: t[0] || (t[0] = (...r) => e.startResize && e.startResize(...r)) }, null, 32)) : Se("", !0), F("div", $f, [F("button", { tabindex: "-1", class: "__close", onClick: t[1] || (t[1] = (...r) => e.close && e.close(...r)) }, "\xD7"), F("div", Pf, [F("b", null, Ee(e.node ? e.node.title : ""), 1)])]), (S(!0), H(ae, null, ct(e.displayedInterfaces, r => (S(), H("div", { key: r.id, class: "__interface" }, [(S(), Oe(ds(r.component), { modelValue: r.value, "onUpdate:modelValue": a => r.value = a, node: e.node, intf: r }, null, 8, ["modelValue", "onUpdate:modelValue", "node", "intf"]))]))), 128))], 6) } var zl = he(Rf, [["render", Lf]]), Yl = me({ __name: "Minimap", setup(e) { let { viewModel: t } = Ye(), { graph: n } = nt(), o = U(null), s = U(!1), i, r = !1, a = { x1: 0, y1: 0, x2: 0, y2: 0 }, l, u = () => { var D, z; if (!i) return; i.canvas.width = o.value.offsetWidth, i.canvas.height = o.value.offsetHeight; let P = new Map, _ = new Map; for (let A of n.value.nodes) { let Z = Wl(A), J = Z?.offsetWidth ?? 0, se = Z?.offsetHeight ?? 0, ee = ((D = A.position) == null ? void 0 : D.x) ?? 0, xe = ((z = A.position) == null ? void 0 : z.y) ?? 0; P.set(A, { x1: ee, y1: xe, x2: ee + J, y2: xe + se }), _.set(A, Z) } let M = { x1: Number.MAX_SAFE_INTEGER, y1: Number.MAX_SAFE_INTEGER, x2: Number.MIN_SAFE_INTEGER, y2: Number.MIN_SAFE_INTEGER }; for (let A of P.values()) A.x1 < M.x1 && (M.x1 = A.x1), A.y1 < M.y1 && (M.y1 = A.y1), A.x2 > M.x2 && (M.x2 = A.x2), A.y2 > M.y2 && (M.y2 = A.y2); let Y = 50; M.x1 -= Y, M.y1 -= Y, M.x2 += Y, M.y2 += Y, a = M; let L = i.canvas.width / i.canvas.height, le = (a.x2 - a.x1) / (a.y2 - a.y1); if (L > le) { let A = (L - le) * (a.y2 - a.y1) * .5; a.x1 -= A, a.x2 += A } else { let A = a.x2 - a.x1, Z = a.y2 - a.y1, J = (A - L * Z) / L * .5; a.y1 -= J, a.y2 += J } i.clearRect(0, 0, i.canvas.width, i.canvas.height), i.strokeStyle = "white"; for (let A of n.value.connections) { let [Z, J] = xo(fn(A.from)), [se, ee] = xo(fn(A.to)), [xe, pn] = c(Z, J), [pt, ht] = c(se, ee); if (i.beginPath(), i.moveTo(xe, pn), t.value.settings.useStraightConnections) i.lineTo(pt, ht); else { let ut = .3 * Math.abs(xe - pt); i.bezierCurveTo(xe + ut, pn, pt - ut, ht, pt, ht) } i.stroke() } i.strokeStyle = "lightgray"; for (let [A, Z] of P.entries()) { let [J, se] = c(Z.x1, Z.y1), [ee, xe] = c(Z.x2, Z.y2); i.fillStyle = p(_.get(A)), i.beginPath(), i.rect(J, se, ee - J, xe - se), i.fill(), i.stroke() } if (s.value) { let A = v(), [Z, J] = c(A.x1, A.y1), [se, ee] = c(A.x2, A.y2); i.fillStyle = "rgba(255, 255, 255, 0.2)", i.fillRect(Z, J, se - Z, ee - J) } }, c = (D, z) => [(D - a.x1) / (a.x2 - a.x1) * i.canvas.width, (z - a.y1) / (a.y2 - a.y1) * i.canvas.height], d = (D, z) => [D * (a.x2 - a.x1) / i.canvas.width + a.x1, z * (a.y2 - a.y1) / i.canvas.height + a.y1], p = D => { if (D) { let z = D.querySelector(".__content"); if (z) { let _ = h(z); if (_) return _ } let P = h(D); if (P) return P } return "gray" }, h = D => { let z = getComputedStyle(D).backgroundColor; if (z && z !== "rgba(0, 0, 0, 0)") return z }, v = () => { let D = o.value.parentElement.offsetWidth, z = o.value.parentElement.offsetHeight, P = D / n.value.scaling - n.value.panning.x, _ = z / n.value.scaling - n.value.panning.y; return { x1: -n.value.panning.x, y1: -n.value.panning.y, x2: P, y2: _ } }, b = D => { D.button === 0 && (r = !0, y(D)) }, y = D => { if (r) { let [z, P] = d(D.offsetX, D.offsetY), _ = v(), M = (_.x2 - _.x1) / 2, Y = (_.y2 - _.y1) / 2; n.value.panning.x = -(z - M), n.value.panning.y = -(P - Y) } }, E = () => { r = !1 }, N = () => { s.value = !0 }, k = () => { s.value = !1, E() }; ze([s, n.value.panning, () => n.value.scaling, () => n.value.connections.length], () => { u() }); let G = j(() => n.value.nodes.map(D => D.position)), C = j(() => n.value.nodes.map(D => D.width)); return ze([G, C], () => { u() }, { deep: !0 }), zt(() => { i = o.value.getContext("2d"), i.imageSmoothingQuality = "high", u(), l = setInterval(u, 500) }), An(() => { clearInterval(l) }), (D, z) => (S(), H("canvas", { ref_key: "canvas", ref: o, class: "baklava-minimap", onMouseenter: N, onMouseleave: k, onMousedown: He(b, ["self"]), onMousemove: He(y, ["self"]), onMouseup: E, onContextmenu: z[0] || (z[0] = He(() => { }, ["stop", "prevent"])) }, null, 544)) } }), Hf = me({ components: { ContextMenu: Ms, VerticalDots: Bl }, props: { type: { type: String, required: !0 }, title: { type: String, required: !0 } }, setup(e) { let { viewModel: t } = Ye(), { switchGraph: n } = nt(), o = U(!1), s = j(() => e.type.startsWith(Zt)); return { showContextMenu: o, hasContextMenu: s, contextMenuItems: [{ label: "Edit Subgraph", value: "editSubgraph" }, { label: "Delete Subgraph", value: "deleteSubgraph" }], openContextMenu: () => { o.value = !0 }, onContextMenuClick: l => { let u = e.type.substring(Zt.length), c = t.value.editor.graphTemplates.find(d => d.id === u); if (c) switch (l) { case "editSubgraph": n(c); break; case "deleteSubgraph": t.value.editor.removeGraphTemplate(c); break } } } } }), Ff = ["data-node-type"], Uf = { class: "__title" }, Bf = { class: "__title-label" }, jf = { key: 0, class: "__menu" }; function Wf(e, t, n, o, s, i) { let r = Yt("vertical-dots"), a = Yt("context-menu"); return S(), H("div", { class: "baklava-node --palette", "data-node-type": e.type }, [F("div", Uf, [F("div", Bf, Ee(e.title), 1), e.hasContextMenu ? (S(), H("div", jf, [oe(r, { class: "--clickable", onPointerdown: t[0] || (t[0] = He(() => { }, ["stop", "prevent"])), onClick: He(e.openContextMenu, ["stop", "prevent"]) }, null, 8, ["onClick"]), oe(a, { modelValue: e.showContextMenu, "onUpdate:modelValue": t[1] || (t[1] = l => e.showContextMenu = l), x: -100, y: 0, items: e.contextMenuItems, onClick: e.onContextMenuClick, onPointerdown: t[2] || (t[2] = He(() => { }, ["stop", "prevent"])) }, null, 8, ["modelValue", "items", "onClick"])])) : Se("", !0)])], 8, Ff) } var Dl = he(Hf, [["render", Wf]]), Kf = { key: 0 }, ql = me({ __name: "NodePalette", setup(e) { let { viewModel: t } = Ye(), { x: n, y: o } = pf(), { transform: s } = dr(), i = ur(t), r = cn("editorEl"), a = U(null), l = j(() => { if (!a.value || !r?.value) return {}; let { left: c, top: d } = r.value.getBoundingClientRect(); return { top: `${o.value - d}px`, left: `${n.value - c}px` } }), u = (c, d) => { a.value = { type: c, nodeInformation: d }; let p = () => { let h = Le(new d.type); t.value.displayedGraph.addNode(h); let v = r.value.getBoundingClientRect(), [b, y] = s(n.value - v.left, o.value - v.top); h.position.x = b, h.position.y = y, a.value = null, document.removeEventListener("pointerup", p) }; document.addEventListener("pointerup", p) }; return (c, d) => (S(), H(ae, null, [F("div", { class: "baklava-node-palette", onContextmenu: d[0] || (d[0] = He(() => { }, ["stop", "prevent"])) }, [(S(!0), H(ae, null, ct(Q(i), p => (S(), H("section", { key: p.name }, [p.name !== "default" ? (S(), H("h1", Kf, Ee(p.name), 1)) : Se("", !0), (S(!0), H(ae, null, ct(p.nodeTypes, (h, v) => (S(), Oe(Dl, { key: v, type: v, title: h.title, onPointerdown: b => u(v, h) }, null, 8, ["type", "title", "onPointerdown"]))), 128))]))), 128))], 32), oe(ys, { name: "fade" }, { default: Mn(() => [a.value ? (S(), H("div", { key: 0, class: "baklava-dragged-node", style: Ke(l.value) }, [oe(Dl, { type: a.value.type, title: a.value.nodeInformation.title }, null, 8, ["type", "title"])], 4)) : Se("", !0)]), _: 1 })], 64)) } }), Gf = me({ props: { command: { type: String, required: !0 }, title: { type: String, required: !0 }, icon: { type: Object, required: !1, default: void 0 } }, setup() { let { viewModel: e } = Ye(); return { viewModel: e } } }), zf = ["disabled", "title"]; function Yf(e, t, n, o, s, i) { return S(), H("button", { class: "baklava-toolbar-entry baklava-toolbar-button", disabled: !e.viewModel.commandHandler.canExecuteCommand(e.command), title: e.title, onClick: t[0] || (t[0] = r => e.viewModel.commandHandler.executeCommand(e.command)) }, [e.icon ? (S(), Oe(ds(e.icon), { key: 0 })) : (S(), H(ae, { key: 1 }, [Hi(Ee(e.title), 1)], 64))], 8, zf) } var kl = he(Gf, [["render", Yf]]), qf = me({ __name: "Toolbar", setup(e) { let { viewModel: t } = Ye(), n = j(() => t.value.displayedGraph !== t.value.editor.graph), o = j(() => t.value.settings.toolbar.commands), s = j(() => t.value.settings.toolbar.subgraphCommands); return (i, r) => (S(), H("div", { class: "baklava-toolbar", onContextmenu: r[0] || (r[0] = He(() => { }, ["stop", "prevent"])) }, [(S(!0), H(ae, null, ct(o.value, a => (S(), Oe(kl, { key: a.command, command: a.command, title: a.title, icon: a.icon }, null, 8, ["command", "title", "icon"]))), 128)), n.value ? (S(!0), H(ae, { key: 0 }, ct(s.value, a => (S(), Oe(kl, { key: a.command, command: a.command, title: a.title, icon: a.icon }, null, 8, ["command", "title", "icon"]))), 128)) : Se("", !0)], 32)) } }), Xf = { class: "connections-container" }, hr = me({ __name: "Editor", props: { viewModel: {} }, setup(e) { let t = e, n = Symbol("EditorToken"), o = $t(t, "viewModel"); Al(o); let s = U(null); fs("editorEl", s); let i = j(() => t.viewModel.displayedGraph.nodes), r = j(() => t.viewModel.displayedGraph.nodes.map(P => cr($t(P, "position")))), a = j(() => t.viewModel.displayedGraph.connections), l = j(() => t.viewModel.displayedGraph.selectedNodes), u = Jd(), c = Pl(), d = Zd(o), p = Qd(s), h = j(() => ({ ...u.styles.value })), v = U(0); t.viewModel.editor.hooks.load.subscribe(n, P => (v.value++, P)); let b = P => { u.onPointerMove(P), c.onMouseMove(P) }, y = P => { if (P.button === 0) { if (p.onPointerDown(P)) return; P.target === s.value && (C(), u.onPointerDown(P)), c.onMouseDown() } }, E = P => { u.onPointerUp(P), c.onMouseUp() }, N = P => { P.key === "Tab" && P.preventDefault(), t.viewModel.commandHandler.handleKeyDown(P) }, k = P => { t.viewModel.commandHandler.handleKeyUp(P) }, G = P => { ["Control", "Shift"].some(_ => t.viewModel.commandHandler.pressedKeys.includes(_)) || C(), t.viewModel.displayedGraph.selectedNodes.push(P) }, C = () => { t.viewModel.displayedGraph.selectedNodes = [] }, D = P => { for (let _ of t.viewModel.displayedGraph.selectedNodes) { let M = i.value.indexOf(_), Y = r.value[M]; Y.onPointerDown(P), document.addEventListener("pointermove", Y.onPointerMove) } document.addEventListener("pointerup", z) }, z = () => { for (let P of t.viewModel.displayedGraph.selectedNodes) { let _ = i.value.indexOf(P), M = r.value[_]; M.onPointerUp(), document.removeEventListener("pointermove", M.onPointerMove) } document.removeEventListener("pointerup", z) }; return (P, _) => (S(), H("div", { ref_key: "el", ref: s, tabindex: "-1", class: we(["baklava-editor", { "baklava-ignore-mouse": !!Q(c).temporaryConnection.value || Q(u).dragging.value, "--temporary-connection": !!Q(c).temporaryConnection.value, "--start-selection-box": Q(p).startSelection }]), onPointermove: He(b, ["self"]), onPointerdown: y, onPointerup: E, onWheel: _[1] || (_[1] = He((...M) => Q(u).onMouseWheel && Q(u).onMouseWheel(...M), ["self"])), onKeydown: N, onKeyup: k, onContextmenu: _[2] || (_[2] = He((...M) => Q(d).open && Q(d).open(...M), ["self"])) }, [We(P.$slots, "background", {}, () => [oe(nf)]), We(P.$slots, "toolbar", {}, () => [P.viewModel.settings.toolbar.enabled ? (S(), Oe(qf, { key: 0 })) : Se("", !0)]), We(P.$slots, "palette", {}, () => [P.viewModel.settings.palette.enabled ? (S(), Oe(ql, { key: 0 })) : Se("", !0)]), (S(), H("svg", Xf, [(S(!0), H(ae, null, ct(a.value, M => (S(), H("g", { key: M.id + v.value.toString() }, [We(P.$slots, "connection", { connection: M }, () => [oe(Kl, { connection: M }, null, 8, ["connection"])])]))), 128)), We(P.$slots, "temporaryConnection", { temporaryConnection: Q(c).temporaryConnection.value }, () => [Q(c).temporaryConnection.value ? (S(), Oe(Gl, { key: 0, connection: Q(c).temporaryConnection.value }, null, 8, ["connection"])) : Se("", !0)])])), F("div", { class: "node-container", style: Ke(h.value) }, [oe(Cl, { name: "fade" }, { default: Mn(() => [(S(!0), H(ae, null, ct(i.value, (M, Y) => We(P.$slots, "node", { key: M.id + v.value.toString(), node: M, selected: l.value.includes(M), dragging: r.value[Y].dragging.value, onSelect: L => G(M), onStartDrag: D }, () => [oe(jl, { node: M, selected: l.value.includes(M), dragging: r.value[Y].dragging.value, onSelect: L => G(M), onStartDrag: D }, null, 8, ["node", "selected", "dragging", "onSelect"])])), 128))]), _: 3 })], 4), We(P.$slots, "sidebar", {}, () => [P.viewModel.settings.sidebar.enabled ? (S(), Oe(zl, { key: 0 })) : Se("", !0)]), We(P.$slots, "minimap", {}, () => [P.viewModel.settings.enableMinimap ? (S(), Oe(Yl, { key: 0 })) : Se("", !0)]), We(P.$slots, "contextMenu", { contextMenu: Q(d) }, () => [P.viewModel.settings.contextMenu.enabled ? (S(), Oe(Ms, { key: 0, modelValue: Q(d).show.value, "onUpdate:modelValue": _[0] || (_[0] = M => Q(d).show.value = M), items: Q(d).items.value, x: Q(d).x.value, y: Q(d).y.value, onClick: Q(d).onClick }, null, 8, ["modelValue", "items", "x", "y", "onClick"])) : Se("", !0)]), Q(p).isSelecting ? (S(), H("div", { key: 0, class: "selection-box", style: Ke(Q(p).getStyles()) }, null, 4)) : Se("", !0)], 34)) } }); function Jf(e) { let t = U([]), n = U([]); return { pressedKeys: t, handleKeyDown: r => { t.value.includes(r.key) || t.value.push(r.key), !(document.activeElement && lr(document.activeElement)) && n.value.forEach(a => { var l, u; a.keys.every(c => t.value.includes(c)) && ((l = a.options) != null && l.preventDefault && r.preventDefault(), (u = a.options) != null && u.stopPropagation && r.stopPropagation(), e(a.commandName)) }) }, handleKeyUp: r => { let a = t.value.indexOf(r.key); a >= 0 && t.value.splice(a, 1) }, registerHotkey: (r, a, l) => { n.value.push({ keys: r, commandName: a, options: l }) } } } var Xl = () => { let e = U(new Map), t = r => e.value.has(r), n = (r, a) => { if (e.value.has(r)) throw new Error(`Command "${r}" already exists`); e.value.set(r, a) }, o = (r, a = !1, ...l) => { if (!e.value.has(r)) { if (a) throw new Error(`[CommandHandler] Command ${r} not registered`); return } return e.value.get(r).execute(...l) }, s = (r, a = !1, ...l) => { if (!e.value.has(r)) { if (a) throw new Error(`[CommandHandler] Command ${r} not registered`); return !1 } return e.value.get(r).canExecute(l) }, i = Jf(o); return Le({ hasCommand: t, registerCommand: n, executeCommand: o, canExecuteCommand: s, ...i }) }, Zf = me({ props: { intf: { type: Object, required: !0 } }, setup(e) { return { onClick: () => { e.intf.callback && e.intf.callback() } } } }), Qf = ["title"]; function ep(e, t, n, o, s, i) { return S(), H("button", { class: "baklava-button --block", title: e.intf.name, onClick: t[0] || (t[0] = (...r) => e.onClick && e.onClick(...r)) }, Ee(e.intf.name), 9, Qf) } var Jl = he(Zf, [["render", ep]]), Qi = class extends ye { constructor(t, n) { super(t, void 0), this.component = Ze(Jl), this.callback = n, this.setPort(!1) } }, tp = ["title"], np = { class: "__label" }, Zl = me({ __name: "CheckboxInterface", props: { modelValue: { type: Boolean }, intf: {} }, emits: ["update:modelValue"], setup(e, { emit: t }) { let n = t; return (o, s) => (S(), H("div", { class: we(["baklava-checkbox", { "--checked": o.modelValue }]), title: o.intf.name, onClick: s[0] || (s[0] = i => n("update:modelValue", !o.modelValue)) }, [s[1] || (s[1] = F("div", { class: "__checkmark-container" }, [F("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", viewBox: "0 0 18 18" }, [F("path", { class: "__checkmark", d: "M 6 5 L 6 10 L 16 10", transform: "rotate(-45 10 10)" })])], -1)), F("div", np, Ee(o.intf.name), 1)], 10, tp)) } }), er = class extends ye { constructor() { super(...arguments), this.component = Ze(Zl) } }, Il = 9; function op(e) { return "validate" in e } var Co = class extends ye { constructor(t, n, o, s) { super(t, n), this.min = o, this.max = s } validate(t) { return (this.min === void 0 || t >= this.min) && (this.max === void 0 || t <= this.max) } }, mr = (e, t = 3) => { let n = U(null), o = U(!1), s = U(!1), i = U("0"), r = j(() => { let d = e.value.value.toFixed(t); return d.length > Il ? e.value.value.toExponential(Il - 5) : d }), a = d => Number.isNaN(d) ? !1 : op(e.value) ? e.value.validate(d) : !0, l = d => { a(d) && (e.value.value = d) }; return ze(i, () => { s.value = !1 }), { editMode: o, invalid: s, tempValue: i, inputEl: n, stringRepresentation: r, validate: a, setValue: l, enterEditMode: async () => { i.value = e.value.value.toFixed(t), o.value = !0, await In(), n.value && n.value.focus() }, leaveEditMode: () => { let d = parseFloat(i.value); a(d) ? (l(d), o.value = !1) : s.value = !0 } } }, sp = {}, ip = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function rp(e, t) { return S(), H("svg", ip, t[0] || (t[0] = [F("polyline", { points: "6 9 12 15 18 9" }, null, -1)])) } var Es = he(sp, [["render", rp]]), ap = me({ components: { "i-arrow": Es }, props: { intf: { type: Object, required: !0 } }, setup(e) { let t = mr($t(e, "intf"), 0); return { ...t, increment: () => { t.setValue(e.intf.value + 1) }, decrement: () => { t.setValue(e.intf.value - 1) } } } }), lp = { class: "baklava-num-input" }, cp = ["title"], up = { class: "__value" }, dp = { key: 1, class: "__content" }; function fp(e, t, n, o, s, i) { let r = Yt("i-arrow"); return S(), H("div", lp, [F("div", { class: "__button --dec", onClick: t[0] || (t[0] = (...a) => e.decrement && e.decrement(...a)) }, [oe(r)]), e.editMode ? (S(), H("div", dp, [Pt(F("input", { ref: "inputEl", "onUpdate:modelValue": t[2] || (t[2] = a => e.tempValue = a), type: "number", class: we(["baklava-input", { "--invalid": e.invalid }]), style: { "text-align": "right" }, onBlur: t[3] || (t[3] = (...a) => e.leaveEditMode && e.leaveEditMode(...a)), onKeydown: t[4] || (t[4] = Pn((...a) => e.leaveEditMode && e.leaveEditMode(...a), ["enter"])) }, null, 34), [[dn, e.tempValue]])])) : (S(), H("div", { key: 0, class: "__content", onClick: t[1] || (t[1] = (...a) => e.enterEditMode && e.enterEditMode(...a)) }, [F("div", { class: "__label", title: e.intf.name }, Ee(e.intf.name), 9, cp), F("div", up, Ee(e.stringRepresentation), 1)])), F("div", { class: "__button --inc", onClick: t[5] || (t[5] = (...a) => e.increment && e.increment(...a)) }, [oe(r)])]) } var Ql = he(ap, [["render", fp]]), tr = class extends Co { constructor() { super(...arguments), this.component = Ze(Ql) } validate(t) { return Number.isInteger(t) && super.validate(t) } }, pp = { class: "baklava-num-input" }, hp = ["title"], mp = { class: "__value" }, vp = { key: 1, class: "__content" }, ec = me({ __name: "NumberInterface", props: { intf: {} }, setup(e) { let t = e, { editMode: n, invalid: o, tempValue: s, inputEl: i, stringRepresentation: r, enterEditMode: a, leaveEditMode: l, setValue: u } = mr($t(t, "intf")); function c() { let p = parseFloat((t.intf.value + .1).toFixed(3)); u(p) } function d() { let p = parseFloat((t.intf.value - .1).toFixed(3)); u(p) } return (p, h) => (S(), H("div", pp, [F("div", { class: "__button --dec", onClick: d }, [oe(Es)]), Q(n) ? (S(), H("div", vp, [Pt(F("input", { ref_key: "inputEl", ref: i, "onUpdate:modelValue": h[1] || (h[1] = v => be(s) ? s.value = v : null), type: "number", class: we(["baklava-input", { "--invalid": Q(o) }]), style: { "text-align": "right" }, onBlur: h[2] || (h[2] = (...v) => Q(l) && Q(l)(...v)), onKeydown: h[3] || (h[3] = Pn((...v) => Q(l) && Q(l)(...v), ["enter"])) }, null, 34), [[dn, Q(s)]])])) : (S(), H("div", { key: 0, class: "__content", onClick: h[0] || (h[0] = (...v) => Q(a) && Q(a)(...v)) }, [F("div", { class: "__label", title: p.intf.name }, Ee(p.intf.name), 9, hp), F("div", mp, Ee(Q(r)), 1)])), F("div", { class: "__button --inc", onClick: c }, [oe(Es)])])) } }), nr = class extends Co { constructor() { super(...arguments), this.component = Ze(ec) } }, gp = me({ components: { "i-arrow": Es }, props: { intf: { type: Object, required: !0 } }, setup(e) { let t = U(null), n = U(!1), o = j(() => e.intf.items.find(r => typeof r == "string" ? r === e.intf.value : r.value === e.intf.value)), s = j(() => o.value ? typeof o.value == "string" ? o.value : o.value.text : ""), i = r => { e.intf.value = typeof r == "string" ? r : r.value }; return Fl(t, () => { n.value = !1 }), { el: t, open: n, selectedItem: o, selectedText: s, setSelected: i } } }), _p = ["title"], yp = { class: "__selected" }, Ep = { class: "__text" }, bp = { class: "__icon" }, Np = { class: "__dropdown" }, wp = { class: "item --header" }, Op = ["onClick"]; function xp(e, t, n, o, s, i) { let r = Yt("i-arrow"); return S(), H("div", { ref: "el", class: we(["baklava-select", { "--open": e.open }]), title: e.intf.name, onClick: t[0] || (t[0] = a => e.open = !e.open) }, [F("div", yp, [F("div", Ep, Ee(e.selectedText), 1), F("div", bp, [oe(r)])]), oe(ys, { name: "slide-fade" }, { default: Mn(() => [Pt(F("div", Np, [F("div", wp, Ee(e.intf.name), 1), (S(!0), H(ae, null, ct(e.intf.items, (a, l) => (S(), H("div", { key: l, class: we(["item", { "--active": a === e.selectedItem }]), onClick: u => e.setSelected(a) }, Ee(typeof a == "string" ? a : a.text), 11, Op))), 128))], 512), [[Yi, e.open]])]), _: 1 })], 10, _p) } var tc = he(gp, [["render", xp]]), or = class extends ye { constructor(t, n, o) { super(t, n), this.component = Ze(tc), this.items = o } }, Cp = me({ props: { intf: { type: Object, required: !0 } }, setup(e) { let t = U(null), n = mr($t(e, "intf")), o = U(!1), s = U(!1), i = j(() => Math.min(100, Math.max(0, (e.intf.value - e.intf.min) * 100 / (e.intf.max - e.intf.min)))); return { ...n, el: t, percentage: i, mousedown: () => { n.editMode.value || (s.value = !0) }, mouseup: () => { n.editMode.value || (o.value || n.enterEditMode(), s.value = !1, o.value = !1) }, mousemove: c => { if (n.editMode.value) return; let d = Math.max(e.intf.min, Math.min(e.intf.max, (e.intf.max - e.intf.min) * (c.offsetX / t.value.clientWidth) + e.intf.min)); s.value && (n.setValue(d), o.value = !0) }, mouseleave: c => { n.editMode.value || (s.value && (c.offsetX >= t.value.clientWidth ? n.setValue(e.intf.max) : c.offsetX <= 0 && n.setValue(e.intf.min)), s.value = !1, o.value = !1) } } } }), Tp = { key: 0, class: "__content" }, Sp = { class: "__label" }, Dp = { class: "__value" }, kp = { key: 1, class: "__content" }; function Ip(e, t, n, o, s, i) { return S(), H("div", { ref: "el", class: we(["baklava-slider", { "baklava-ignore-mouse": !e.editMode }]), onPointerdown: t[3] || (t[3] = (...r) => e.mousedown && e.mousedown(...r)), onPointerup: t[4] || (t[4] = (...r) => e.mouseup && e.mouseup(...r)), onPointermove: t[5] || (t[5] = (...r) => e.mousemove && e.mousemove(...r)), onPointerleave: t[6] || (t[6] = (...r) => e.mouseleave && e.mouseleave(...r)) }, [F("div", { class: "__slider", style: Ke({ width: e.percentage + "%" }) }, null, 4), e.editMode ? (S(), H("div", kp, [Pt(F("input", { ref: "inputEl", "onUpdate:modelValue": t[0] || (t[0] = r => e.tempValue = r), type: "number", class: we(["baklava-input", { "--invalid": e.invalid }]), style: { "text-align": "right" }, onBlur: t[1] || (t[1] = (...r) => e.leaveEditMode && e.leaveEditMode(...r)), onKeydown: t[2] || (t[2] = Pn((...r) => e.leaveEditMode && e.leaveEditMode(...r), ["enter"])) }, null, 34), [[dn, e.tempValue]])])) : (S(), H("div", Tp, [F("div", Sp, Ee(e.intf.name), 1), F("div", Dp, Ee(e.stringRepresentation), 1)]))], 34) } var nc = he(Cp, [["render", Ip]]), sr = class extends Co { constructor(t, n, o, s) { super(t, n, o, s), this.component = Ze(nc), this.min = o, this.max = s } }, Mp = me({ props: { intf: { type: Object, required: !0 } } }); function Vp(e, t, n, o, s, i) { return S(), H("div", null, Ee(e.intf.value), 1) } var Ap = he(Mp, [["render", Vp]]), ir = class extends ye { constructor(t, n) { super(t, n), this.component = Ze(Ap), this.setPort(!1) } }, Rp = me({ props: { intf: { type: Object, required: !0 }, modelValue: { type: String, required: !0 } }, emits: ["update:modelValue"], setup(e, { emit: t }) { return { v: j({ get: () => e.modelValue, set: o => { t("update:modelValue", o) } }) } } }), $p = ["placeholder", "title"]; function Pp(e, t, n, o, s, i) { return S(), H("div", null, [Pt(F("input", { "onUpdate:modelValue": t[0] || (t[0] = r => e.v = r), type: "text", class: "baklava-input", placeholder: e.intf.name, title: e.intf.name }, null, 8, $p), [[dn, e.v]])]) } var oc = he(Rp, [["render", Pp]]), To = class extends ye { constructor() { super(...arguments), this.component = Ze(oc) } }, Lp = me({ props: { intf: { type: Object, required: !0 }, modelValue: { type: String, required: !0 } }, emits: ["update:modelValue"], setup(e, { emit: t }) { return { v: j({ get: () => e.modelValue, set: o => { t("update:modelValue", o) } }) } } }), Hp = ["placeholder", "title"]; function Fp(e, t, n, o, s, i) { return S(), H("div", null, [Pt(F("textarea", { "onUpdate:modelValue": t[0] || (t[0] = r => e.v = r), rows: "5", class: "baklava-input", placeholder: e.intf.name, title: e.intf.name }, null, 8, Hp), [[dn, e.v]])]) } var sc = he(Lp, [["render", Fp]]), rr = class extends ye { constructor() { super(...arguments), this.component = Ze(sc) } }, Ve = []; for (let e = 0; e < 256; ++e)Ve.push((e + 256).toString(16).slice(1)); function Up(e, t = 0) { return (Ve[e[t + 0]] + Ve[e[t + 1]] + Ve[e[t + 2]] + Ve[e[t + 3]] + "-" + Ve[e[t + 4]] + Ve[e[t + 5]] + "-" + Ve[e[t + 6]] + Ve[e[t + 7]] + "-" + Ve[e[t + 8]] + Ve[e[t + 9]] + "-" + Ve[e[t + 10]] + Ve[e[t + 11]] + Ve[e[t + 12]] + Ve[e[t + 13]] + Ve[e[t + 14]] + Ve[e[t + 15]]).toLowerCase() } var Xi, Bp = new Uint8Array(16); function jp() { if (!Xi) { if (typeof crypto > "u" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"); Xi = crypto.getRandomValues.bind(crypto) } return Xi(Bp) } var Wp = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Ml = { randomUUID: Wp }; function bs(e, t, n) { var o; if (Ml.randomUUID && !e) return Ml.randomUUID(); e = e || {}; let s = e.random ?? ((o = e.rng) == null ? void 0 : o.call(e)) ?? jp(); if (s.length < 16) throw new Error("Random bytes length must be >= 16"); return s[6] = s[6] & 15 | 64, s[8] = s[8] & 63 | 128, Up(s) } var Hn = "SAVE_SUBGRAPH"; function Kp(e, t) { let n = () => { let o = e.value; if (!o.template) throw new Error("Graph template property not set"); o.template.update(o.save()), o.template.panning = o.panning, o.template.scaling = o.scaling }; t.registerCommand(Hn, { canExecute: () => { var o; return e.value !== ((o = e.value.editor) == null ? void 0 : o.graph) }, execute: n }) } var Ns = class extends Vt { constructor() { super(...arguments), this._title = "Subgraph Input", this.inputs = { name: new To("Name", "Input").setPort(!1) }, this.outputs = { placeholder: new ye("Connection", void 0) } } }, ws = class extends At { constructor() { super(...arguments), this._title = "Subgraph Output", this.inputs = { name: new To("Name", "Output").setPort(!1), placeholder: new ye("Connection", void 0) }, this.outputs = { output: new ye("Output", void 0).setHidden(!0) } } }, vr = "CREATE_SUBGRAPH", Vl = [vt, gt]; function Gp(e, t, n) { let o = () => e.value.selectedNodes.filter(i => !Vl.includes(i.type)).length > 0, s = () => { let { viewModel: i } = Ye(), r = e.value, a = e.value.editor; if (r.selectedNodes.length === 0) return; let l = r.selectedNodes.filter(_ => !Vl.includes(_.type)), u = l.flatMap(_ => Object.values(_.inputs)), c = l.flatMap(_ => Object.values(_.outputs)), d = r.connections.filter(_ => !c.includes(_.from) && u.includes(_.to)), p = r.connections.filter(_ => c.includes(_.from) && !u.includes(_.to)), h = r.connections.filter(_ => c.includes(_.from) && u.includes(_.to)), v = l.map(_ => _.save()), b = h.map(_ => ({ id: _.id, from: _.from.id, to: _.to.id })), y = new Map, { xLeft: E, xRight: N, yTop: k } = zp(l); for (let [_, M] of d.entries()) { let Y = new Ns; Y.inputs.name.value = M.to.name, v.push({ ...Y.save(), position: { x: N - i.value.settings.nodes.defaultWidth - 100, y: k + _ * 200 } }), b.push({ id: bs(), from: Y.outputs.placeholder.id, to: M.to.id }), y.set(M.to.id, Y.graphInterfaceId) } for (let [_, M] of p.entries()) { let Y = new ws; Y.inputs.name.value = M.from.name, v.push({ ...Y.save(), position: { x: E + 100, y: k + _ * 200 } }), b.push({ id: bs(), from: M.from.id, to: Y.inputs.placeholder.id }), y.set(M.from.id, Y.graphInterfaceId) } let G = Le(new Qt({ connections: b, nodes: v, inputs: [], outputs: [] }, a)); a.addGraphTemplate(G); let C = a.nodeTypes.get(_t(G)); if (!C) throw new Error("Unable to create subgraph: Could not find corresponding graph node type"); r.activeTransactions++; let D = Le(new C.type); r.addNode(D); let z = Math.round(l.map(_ => _.position.x).reduce((_, M) => _ + M, 0) / l.length), P = Math.round(l.map(_ => _.position.y).reduce((_, M) => _ + M, 0) / l.length); D.position.x = z, D.position.y = P, d.forEach(_ => { r.removeConnection(_), r.addConnection(_.from, D.inputs[y.get(_.to.id)]) }), p.forEach(_ => { r.removeConnection(_), r.addConnection(D.outputs[y.get(_.from.id)], _.to) }), l.forEach(_ => r.removeNode(_)), r.activeTransactions--, t.canExecuteCommand(Hn) && t.executeCommand(Hn), n(G), e.value.panning = { ...r.panning }, e.value.scaling = r.scaling }; t.registerCommand(vr, { canExecute: o, execute: s }) } function zp(e) { let t = e.reduce((s, i) => { let r = i.position.x; return r < s ? r : s }, 1 / 0), n = e.reduce((s, i) => { let r = i.position.y; return r < s ? r : s }, 1 / 0); return { xLeft: e.reduce((s, i) => { let r = i.position.x + i.width; return r > s ? r : s }, -1 / 0), xRight: t, yTop: n } } var Os = class { constructor(t, n) { this.type = t, t === "addNode" ? this.nodeId = n : this.nodeState = n } undo(t) { this.type === "addNode" ? this.removeNode(t) : this.addNode(t) } redo(t) { this.type === "addNode" && this.nodeState ? this.addNode(t) : this.type === "removeNode" && this.nodeId && this.removeNode(t) } addNode(t) { let n = t.editor.nodeTypes.get(this.nodeState.type); if (!n) return; let o = new n.type; t.addNode(o), o.load(this.nodeState), this.nodeId = o.id } removeNode(t) { let n = t.nodes.find(o => o.id === this.nodeId); n && (this.nodeState = n.save(), t.removeNode(n)) } }, xs = class { constructor(t, n) { if (this.type = t, t === "addConnection") this.connectionId = n; else { let o = n; this.connectionState = { id: o.id, from: o.from.id, to: o.to.id } } } undo(t) { this.type === "addConnection" ? this.removeConnection(t) : this.addConnection(t) } redo(t) { this.type === "addConnection" && this.connectionState ? this.addConnection(t) : this.type === "removeConnection" && this.connectionId && this.removeConnection(t) } addConnection(t) { let n = t.findNodeInterface(this.connectionState.from), o = t.findNodeInterface(this.connectionState.to); if (!n || !o) return; let s = t.addConnection(n, o); s && (s.id = this.connectionState.id), this.connectionId = s?.id } removeConnection(t) { let n = t.connections.find(o => o.id === this.connectionId); n && (this.connectionState = { id: n.id, from: n.from.id, to: n.to.id }, t.removeConnection(n)) } }, ar = class { constructor(t) { if (this.type = "transaction", t.length === 0) throw new Error("Can't create a transaction with no steps"); this.steps = t } undo(t) { for (let n = this.steps.length - 1; n >= 0; n--)this.steps[n].undo(t) } redo(t) { for (let n = 0; n < this.steps.length; n++)this.steps[n].redo(t) } }, Cs = "UNDO", Ts = "REDO", Vs = "START_TRANSACTION", As = "COMMIT_TRANSACTION", ic = "CLEAR_HISTORY"; function Yp(e, t) { let n = Symbol("HistoryToken"), o = U(200), s = U([]), i = U(!1), r = U(-1), a = U(!1), l = U([]), u = E => { if (!i.value) if (a.value) l.value.push(E); else { for (r.value !== s.value.length - 1 && (s.value = s.value.slice(0, r.value + 1)), s.value.push(E); s.value.length > o.value;)s.value.shift(); r.value = s.value.length - 1 } }, c = () => { a.value = !0 }, d = () => { a.value = !1, l.value.length > 0 && (u(new ar(l.value)), l.value = []) }, p = () => s.value.length !== 0 && r.value !== -1, h = () => { p() && (i.value = !0, s.value[r.value--].undo(e.value), i.value = !1) }, v = () => s.value.length !== 0 && r.value < s.value.length - 1, b = () => { v() && (i.value = !0, s.value[++r.value].redo(e.value), i.value = !1) }, y = () => { s.value = [], r.value = -1 }; return ze(e, (E, N) => { N && (N.events.addNode.unsubscribe(n), N.events.removeNode.unsubscribe(n), N.events.addConnection.unsubscribe(n), N.events.removeConnection.unsubscribe(n)), E && (E.events.addNode.subscribe(n, k => { u(new Os("addNode", k.id)) }), E.events.removeNode.subscribe(n, k => { u(new Os("removeNode", k.save())) }), E.events.addConnection.subscribe(n, k => { u(new xs("addConnection", k.id)) }), E.events.removeConnection.subscribe(n, k => { u(new xs("removeConnection", k)) })) }, { immediate: !0 }), t.registerCommand(Cs, { canExecute: p, execute: h }), t.registerCommand(Ts, { canExecute: v, execute: b }), t.registerCommand(Vs, { canExecute: () => !a.value, execute: c }), t.registerCommand(As, { canExecute: () => a.value, execute: d }), t.registerCommand(ic, { canExecute: () => s.value.length > 0, execute: y }), t.registerHotkey(["Control", "z"], Cs), t.registerHotkey(["Control", "y"], Ts), Le({ maxSteps: o }) } var Ss = "DELETE_NODES"; function qp(e, t) { t.registerCommand(Ss, { canExecute: () => e.value.selectedNodes.length > 0, execute() { t.executeCommand(Vs); for (let n = e.value.selectedNodes.length - 1; n >= 0; n--) { let o = e.value.selectedNodes[n]; e.value.removeNode(o) } t.executeCommand(As) } }), t.registerHotkey(["Delete"], Ss) } var gr = "SWITCH_TO_MAIN_GRAPH"; function Xp(e, t, n) { t.registerCommand(gr, { canExecute: () => e.value !== e.value.editor.graph, execute: () => { t.executeCommand(Hn), n(e.value.editor.graph) } }) } function Jp(e, t, n) { qp(e, t), Gp(e, t, n), Kp(e, t), Xp(e, t, n) } var Ds = "COPY", ks = "PASTE", rc = "CLEAR_CLIPBOARD"; function Zp(e, t, n) { let o = Symbol("ClipboardToken"), s = U(""), i = U(""), r = j(() => !s.value), a = () => { s.value = "", i.value = "" }, l = () => { let d = e.value.selectedNodes.flatMap(h => [...Object.values(h.inputs), ...Object.values(h.outputs)]), p = e.value.connections.filter(h => d.includes(h.from) || d.includes(h.to)).map(h => ({ from: h.from.id, to: h.to.id })); i.value = JSON.stringify(p), s.value = JSON.stringify(e.value.selectedNodes.map(h => h.save())) }, u = (d, p, h) => { for (let v of d) { let b; if ((!h || h === "input") && (b = Object.values(v.inputs).find(y => y.id === p)), !b && (!h || h === "output") && (b = Object.values(v.outputs).find(y => y.id === p)), b) return b } }, c = () => { if (r.value) return; let d = new Map, p = JSON.parse(s.value), h = JSON.parse(i.value), v = [], b = [], y = e.value; n.executeCommand(Vs); for (let E of p) { let N = t.value.nodeTypes.get(E.type); if (!N) { console.warn(`Node type ${E.type} not registered`); return } let k = new N.type, G = k.id; v.push(k), k.hooks.beforeLoad.subscribe(o, C => { let D = C; return D.position && (D.position.x += 100, D.position.y += 100), k.hooks.beforeLoad.unsubscribe(o), D }), y.addNode(k), k.load({ ...E, id: G }), k.id = G, d.set(E.id, G); for (let C of Object.values(k.inputs)) { let D = bs(); d.set(C.id, D), C.id = D } for (let C of Object.values(k.outputs)) { let D = bs(); d.set(C.id, D), C.id = D } } for (let E of h) { let N = u(v, d.get(E.from), "output"), k = u(v, d.get(E.to), "input"); if (!N || !k) continue; let G = y.addConnection(N, k); G && b.push(G) } return e.value.selectedNodes = v, n.executeCommand(As), { newNodes: v, newConnections: b } }; return n.registerCommand(Ds, { canExecute: () => e.value.selectedNodes.length > 0, execute: l }), n.registerHotkey(["Control", "c"], Ds), n.registerCommand(ks, { canExecute: () => !r.value, execute: c }), n.registerHotkey(["Control", "v"], ks), n.registerCommand(rc, { canExecute: () => !0, execute: a }), Le({ isEmpty: r }) } var ac = "OPEN_SIDEBAR"; function Qp(e, t) { t.registerCommand(ac, { execute: n => { e.value.sidebar.nodeId = n, e.value.sidebar.visible = !0 }, canExecute: () => !0 }) } var eh = (e, t) => { e.displayInSidebar = t }; function th(e, t) { Qp(e, t) } var lc = "ZOOM_TO_FIT_RECT", cc = "ZOOM_TO_FIT_NODES", Is = "ZOOM_TO_FIT_GRAPH"; function nh(e, t, n) { t.registerCommand(lc, { canExecute: () => !0, execute: o => uc(e.value, n, o) }), t.registerCommand(cc, { canExecute: () => !0, execute: o => dc(e.value, n, o) }), t.registerCommand(Is, { canExecute: () => e.value.nodes.length > 0, execute: () => oh(e.value, n) }), t.registerHotkey(["f"], Is) } function uc(e, t, n) { let o = { left: t.zoomToFit.paddingLeft, right: t.zoomToFit.paddingRight, top: t.zoomToFit.paddingTop, bottom: t.zoomToFit.paddingBottom }, i = document.querySelector(".baklava-editor").getBoundingClientRect(), r = Math.max(0, i.width - o.left - o.right), a = Math.max(0, i.height - o.top - o.bottom); n = ih(n); let l = n.x2 - n.x1, u = n.y2 - n.y1, c = l === 0 ? 1 / 0 : r / l, d = u == 0 ? 1 / 0 : a / u, p = Math.min(c, d); (p === 0 || !Number.isFinite(p)) && (p = 1); let h = Math.max(0, r / p - l), v = Math.max(0, a / p - u), b = -n.x1 + o.left / p + h / 2, y = -n.y1 + o.top / p + v / 2; e.panning.x = b, e.panning.y = y, e.scaling = p } function dc(e, t, n) { if (n.length === 0) return; let o = n.map(sh), s = { x1: Math.min(...o.map(i => i.x1)), y1: Math.min(...o.map(i => i.y1)), x2: Math.max(...o.map(i => i.x2)), y2: Math.max(...o.map(i => i.y2)) }; uc(e, t, s) } function oh(e, t) { dc(e, t, e.nodes) } function sh(e) { var t, n; let o = document.getElementById(e.id), s = o?.offsetWidth ?? 0, i = o?.offsetHeight ?? 0, r = ((t = e.position) == null ? void 0 : t.x) ?? 0, a = ((n = e.position) == null ? void 0 : n.y) ?? 0; return { x1: r, y1: a, x2: r + s, y2: a + i } } function ih(e) { return { x1: Math.min(e.x1, e.x2), y1: Math.min(e.y1, e.y2), x2: Math.max(e.x1, e.x2), y2: Math.max(e.y1, e.y2) } } var rh = Object.freeze(Object.defineProperty({ __proto__: null, CLEAR_CLIPBOARD_COMMAND: rc, CLEAR_HISTORY_COMMAND: ic, COMMIT_TRANSACTION_COMMAND: As, COPY_COMMAND: Ds, CREATE_SUBGRAPH_COMMAND: vr, DELETE_NODES_COMMAND: Ss, OPEN_SIDEBAR_COMMAND: ac, PASTE_COMMAND: ks, REDO_COMMAND: Ts, SAVE_SUBGRAPH_COMMAND: Hn, START_SELECTION_BOX_COMMAND: wo, START_TRANSACTION_COMMAND: Vs, SWITCH_TO_MAIN_GRAPH_COMMAND: gr, UNDO_COMMAND: Cs, ZOOM_TO_FIT_GRAPH_COMMAND: Is, ZOOM_TO_FIT_NODES_COMMAND: cc, ZOOM_TO_FIT_RECT_COMMAND: lc }, Symbol.toStringTag, { value: "Module" })), ah = {}, lh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function ch(e, t) { return S(), H("svg", lh, t[0] || (t[0] = [F("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, null, -1), F("path", { d: "M9 13l-4 -4l4 -4m-4 4h11a4 4 0 0 1 0 8h-1" }, null, -1)])) } var uh = he(ah, [["render", ch]]), dh = {}, fh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function ph(e, t) { return S(), H("svg", fh, t[0] || (t[0] = [F("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, null, -1), F("path", { d: "M15 13l4 -4l-4 -4m4 4h-11a4 4 0 0 0 0 8h1" }, null, -1)])) } var hh = he(dh, [["render", ph]]), mh = {}, vh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function gh(e, t) { return S(), H("svg", vh, t[0] || (t[0] = [F("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, null, -1), F("line", { x1: "5", y1: "12", x2: "19", y2: "12" }, null, -1), F("line", { x1: "5", y1: "12", x2: "11", y2: "18" }, null, -1), F("line", { x1: "5", y1: "12", x2: "11", y2: "6" }, null, -1)])) } var _h = he(mh, [["render", gh]]), yh = {}, Eh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function bh(e, t) { return S(), H("svg", Eh, t[0] || (t[0] = [F("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, null, -1), F("path", { d: "M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2" }, null, -1), F("rect", { x: "9", y: "3", width: "6", height: "4", rx: "2" }, null, -1)])) } var Nh = he(yh, [["render", bh]]), wh = {}, Oh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function xh(e, t) { return S(), H("svg", Oh, t[0] || (t[0] = [F("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, null, -1), F("rect", { x: "8", y: "8", width: "12", height: "12", rx: "2" }, null, -1), F("path", { d: "M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2" }, null, -1)])) } var Ch = he(wh, [["render", xh]]), Th = {}, Sh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function Dh(e, t) { return S(), H("svg", Sh, t[0] || (t[0] = [F("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }, null, -1), F("path", { d: "M6 4h10l4 4v10a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2" }, null, -1), F("circle", { cx: "12", cy: "14", r: "2" }, null, -1), F("polyline", { points: "14 4 14 8 8 8 8 4" }, null, -1)])) } var kh = he(Th, [["render", Dh]]), Ih = {}, Mh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function Vh(e, t) { return S(), H("svg", Mh, t[0] || (t[0] = [_o('<path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M10 3h4v4h-4z"></path><path d="M3 17h4v4h-4z"></path><path d="M17 17h4v4h-4z"></path><path d="M7 17l5 -4l5 4"></path><line x1="12" y1="7" x2="12" y2="13"></line>', 6)])) } var Ah = he(Ih, [["render", Vh]]), Rh = {}, $h = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "1.5", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function Ph(e, t) { return S(), H("svg", $h, t[0] || (t[0] = [_o('<path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 1a1 1 0 0 1 1 -1h6a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-6a1 1 0 0 1 -1 -1z"></path><path d="M12 20v.01"></path><path d="M16 20v.01"></path><path d="M8 20v.01"></path><path d="M4 20v.01"></path><path d="M4 16v.01"></path><path d="M4 12v.01"></path><path d="M4 8v.01"></path><path d="M4 4v.01"></path><path d="M8 4v.01"></path><path d="M12 4v.01"></path><path d="M16 4v.01"></path><path d="M20 4v.01"></path><path d="M20 8v.01"></path><path d="M20 12v.01"></path><path d="M20 16v.01"></path><path d="M20 20v.01"></path>', 18)])) } var Lh = he(Rh, [["render", Ph]]), Hh = {}, Fh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "1.5", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function Uh(e, t) { return S(), H("svg", Fh, t[0] || (t[0] = [_o('<path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M4 7l16 0"></path><path d="M10 11l0 6"></path><path d="M14 11l0 6"></path><path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12"></path><path d="M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3"></path>', 6)])) } var Bh = he(Hh, [["render", Uh]]), jh = {}, Wh = { xmlns: "http://www.w3.org/2000/svg", class: "baklava-icon", width: "24", height: "24", viewBox: "0 0 24 24", "stroke-width": "2", stroke: "currentColor", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" }; function Kh(e, t) { return S(), H("svg", Wh, t[0] || (t[0] = [_o('<path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M4 8v-2a2 2 0 0 1 2 -2h2"></path><path d="M4 16v2a2 2 0 0 0 2 2h2"></path><path d="M16 4h2a2 2 0 0 1 2 2v2"></path><path d="M16 20h2a2 2 0 0 0 2 -2v-2"></path><path d="M8 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"></path><path d="M16 16l-2.5 -2.5"></path>', 7)])) } var Gh = he(jh, [["render", Kh]]), fc = { COPY: { command: Ds, title: "Copy", icon: Ch }, PASTE: { command: ks, title: "Paste", icon: Nh }, DELETE_NODES: { command: Ss, title: "Delete selected nodes", icon: Bh }, UNDO: { command: Cs, title: "Undo", icon: uh }, REDO: { command: Ts, title: "Redo", icon: hh }, ZOOM_TO_FIT_GRAPH: { command: Is, title: "Zoom to Fit", icon: Gh }, START_SELECTION_BOX: { command: wo, title: "Box Select", icon: Lh }, CREATE_SUBGRAPH: { command: vr, title: "Create Subgraph", icon: Ah } }, pc = Object.values(fc), hc = { SAVE_SUBGRAPH: { command: Hn, title: "Save Subgraph", icon: kh }, SWITCH_TO_MAIN_GRAPH: { command: gr, title: "Back to Main Graph", icon: _h } }, mc = Object.values(hc), zh = e => !(e instanceof it); function Yh(e, t) { return { switchGraph: o => { let s; if (zh(o)) s = new it(e.value), o.createGraph(s); else { if (o !== e.value.graph) throw new Error("Can only switch using 'Graph' instance when it is the root graph. Otherwise a 'GraphTemplate' must be used."); s = o } t.value && t.value !== e.value.graph && t.value.destroy(), s.panning = s.panning ?? o.panning ?? { x: 0, y: 0 }, s.scaling = s.scaling ?? o.scaling ?? 1, s.selectedNodes = s.selectedNodes ?? [], s.sidebar = s.sidebar ?? { visible: !1, nodeId: "", optionName: "" }, t.value = s } } } function qh(e, t) { e.position = e.position ?? { x: 0, y: 0 }, e.disablePointerEvents = !1, e.twoColumn = e.twoColumn ?? !1, e.width = e.width ?? t.defaultWidth } var Xh = () => ({ useStraightConnections: !1, enableMinimap: !1, toolbar: { enabled: !0, commands: pc, subgraphCommands: mc }, palette: { enabled: !0 }, background: { gridSize: 100, gridDivision: 5, subGridVisibleThreshold: .6 }, sidebar: { enabled: !0, width: 300, resizable: !0 }, displayValueOnHover: !1, nodes: { defaultWidth: 200, maxWidth: 320, minWidth: 150, resizable: !1, reverseY: !1 }, contextMenu: { enabled: !0, additionalItems: [] }, zoomToFit: { paddingLeft: 300, paddingRight: 50, paddingTop: 110, paddingBottom: 50 } }); function _r(e) { let t = U(e ?? new Kn), n = Symbol("ViewModelToken"), o = U(null), s = _i(o), { switchGraph: i } = Yh(t, o), r = j(() => s.value && s.value !== t.value.graph), a = Le(Xh()), l = Xl(), u = Yp(s, l), c = Zp(s, t, l), d = { renderNode: new Ne(null), renderInterface: new Ne(null) }; return Jp(s, l, i), th(s, l), nh(s, l, a), ze(t, (p, h) => { h && (h.events.registerGraph.unsubscribe(n), h.graphEvents.beforeAddNode.unsubscribe(n), p.nodeHooks.beforeLoad.unsubscribe(n), p.nodeHooks.afterSave.unsubscribe(n), p.graphTemplateHooks.beforeLoad.unsubscribe(n), p.graphTemplateHooks.afterSave.unsubscribe(n), p.graph.hooks.load.unsubscribe(n), p.graph.hooks.save.unsubscribe(n)), p && (p.nodeHooks.beforeLoad.subscribe(n, (v, b) => (b.position = v.position ?? { x: 0, y: 0 }, b.width = v.width ?? a.nodes.defaultWidth, b.twoColumn = v.twoColumn ?? !1, v)), p.nodeHooks.afterSave.subscribe(n, (v, b) => (v.position = b.position, v.width = b.width, v.twoColumn = b.twoColumn, v)), p.graphTemplateHooks.beforeLoad.subscribe(n, (v, b) => (b.panning = v.panning, b.scaling = v.scaling, v)), p.graphTemplateHooks.afterSave.subscribe(n, (v, b) => (v.panning = b.panning, v.scaling = b.scaling, v)), p.graph.hooks.load.subscribe(n, (v, b) => (b.panning = v.panning, b.scaling = v.scaling, v)), p.graph.hooks.save.subscribe(n, (v, b) => (v.panning = b.panning, v.scaling = b.scaling, v)), p.graphEvents.beforeAddNode.subscribe(n, v => qh(v, { defaultWidth: a.nodes.defaultWidth })), t.value.registerNodeType(Ns, { category: "Subgraphs" }), t.value.registerNodeType(ws, { category: "Subgraphs" }), i(p.graph)) }, { immediate: !0 }), Le({ editor: t, displayedGraph: s, isSubgraph: r, settings: a, commandHandler: l, history: u, clipboard: c, hooks: d, switchGraph: i }) } var Jh = Object.freeze(Object.defineProperty({ __proto__: null, Connection: pr, ConnectionWrapper: Kl, ContextMenu: Ms, Minimap: Yl, Node: jl, NodeInterface: Zi, NodePalette: ql, Sidebar: zl, TemporaryConnection: Gl }, Symbol.toStringTag, { value: "Module" })); function Zh(e) { let t; return Tl({ setup() { let n = _r(); return t = n, { viewModel: n } }, render() { return ms(hr, { viewModel: this.viewModel }) } }).mount(e), t } return Nc(Qh);
})();
/*! Bundled license information:

@vue/shared/dist/shared.esm-bundler.js:
  (**
  * @vue/shared v3.5.16
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (*! #__NO_SIDE_EFFECTS__ *)

@vue/reactivity/dist/reactivity.esm-bundler.js:
  (**
  * @vue/reactivity v3.5.16
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/runtime-core/dist/runtime-core.esm-bundler.js:
  (**
  * @vue/runtime-core v3.5.16
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/runtime-core/dist/runtime-core.esm-bundler.js:
@vue/runtime-core/dist/runtime-core.esm-bundler.js:
@vue/runtime-core/dist/runtime-core.esm-bundler.js:
@vue/runtime-dom/dist/runtime-dom.esm-bundler.js:
@vue/runtime-dom/dist/runtime-dom.esm-bundler.js:
  (*! #__NO_SIDE_EFFECTS__ *)

@vue/runtime-dom/dist/runtime-dom.esm-bundler.js:
  (**
  * @vue/runtime-dom v3.5.16
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

vue/dist/vue.runtime.esm-bundler.js:
  (**
  * vue v3.5.16
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
*/
//# sourceMappingURL=bundle.js.map